/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (() => {

eval("\n((window) => {\n    const undefinedErr = Error(\"undefined\");\n    function htmltag(name, inner = \"\", Class = \"\") {\n        const output = document.createElement(name);\n        if (output) {\n            if (inner)\n                output.innerText = inner;\n            if (Class)\n                output.classList.add(Class);\n            return output;\n        }\n        else {\n            throw undefinedErr;\n        }\n    }\n    function objectCopy(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    function textCopy(textVal) {\n        const copyFrom = document.createElement(\"textarea\");\n        copyFrom.textContent = textVal;\n        const bodyElm = document.getElementsByTagName(\"body\")[0];\n        bodyElm.appendChild(copyFrom);\n        copyFrom.select();\n        const retVal = document.execCommand(\"copy\");\n        bodyElm.removeChild(copyFrom);\n        return retVal;\n    }\n    class parser_lexicallyAnalyze2AST {\n        constructor(lexically_analyzed) {\n            this.timeline_parsed = lexically_analyzed;\n            this.i_loading = 0;\n        }\n        get now_val() {\n            return this.timeline_parsed[this.i_loading];\n        }\n        set now_val(_) {\n            throw Error(\"now_valにはセットできません\");\n        }\n        get now_val_type() {\n            return this.now_val.type;\n        }\n        set now_val_type(_) {\n            throw Error(\"now_valにはセットできません\");\n        }\n        Normalize() {\n            let output = [];\n            let i;\n            const t = this;\n            const type = () => this.timeline_parsed[i].type;\n            for (i = 0; i < this.timeline_parsed.length; i++) {\n                if (type() === \"bracketL\") {\n                    removeMeaninglessNewLine();\n                }\n                output.push(this.timeline_parsed[i]);\n            }\n            function removeMeaninglessNewLine() {\n                let i_toErrMsg = [i];\n                output.push(t.timeline_parsed[i]);\n                i++;\n                for (; i < t.timeline_parsed.length; i++) {\n                    if (i + 1 === t.timeline_parsed.length) {\n                        t.i_loading = (i_toErrMsg === null || i_toErrMsg === void 0 ? void 0 : i_toErrMsg[1]) || i_toErrMsg[0];\n                        t.error_unexpectedToken(\"]が不足しています\");\n                    }\n                    if (type() === \"bracketL\") {\n                        i_toErrMsg.push(i);\n                        removeMeaninglessNewLine();\n                    }\n                    else if (type() === \"new_line\") {\n                        continue;\n                    }\n                    else if (type() === \"bracketR\") {\n                        i_toErrMsg.pop();\n                        break;\n                    }\n                    output.push(t.timeline_parsed[i]);\n                }\n            }\n            for (let i = 0, isBeforeNewLine = true; i < output.length; i++) {\n                if (output[i].type === \"new_line\") {\n                    if (isBeforeNewLine) {\n                        output.splice(i, 1);\n                        i--;\n                    }\n                    isBeforeNewLine = true;\n                }\n                else {\n                    isBeforeNewLine = false;\n                }\n            }\n            for (let i = output.length - 1; i >= 0; i--) {\n                if (output[i].type === \"new_line\") {\n                    output.pop();\n                }\n                else {\n                    break;\n                }\n            }\n            this.timeline_parsed = output;\n        }\n        parse() {\n            this.Normalize();\n            let output = [];\n            if (this.timeline_parsed.length === 0) {\n                return output;\n            }\n            this.timeline_parsed.push({ type: \"new_line\", value: \"\\n\" });\n            for (this.i_loading = 0; this.i_loading < this.timeline_parsed.length; this.i_loading++) {\n                const data = this.loadStatement();\n                output.push(data);\n                if (this.now_val_type !== \"new_line\") {\n                    this.error_unexpectedToken(\"]のあとにコメント以外の文を書くことはできません\");\n                }\n            }\n            return output;\n        }\n        loadStatement() {\n            let statementList = [];\n            this.checkIsWord();\n            const commmand = this.now_val.value;\n            this.nextVal();\n            const push = () => {\n                statementList.push(this.now_val.value);\n                this.nextVal();\n            };\n            if (commmand === \"move_list\" || commmand === \"mv_ls\") {\n                this.checkIsWord();\n                const arg1 = this.now_val.value;\n                this.nextVal();\n                if (this.now_val_type !== \"bracketL\") {\n                    this.error_unexpectedToken(\"move_listの第二引数は [ から始まる必要があります\");\n                }\n                this.nextVal();\n                const arg2 = [];\n                if (this.now_val_type !== \"bracketR\") {\n                    loop: while (true) {\n                        let list;\n                        switch (this.now_val_type) {\n                            case \"bracketL\":\n                                this.nextVal();\n                                list = this.getMoveListInList(\"bracketR\");\n                                arg2.push({ mode: \"switch\", value: list });\n                                break;\n                            case \"angle_bracketL\":\n                                this.nextVal();\n                                list = this.getMoveListInList(\"angle_bracketR\");\n                                arg2.push({ mode: \"order\", value: list });\n                                break;\n                            case \"braceL\":\n                                this.nextVal();\n                                list = this.getMoveListInList(\"braceR\");\n                                arg2.push({ mode: \"command\", value: list });\n                                break;\n                            case \"word\":\n                                const val = { mode: \"action\", value: [] };\n                                val.value.push(this.now_val.value);\n                                arg2.push(val);\n                                this.nextVal();\n                                break;\n                            default:\n                                this.error_unexpectedToken(\"move_list内のパースエラー　正しい値が入力されているか確認してください\");\n                        }\n                        if (this.now_val_type === \"bracketR\") {\n                            break loop;\n                        }\n                        else if (this.now_val_type === \"commma\") {\n                            this.nextVal();\n                        }\n                        else {\n                            this.error_unexpectedToken(\"コンマかmove_list終了の]が不足しています\");\n                        }\n                    }\n                }\n                statementList = [commmand, arg1, arg2];\n                this.nextVal();\n            }\n            else {\n                statementList = [commmand];\n                while (true) {\n                    if (this.now_val_type === \"word\") {\n                        push();\n                    }\n                    else if (this.now_val_type === \"new_line\") {\n                        break;\n                    }\n                    else {\n                        this.error_unexpectedToken(\"この文字は入力できません\");\n                    }\n                }\n            }\n            return statementList;\n        }\n        isLastValue() {\n            return this.i_loading + 1 >= this.timeline_parsed.length;\n        }\n        getMoveListInList(endType) {\n            let output = [];\n            if (this.now_val_type === endType) {\n                return output;\n            }\n            loop: while (true) {\n                switch (this.now_val_type) {\n                    case \"word\":\n                        output.push(this.now_val.value);\n                        this.nextVal();\n                        break;\n                    default:\n                        this.error_unexpectedToken(\"move_list内のかっこが閉じれていないか引数が不正です\");\n                }\n                switch (this.now_val_type) {\n                    case endType:\n                        this.nextVal();\n                        break loop;\n                    case \"commma\":\n                        this.nextVal();\n                        break;\n                    default:\n                        this.error_unexpectedToken(\"move_list内のかっこが閉じれていないか引数が不正、もしくはコンマが不足しています\");\n                }\n            }\n            return output;\n        }\n        nextVal() {\n            if (this.isLastValue()) {\n                this.error_unexpectedToken(\"内部エラーの可能性があります。このメッセージが出たらお知らせお願いします。\");\n            }\n            this.i_loading++;\n        }\n        nextVal_noerror() {\n            if (!this.isLastValue()) {\n                this.i_loading++;\n            }\n        }\n        checkIsWord() {\n            if (this.now_val_type !== \"word\") {\n                this.error_unexpectedToken();\n            }\n        }\n        checkIsCommma() {\n            if (this.now_val_type !== \"commma\") {\n                this.error_unexpectedToken();\n            }\n        }\n        error_unexpectedToken(errMsg = \"\") {\n            const output_err_where = htmltag(\"span\");\n            output_err_where.appendChild(htmltag(\"span\", \"→→\" + this.now_val.value + \"←←\", \"errMsg\"));\n            if (this.now_val.type !== \"new_line\") {\n                for (let i = this.i_loading + 1; i < this.timeline_parsed.length; i++) {\n                    if (this.timeline_parsed[i].type === \"new_line\") {\n                        break;\n                    }\n                    else {\n                        output_err_where.insertAdjacentText(\"beforeend\", this.timeline_parsed[i].value);\n                    }\n                }\n            }\n            for (let i = this.i_loading - 1; i >= 0; i--) {\n                if (this.timeline_parsed[i].type === \"new_line\") {\n                    break;\n                }\n                else {\n                    output_err_where.insertAdjacentText(\"afterbegin\", this.timeline_parsed[i].value);\n                }\n            }\n            if (this.now_val.type === \"reserved\") {\n                errMsg = \"予約文字です\";\n            }\n            const output = htmltag(\"span\");\n            output.insertAdjacentText(\"beforeend\", \"想定外の値: 「\" + JSON.stringify(this.now_val.value) + \"」\");\n            output.appendChild(htmltag(\"br\"));\n            output.appendChild(output_err_where);\n            output.appendChild(htmltag(\"br\"));\n            output.insertAdjacentText(\"beforeend\", errMsg);\n            throw Error(output.outerHTML);\n        }\n    }\n    class parser_lexicallyAnalyze {\n        constructor(timeline_str) {\n            this.timeline_str = timeline_str;\n            this.timeline_parsed = [];\n            this._now_str = \"\";\n            this.i_nowloadstr = 0;\n        }\n        parse() {\n            this.timeline_parsed = this.lexicalAnalysis();\n            return this.timeline_parsed;\n        }\n        lexicalAnalysis() {\n            let string = this.timeline_str;\n            let output = [];\n            let tmp = \"\";\n            const space = \"\\u{20}\";\n            string = string.replaceAll(/\\\\(\\n|$)/g, \"\");\n            const parsed = (type, value) => ({\n                type: type,\n                value: value,\n            });\n            loop: for (let i = 0; i < string.length; i++) {\n                let char = string[i];\n                let val = parsed(\"\", char);\n                const changeType = (type) => {\n                    val.type = type;\n                };\n                switch (char) {\n                    case \",\":\n                        changeType(\"commma\");\n                        break;\n                    case \"\\n\":\n                        changeType(\"new_line\");\n                        break;\n                    case space:\n                    case \"　\":\n                    case \"\\t\":\n                        push();\n                        continue;\n                    case \"#\":\n                        for (; i < string.length; i++) {\n                            if (string[i] === \"\\n\") {\n                                i--;\n                                continue loop;\n                            }\n                        }\n                        continue;\n                    case \"{\":\n                        changeType(\"braceL\");\n                        break;\n                    case \"}\":\n                        changeType(\"braceR\");\n                        break;\n                    case \"[\":\n                        changeType(\"bracketL\");\n                        break;\n                    case \"]\":\n                        changeType(\"bracketR\");\n                        break;\n                    case \"<\":\n                        changeType(\"angle_bracketL\");\n                        break;\n                    case \">\":\n                        changeType(\"angle_bracketR\");\n                        break;\n                    case \"(\":\n                    case \"(\":\n                    case \")\":\n                    case '\"':\n                    case \"'\":\n                    case \"!\":\n                    case \"$\":\n                    case \"%\":\n                    case \"&\":\n                    case \"=\":\n                    case \"^\":\n                    case \"~\":\n                    case \"*\":\n                    case \"?\":\n                    case \";\":\n                    case \"`\":\n                        changeType(\"reserved\");\n                        break;\n                    default:\n                        tmp += char;\n                        continue loop;\n                }\n                push();\n                output.push(val);\n            }\n            push();\n            function push() {\n                if (tmp.length !== 0) {\n                    output.push(parsed(\"word\", tmp));\n                    tmp = \"\";\n                }\n            }\n            return output;\n        }\n    }\n    class OperateURL {\n        constructor(_URL = location.href, autochange = true) {\n            this._href = _URL;\n            this._urlAPI = new URL(this._href);\n            this.autochange = autochange;\n        }\n        getParam(param) {\n            return decodeURIComponent(this._urlAPI.searchParams.get(param) || \"\");\n        }\n        setParam(name, value = \"\") {\n            this._urlAPI.searchParams.set(name, encodeURIComponent(value));\n            if (this.autochange) {\n                this._setURL(this._urlAPI.href);\n            }\n        }\n        get hash() {\n            return this._urlAPI.hash;\n        }\n        set hash(val) {\n            this._setURL(`#${val}`);\n        }\n        get href() {\n            return (this._urlAPI.protocol +\n                \"//\" +\n                this._urlAPI.host +\n                this._urlAPI.pathname +\n                \"?TL=\" +\n                encodeURIComponent(this.getParam(\"TL\")));\n        }\n        set href(val) {\n            this._urlAPI.href = val;\n        }\n        _setURL(arg3) {\n            if (this.autochange) {\n                history.replaceState(\"\", \"\", arg3);\n            }\n        }\n        _reflesh() {\n            this._urlAPI = new URL(this._href);\n        }\n    }\n    const url = new OperateURL(undefined, false);\n    class timeline {\n        constructor() {\n            this.current = new Array();\n            this.switchData = new Array();\n            this.cardData = new Array();\n            this.comment = new Array();\n            this.color = undefined;\n            this.place_of_currentTimeline = 0;\n        }\n        move(OrderValue, id = this.ID_of_firstChara(), canMoveWithout1stChara = false) {\n            this.setColor(id, this.place_of_currentTimeline);\n            if (id !== this.ID_of_firstChara() && canMoveWithout1stChara === false) {\n                throw new Error(\"最初のキャラ以外は操作できません\");\n            }\n            const moveChara_nowOrderValue = this.get_chara_by_ID(id).timeline_OrderValue;\n            let OrderValue_diff_between_1stchara_and_movechara = moveChara_nowOrderValue - this.OrderValue_of_firstChara();\n            let calculated_moved_OrderValue = moveChara_nowOrderValue +\n                OrderValue -\n                OrderValue_diff_between_1stchara_and_movechara;\n            this.pushChara(id, calculated_moved_OrderValue);\n            this.nextturn();\n        }\n        setColor(chara, place) {\n            if (this.color) {\n                this.comment.push([\"color\", chara, place, this.color]);\n                this.color = undefined;\n            }\n        }\n        setChara(id, initOrderValue) {\n            this.pushChara(id, initOrderValue);\n        }\n        place_to_moved(calculated_moved_OrderValue) {\n            let place_to_moved = -1;\n            for (let i = this.current.length - 1; i > this.place_of_currentTimeline; i--) {\n                if (calculated_moved_OrderValue >= this.current[i].timeline_OrderValue) {\n                    place_to_moved = i;\n                    break;\n                }\n            }\n            let output;\n            if (place_to_moved === -1) {\n                output = this.place_of_currentTimeline + 1;\n            }\n            else {\n                output = place_to_moved + 1;\n            }\n            return output;\n        }\n        pushChara(id, calculated_moved_OrderValue) {\n            let tmp_movechara;\n            try {\n                tmp_movechara = objectCopy(this.get_chara_by_ID(id));\n            }\n            catch (_a) {\n                tmp_movechara = { id };\n            }\n            tmp_movechara.timeline_OrderValue = calculated_moved_OrderValue;\n            let place_to_moved = this.place_to_moved(calculated_moved_OrderValue);\n            this.current.splice(place_to_moved, 0, tmp_movechara);\n        }\n        addChara(id, initOrderValue) {\n            let chara = {\n                id: id,\n                timeline_OrderValue: initOrderValue,\n                type: \"chara\",\n            };\n            this.current.splice(this.place_of_currentTimeline, 0, chara);\n        }\n        addSkillCard(id, OrderValue, time) {\n            let current_card;\n            let isFoundCard = true;\n            try {\n                current_card = this.get_chara_by_ID(id);\n            }\n            catch (_a) {\n                isFoundCard = false;\n            }\n            if (isFoundCard) {\n                if (current_card) {\n                    if (current_card.type !== \"skillcard\")\n                        throw Error(\"指定された名前はスキルカードではありません\");\n                    current_card.time = time;\n                    this.current[this.placeToChara(id)] = current_card;\n                }\n                else {\n                    throw Error(\"ここは実行されないはず\");\n                }\n            }\n            else {\n                let target_ov = this.OrderValue_of_firstChara() + OrderValue;\n                let target_place = this.place_to_moved(target_ov);\n                this.current.splice(target_place, 0, {\n                    type: \"skillcard\",\n                    time,\n                    id,\n                    timeline_OrderValue: target_ov,\n                    OrderValue,\n                });\n                this.cardData.push([this.place_of_currentTimeline, id]);\n            }\n        }\n        switchChara(id_currentChara, id_switchToChara) {\n            this.switchData.push([\n                this.place_of_currentTimeline,\n                id_currentChara,\n                id_switchToChara,\n            ]);\n            this.setColor(id_currentChara, this.place_of_currentTimeline);\n            if (id_currentChara === this.ID_of_firstChara()) {\n                this.current[this.placeToChara(id_currentChara)].id = id_switchToChara;\n                this.current[this.placeToChara(id_switchToChara)].timeline_OrderValue =\n                    this.OrderValue_of_firstChara();\n            }\n            else {\n                this.switchSupportChara(id_currentChara, id_switchToChara);\n            }\n        }\n        switchSupportChara(id_currentChara, id_switchToChara) {\n            this.current.splice(this.placeToChara(id_currentChara), 1);\n            this.addChara(id_switchToChara, this.OrderValue_of_firstChara());\n        }\n        inited() {\n            this.current.sort(function (a, b) {\n                const a_OrderValue = a.timeline_OrderValue;\n                const b_OrderValue = b.timeline_OrderValue;\n                if (a_OrderValue < b_OrderValue)\n                    return -1;\n                if (a_OrderValue > b_OrderValue)\n                    return 1;\n                return 0;\n            });\n            this.place_of_currentTimeline = 0;\n        }\n        get firstChara() {\n            return this.current[this.place_of_currentTimeline];\n        }\n        set firstChara(_) {\n            throw Error(\"firstCharaにはセットできません\");\n        }\n        OrderValue_of_firstChara() {\n            return this.firstChara.timeline_OrderValue;\n        }\n        ID_of_firstChara() {\n            return this.firstChara.id;\n        }\n        nextturn() {\n            var _a;\n            this.place_of_currentTimeline++;\n            if (((_a = this.firstChara) === null || _a === void 0 ? void 0 : _a.type) === \"skillcard\") {\n                this.firstChara.time--;\n                if (this.firstChara.time === 0) {\n                    this.nextturn();\n                }\n                else if (this.firstChara.time < 0) {\n                    throw Error(\"skillcardのtimeに0未満の数値\");\n                }\n                else {\n                    this.move(this.firstChara.OrderValue, this.ID_of_firstChara(), false);\n                }\n            }\n        }\n        get_chara_by_ID(id) {\n            return this.current[this.placeToChara(id)];\n        }\n        placeToChara(id) {\n            for (let i = this.place_of_currentTimeline; i < this.current.length; i++) {\n                if (this.current[i].id === id) {\n                    return i;\n                }\n            }\n            throw Error(\"Not Found!IDに誤りがあります\");\n        }\n    }\n    class chara {\n        constructor(id, SPD, SPD_buff, LoadFactorReduce = 0) {\n            this.id = id;\n            this.SPD = SPD;\n            this.SPD_buff = SPD_buff;\n            this.LoadFactorReduce = LoadFactorReduce;\n        }\n        calculateOrderValue(LoadFactor, LoadFactorReduce = 0) {\n            const SPD = this.SPD;\n            const SPD_buff = this.SPD_buff / 100;\n            let OrderValueRadix = Math.min(Math.max(124 - Math.floor(SPD / 2), 0), 100);\n            let OrderValue = Math.floor(OrderValueRadix *\n                (LoadFactor / 100) *\n                (1 - LoadFactorReduce) *\n                (1 - SPD_buff));\n            return Math.max(Math.min(OrderValue, 500), 15);\n        }\n        initOrderValue() {\n            return this.calculateOrderValue(100, 0);\n        }\n    }\n    window.onload = () => {\n        const input_elm = document.getElementById(\"input_txt\");\n        if (!input_elm) {\n            throw undefinedErr;\n        }\n        const TLparam = url.getParam(\"TL\");\n        if (typeof TLparam !== null) {\n            input_elm.textContent = TLparam;\n        }\n        input_elm.oninput = main;\n        const elm_csvDownload = document.getElementById(\"csvDownload\");\n        if (elm_csvDownload)\n            elm_csvDownload.onclick = outputAsCSV;\n        const elm_copyTL = document.getElementById(\"copyTL\");\n        if (elm_copyTL)\n            elm_copyTL.onclick = copyDataAsURL;\n        const elm_log_convertedTL = document.getElementById(\"log_convertedTL\");\n        if (elm_log_convertedTL)\n            elm_log_convertedTL.onclick = printConvertedTL;\n        const elm_copy_ConvertedTL = document.getElementById(\"copy_ConvertedTL\");\n        if (elm_copy_ConvertedTL)\n            elm_copy_ConvertedTL.onclick = copyConvertedTL;\n        const elm_jumpTwitter = document.getElementById(\"jumpTwitter\");\n        if (elm_jumpTwitter)\n            elm_jumpTwitter.onclick = () => {\n                window.open(\"https://twitter.com/Y52en/status/1402239605978517505?s=20\", \"_blank\");\n            };\n        const elm_unzipMoveList = document.getElementById(\"unzipMoveList\");\n        if (elm_unzipMoveList)\n            elm_unzipMoveList.onclick = () => {\n                const elm_pop11 = document.getElementById(\"pop11\");\n                if (elm_pop11)\n                    elm_pop11.checked = true;\n            };\n        const elm_Set_onbeforeunload = document.getElementById(\"isSet_onbeforeunload\");\n        if (!elm_Set_onbeforeunload)\n            throw undefinedErr;\n        window.onbeforeunload = function (e) {\n            if (input_elm.value.length !== 0 && elm_Set_onbeforeunload.checked) {\n                e.preventDefault();\n                e.returnValue = \"ページから離れますか？\";\n            }\n        };\n        input_elm.addEventListener(\"keydown\", (e) => {\n            if (e.key === \"c\" && e.ctrlKey) {\n                let cursorPlace_start = input_elm.selectionStart;\n                let cursorPlace_end = input_elm.selectionEnd;\n                if (cursorPlace_start === cursorPlace_end) {\n                    let textValue = input_elm.value;\n                    const numOfLines_start = [\n                        ...textValue\n                            .slice(0, cursorPlace_start)\n                            .matchAll(/\\n/g),\n                    ].length;\n                    const beforeLines_regex = \"^(.*\\\\n){\" + numOfLines_start + \"}\";\n                    textCopy(textValue.replace(new RegExp(beforeLines_regex + \"(.*)($|[\\\\s\\\\S]*$)\"), \"$2\"));\n                    return false;\n                }\n            }\n            return true;\n        });\n        input_elm.addEventListener(\"keydown\", (e) => {\n            if (e.key === \"/\" && e.ctrlKey) {\n                let cursorPlace_start = input_elm.selectionStart;\n                let cursorPlace_end = input_elm.selectionEnd;\n                let textValue = input_elm.value;\n                const numOfLines_start = [\n                    ...textValue\n                        .slice(0, cursorPlace_start)\n                        .matchAll(/\\n/g),\n                ].length;\n                const numOfLines_end = [\n                    ...textValue\n                        .slice(0, cursorPlace_end)\n                        .matchAll(/\\n/g),\n                ].length;\n                for (let i = numOfLines_start; i <= numOfLines_end; i++) {\n                    const beforeLines_regex = \"^(.*\\n){\" + i + \"}\";\n                    if (new RegExp(beforeLines_regex + \"( )*#\").test(textValue)) {\n                        textValue = textValue.replace(new RegExp(\"(\" + beforeLines_regex + \"( )*)#\"), \"$1\");\n                        if (i === numOfLines_start) {\n                            cursorPlace_start--;\n                        }\n                        cursorPlace_end--;\n                    }\n                    else {\n                        textValue = textValue.replace(new RegExp(\"(\" + beforeLines_regex + \")\"), \"$1#\");\n                        if (i === numOfLines_start) {\n                            cursorPlace_start++;\n                        }\n                        cursorPlace_end++;\n                    }\n                }\n                input_elm.value = textValue;\n                input_elm.setSelectionRange(cursorPlace_start, cursorPlace_end);\n                main();\n            }\n        });\n        input_elm.addEventListener(\"keydown\", (e) => {\n            if ((e.key === \"[\" || e.key === \"]\") && e.ctrlKey) {\n                let cursorPlace_start = input_elm.selectionStart;\n                let cursorPlace_end = input_elm.selectionEnd;\n                let textValue = input_elm.value;\n                const numOfLines_start = [\n                    ...textValue\n                        .slice(0, cursorPlace_start)\n                        .matchAll(/\\n/g),\n                ].length;\n                const numOfLines_end = [\n                    ...textValue\n                        .slice(0, cursorPlace_end)\n                        .matchAll(/\\n/g),\n                ].length;\n                for (let i = numOfLines_start; i <= numOfLines_end; i++) {\n                    const beforeLines_regex = \"^(.*\\n){\" + i + \"}\";\n                    const beforeReplace_textValue = textValue;\n                    if (e.key === \"[\") {\n                        textValue = textValue.replace(new RegExp(\"(\" + beforeLines_regex + \") \"), \"$1\");\n                        if (beforeReplace_textValue !== textValue) {\n                            if (i === numOfLines_start) {\n                                cursorPlace_start--;\n                            }\n                            cursorPlace_end--;\n                        }\n                    }\n                    else {\n                        textValue = textValue.replace(new RegExp(\"(\" + beforeLines_regex + \")\"), \"$1 \");\n                        if (beforeReplace_textValue !== textValue) {\n                            if (i === numOfLines_start) {\n                                cursorPlace_start++;\n                            }\n                            cursorPlace_end++;\n                        }\n                    }\n                }\n                input_elm.value = textValue;\n                input_elm.setSelectionRange(cursorPlace_start, cursorPlace_end);\n                main();\n            }\n        });\n        main();\n    };\n    let tableData;\n    let convertedTLdata;\n    function main() {\n        var _a, _b, _c, _d;\n        const elm_input_txt = document.getElementById(\"input_txt\");\n        let str;\n        if (elm_input_txt) {\n            str = elm_input_txt.value;\n        }\n        else {\n            throw undefinedErr;\n        }\n        url.setParam(\"TL\", str);\n        convertedTLdata = { main: [], set: [] };\n        let chara_list = {};\n        let TL = new timeline();\n        let chara_move_list = {};\n        const err = document.getElementById(\"error\");\n        const info = document.getElementById(\"info\");\n        if (!err || !info) {\n            throw undefinedErr;\n        }\n        err.innerHTML = \"\";\n        info.innerHTML = \"\";\n        let parsed_tldata;\n        try {\n            const tl_parser_lexicallyAnalyze = new parser_lexicallyAnalyze(str);\n            const lexicallyAnalyzed = tl_parser_lexicallyAnalyze.parse();\n            const tl_parser_AST = new parser_lexicallyAnalyze2AST(lexicallyAnalyzed);\n            parsed_tldata = tl_parser_AST.parse();\n        }\n        catch (e) {\n            err.innerHTML = e;\n            throw e;\n        }\n        const mode_list = {\n            init: \"init\",\n            start: \"start\",\n            start_sort: \"start_sort\",\n            sorting: \"sorting\",\n            waiting_mode: \"waiting_mode\",\n        };\n        let mode = mode_list.init;\n        for (let i = 0; i < parsed_tldata.length; i++) {\n            try {\n                const load_text_command = (_a = parsed_tldata[i]) === null || _a === void 0 ? void 0 : _a[0];\n                const load_text_arg1 = (_b = parsed_tldata[i]) === null || _b === void 0 ? void 0 : _b[1];\n                const load_text_arg2 = (_c = parsed_tldata[i]) === null || _c === void 0 ? void 0 : _c[2];\n                const load_text_arg3 = (_d = parsed_tldata[i]) === null || _d === void 0 ? void 0 : _d[3];\n                let id, SPD, buff, LoadFactor, LoadFactor_list, to, from, ordervalue;\n                switch (mode) {\n                    case mode_list.init:\n                        switch (load_text_command) {\n                            case \"set\":\n                                id = load_text_arg1.toString();\n                                SPD = Number(load_text_arg2);\n                                buff = Number(load_text_arg3) || 0;\n                                chara_list[id] = new chara(id, SPD, buff);\n                                TL.setChara(id, chara_list[id].initOrderValue());\n                                if (convertedTLdata.set.length === 0) {\n                                    convertedTLdata.set = [parsed_tldata[i]];\n                                }\n                                else {\n                                    convertedTLdata.set.push(parsed_tldata[i]);\n                                }\n                                break;\n                            case \"start\":\n                                mode = mode_list.start;\n                                TL.inited();\n                                break;\n                            case \"start_sort\":\n                                mode = mode_list.start_sort;\n                                TL.inited();\n                                break;\n                            case \"\":\n                                break;\n                            default:\n                                throw Error(\"need 'start'\");\n                        }\n                        break;\n                    case mode_list.start:\n                        var statement = parsed_tldata[i];\n                        if (statement[0] !== \"mv_ls\" && statement[0] !== \"move_list\") {\n                            mainMode(...statement);\n                        }\n                        else {\n                            throw Error(\"start_sort ~ end_sort内にmove_listを書いてください\");\n                        }\n                        break;\n                    case mode_list.start_sort:\n                        switch (load_text_command) {\n                            case \"move_list\":\n                            case \"mv_ls\":\n                                id = load_text_arg1;\n                                LoadFactor_list = load_text_arg2;\n                                chara_move_list[id] = LoadFactor_list;\n                                break;\n                            case \"end_sort\":\n                                sorting();\n                                mode = mode_list.waiting_mode;\n                                break;\n                            case \"\":\n                                break;\n                            default:\n                                throw Error(\"no command found:「\" + load_text_command + \"」\");\n                        }\n                        break;\n                    case mode_list.waiting_mode:\n                        switch (load_text_command) {\n                            case \"start\":\n                                mode = mode_list.start;\n                                break;\n                            case \"start_sort\":\n                                mode = mode_list.start_sort;\n                                break;\n                            case \"\":\n                                break;\n                            default:\n                                throw Error(\"need 'start'\");\n                        }\n                        break;\n                    default:\n                        throw Error(\"内部エラー\");\n                }\n                function sorting() {\n                    var _a;\n                    while (true) {\n                        const id = TL.ID_of_firstChara();\n                        if (((_a = chara_move_list[id]) === null || _a === void 0 ? void 0 : _a[0]) === undefined) {\n                            let output = {};\n                            Object.keys(chara_move_list).forEach(function (key) {\n                                if (chara_move_list[key].length !== 0) {\n                                    output[key] = chara_move_list[key];\n                                }\n                            });\n                            if (Object.keys(output).length !== 0) {\n                                if (!info)\n                                    throw undefinedErr;\n                                info.insertAdjacentText(\"beforeend\", \"ⓘinfo :move_listに使われていないスキルがあります:\" +\n                                    JSON.stringify(Object.fromEntries(Object.entries(output).map(([key, value]) => [\n                                        key,\n                                        value.map((x) => {\n                                            if (x.value.length === 1) {\n                                                x.value = x.value[0];\n                                            }\n                                            return x.value;\n                                        }),\n                                    ]))).replaceAll('\"', \"\"));\n                            }\n                            break;\n                        }\n                        const input = chara_move_list[id].shift();\n                        if (!input)\n                            throw Error(\"内部エラーの可能性があります。このメッセージが出たらお知らせお願いします。\");\n                        try {\n                            if (input.mode === \"order\") {\n                                const [Color_OrderValue] = input.value;\n                                const Color = Color_OrderValue.match(/^[a-zA-Z]/g);\n                                const OrderValue = Color_OrderValue.match(/\\d+/g);\n                                if (Color)\n                                    mainMode(\"color\", Color[0]);\n                                if (OrderValue) {\n                                    mainMode(\"order\", id, OrderValue[0]);\n                                }\n                                else {\n                                    throw Error(\"硬直が見つかりませんでした\");\n                                }\n                            }\n                            else if (input.mode === \"action\") {\n                                const [Color_LoadFactor] = input.value;\n                                const Color = Color_LoadFactor.match(/^[a-zA-Z]/g);\n                                const LoadFactor = Color_LoadFactor.match(/\\d+/g);\n                                if (Color)\n                                    mainMode(\"color\", Color[0]);\n                                if (LoadFactor) {\n                                    mainMode(\"action\", id, LoadFactor[0]);\n                                }\n                                else {\n                                    throw Error(\"硬直値が見つかりませんでした\");\n                                }\n                            }\n                            else if (input.mode === \"switch\") {\n                                const [to_name, SPD, buff] = input.value;\n                                mainMode(\"switch\", id, to_name, SPD, buff || \"0\");\n                                chara_move_list[to_name] = chara_move_list[id];\n                                chara_move_list[id] = [];\n                            }\n                            else if (input.mode === \"command\") {\n                                mainMode(...input.value);\n                            }\n                            else {\n                                throw Error(\"テキストのパースエラー\");\n                            }\n                        }\n                        catch (e) {\n                            throw Error(e + \":  \" + JSON.stringify(input.value) + \" \");\n                        }\n                    }\n                }\n                function mainMode(...arg) {\n                    const [load_text_command, load_text_arg1, load_text_arg2, load_text_arg3, load_text_arg4,] = arg;\n                    if (load_text_command !== \"\" && load_text_command !== \"end\") {\n                        if (convertedTLdata.main.length === 0) {\n                            convertedTLdata.main = [arg.filter((x) => x || x === \"0\")];\n                        }\n                        else {\n                            convertedTLdata.main.push(arg.filter((x) => x || x === \"0\"));\n                        }\n                    }\n                    let id, buff;\n                    switch (load_text_command) {\n                        case \"buffset\":\n                        case \"b\":\n                            id = load_text_arg1;\n                            buff = Number(load_text_arg2) || 0;\n                            chara_list[id].SPD_buff = buff;\n                            break;\n                        case \"buffadd\":\n                        case \"b+\":\n                            id = load_text_arg1;\n                            buff = Number(load_text_arg2) || 0;\n                            chara_list[id].SPD_buff += buff;\n                            break;\n                        case \"buffminus\":\n                        case \"b-\":\n                            id = load_text_arg1;\n                            buff = Number(load_text_arg2) || 0;\n                            chara_list[id].SPD_buff -= buff;\n                            break;\n                        case \"add\":\n                        case \"a\":\n                            id = load_text_arg1;\n                            SPD = Number(load_text_arg2);\n                            buff = Number(load_text_arg3) || 0;\n                            chara_list[id] = new chara(id, SPD, buff);\n                            TL.addChara(id, chara_list[id].initOrderValue());\n                            break;\n                        case \"move\":\n                        case \"m\":\n                            LoadFactor = Number(load_text_arg1);\n                            id = load_text_arg2;\n                            const canMoveWithout1stChara = load_text_arg3 === \"true\";\n                            TL.move(chara_list[TL.ID_of_firstChara()].calculateOrderValue(LoadFactor), id, canMoveWithout1stChara);\n                            break;\n                        case \"action\":\n                        case \"ac\":\n                            id = load_text_arg1;\n                            LoadFactor = Number(load_text_arg2);\n                            const canMoveWithout1stChara_act = load_text_arg3 === \"true\";\n                            TL.move(chara_list[TL.ID_of_firstChara()].calculateOrderValue(LoadFactor), id, canMoveWithout1stChara_act);\n                            break;\n                        case \"order\":\n                            id = load_text_arg1;\n                            ordervalue = Number(load_text_arg2);\n                            TL.move(ordervalue, id, false);\n                            break;\n                        case \"switch\":\n                        case \"sw\":\n                            to = load_text_arg1;\n                            from = load_text_arg2;\n                            SPD = Number(load_text_arg3);\n                            buff = Number(load_text_arg4) || 0;\n                            TL.switchChara(to, from);\n                            chara_list[from] = new chara(from, SPD, buff);\n                            break;\n                        case \"color\":\n                        case \"c\":\n                            var color = load_text_arg1;\n                            TL.color = color;\n                            break;\n                        case \"skillcard\":\n                        case \"sc\":\n                            var name = load_text_arg1;\n                            var spd = Number(load_text_arg2);\n                            LoadFactor = Number(load_text_arg3);\n                            var time = Number(load_text_arg4);\n                            var skillcard = new chara(name, spd, 0);\n                            chara_list[name] = skillcard;\n                            TL.addSkillCard(name, skillcard.calculateOrderValue(LoadFactor), time);\n                            break;\n                        case \"end\":\n                            mode = mode_list.waiting_mode;\n                            break;\n                        case \"\":\n                            break;\n                        default:\n                            throw Error(\"no command found\");\n                    }\n                }\n            }\n            catch (e) {\n                err.appendChild(htmltag(\"br\"));\n                err.insertAdjacentText(\"beforeend\", e);\n                break;\n            }\n        }\n        let chara_array = [];\n        for (let i in chara_list) {\n            chara_array.push(i);\n        }\n        let outputTL = Array.from(new Array(Object.keys(chara_list).length), () => new Array(TL.current.length).fill(undefined));\n        TL.current.forEach((i, index) => {\n            let chara_id = i.id;\n            let OrderValue = i.timeline_OrderValue;\n            let charaPlace = chara_array.indexOf(chara_id);\n            outputTL[charaPlace][index] = OrderValue;\n        });\n        TL.switchData.forEach((x) => {\n            const [place, from_id, to_id] = x;\n            let from_charaPlace = chara_array.indexOf(from_id);\n            let to_charaPlace = chara_array.indexOf(to_id);\n            let arrow_str = \"\";\n            if (from_charaPlace < to_charaPlace) {\n                arrow_str = \"↓↓\";\n            }\n            else {\n                arrow_str = \"↑↑\";\n            }\n            outputTL[from_charaPlace][place] = arrow_str;\n        });\n        TL.cardData.forEach((x) => {\n            let charaPlace = chara_array.indexOf(x[1]);\n            outputTL[charaPlace][x[0]] = \"→\";\n        });\n        const now_place = TL.place_of_currentTimeline + 1;\n        const elm_firstchara = document.getElementById(\"firstchara\");\n        if (elm_firstchara)\n            elm_firstchara.innerText = TL.ID_of_firstChara();\n        const elm_now_place = document.getElementById(\"now_place\");\n        if (elm_now_place)\n            elm_now_place.innerText = String(now_place);\n        tableData = [outputTL, chara_array];\n        outputAsTable(outputTL, chara_array, TL.comment, now_place);\n        printConvertedTL();\n    }\n    function outputAsTable(json, charalist, comment, now_place) {\n        let output = htmltag(\"thead\");\n        let inner_tr = htmltag(\"tr\");\n        for (let i = 0; i <= json[0].length; i++) {\n            let tmp;\n            if (i === now_place) {\n                tmp = htmltag(\"th\", i.toString(), \"now_place\");\n            }\n            else if (i === 0) {\n                tmp = htmltag(\"th\", \"\", \"nowrap\");\n            }\n            else {\n                tmp = htmltag(\"th\", i.toString());\n            }\n            inner_tr.appendChild(tmp);\n        }\n        output.appendChild(inner_tr);\n        for (let x = 0; x < json.length; x++) {\n            let main_tl = htmltag(\"tr\");\n            main_tl.appendChild(htmltag(\"td\", charalist[x], \"nowrap\"));\n            for (let y = 0; y < json[0].length; y++) {\n                let tmp;\n                const find = comment.find((elm) => elm[0] === \"color\" && elm[1] === charalist[x] && elm[2] === y);\n                let inner_tmp = json[x][y];\n                let inner_tmp_string;\n                if (typeof inner_tmp === \"string\") {\n                    inner_tmp_string = inner_tmp;\n                }\n                else if (typeof inner_tmp === \"number\") {\n                    inner_tmp_string = String(inner_tmp);\n                }\n                else {\n                    inner_tmp_string = \"\";\n                }\n                if (find) {\n                    tmp = htmltag(\"td\", inner_tmp_string, \"color-\" + find[3]);\n                }\n                else {\n                    tmp = htmltag(\"td\", inner_tmp_string);\n                }\n                main_tl.appendChild(tmp);\n            }\n            output.appendChild(main_tl);\n        }\n        const target_elm = document.querySelector(\"table\");\n        if (target_elm) {\n            target_elm.innerHTML = \"\";\n            target_elm.appendChild(output);\n        }\n        else {\n            throw undefinedErr;\n        }\n    }\n    function outputAsCSV() {\n        const [json, charalist] = tableData;\n        let output = \"\";\n        for (let i = 0; i < json[0].length; i++) {\n            output += \",\" + (i + 1);\n        }\n        output += \"\\n\";\n        for (let x = 0; x < json.length; x++) {\n            output += charalist[x];\n            for (let y = 0; y < json[0].length; y++) {\n                output += \",\";\n                output += json[x][y] || \"\";\n            }\n            output += \"\\n\";\n        }\n        makeCSVfile_download(output);\n    }\n    function makeCSVfile_download(csv, fileName = \"timeline.csv\") {\n        let bom = new Uint8Array([0xef, 0xbb, 0xbf]);\n        let blob = new Blob([bom, csv], { type: \"text/csv\" });\n        let blobUrl = URL.createObjectURL(blob);\n        let link = document.createElement(\"a\");\n        link.href = blobUrl;\n        link.download = fileName;\n        link.style.display = \"none\";\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        URL.revokeObjectURL(blobUrl);\n    }\n    function copyDataAsURL() {\n        textCopy(url.href);\n        const copyed = document.getElementById(\"copyed\");\n        if (copyed) {\n            copyed.style.display = \"block\";\n            setTimeout(() => {\n                copyed.style.display = \"none\";\n            }, 1000);\n        }\n        else {\n            throw undefinedErr;\n        }\n    }\n    function printConvertedTL() {\n        const popup_elm = document.getElementById(\"popup\");\n        if (popup_elm) {\n            popup_elm.innerText = joinedTLdata();\n        }\n        else {\n            throw undefinedErr;\n        }\n    }\n    function copyConvertedTL() {\n        textCopy(joinedTLdata());\n        const copyed = document.getElementById(\"copyed_popup\");\n        if (copyed) {\n            copyed.style.display = \"block\";\n            setTimeout(() => {\n                copyed.style.display = \"none\";\n            }, 1000);\n        }\n        else {\n            throw undefinedErr;\n        }\n    }\n    function joinedTLdata() {\n        return (convertedTLdata.set.map((x) => x.join(\" \")).join(\"\\n\") +\n            \"\\n\\nstart\\n\" +\n            convertedTLdata.main.map((x) => \"  \" + x.join(\" \")).join(\"\\n\") +\n            \"\\nend\");\n    }\n})(window);\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.ts"]();
/******/ 	
/******/ })()
;