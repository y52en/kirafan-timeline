/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/brython/brython.js":
/*!*****************************************!*\
  !*** ./node_modules/brython/brython.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// brython.js brython.info\n// version [3, 10, 0, 'final', 0]\n// implementation [3, 10, 4, 'final', 0]\n// version compiled from commented, indented source files at\n// github.com/brython-dev/brython\nvar __BRYTHON__ = __BRYTHON__ || {}\nwindow.brython = __BRYTHON__;\ntry{\neval(\"async function* f(){}\")}catch(err){console.warn(\"Your browser is not fully supported. If you are using \"+\n\"Microsoft Edge, please upgrade to the latest version\")}\n;(function($B){\n\n\n\n\n$B.isWebWorker=('undefined' !==typeof WorkerGlobalScope)&&\n(\"function\"===typeof importScripts)&&\n(navigator instanceof WorkerNavigator)\n$B.isNode=(typeof process !=='undefined')&&(process.release.name==='node')\nvar _window\nif($B.isNode){_window={location:{href:'',origin:'',pathname:''},navigator:{userLanguage:''}}}else{\n_window=self}\nvar href=_window.location.href\n$B.protocol=href.split(':')[0]\n$B.BigInt=_window.BigInt\n$B.indexedDB=_window.indexedDB\nvar $path\nif($B.brython_path===undefined){\nvar this_url;\nif($B.isWebWorker){this_url=_window.location.href;\nif(this_url.startsWith(\"blob:\")){this_url=this_url.substr(5)}}else{var scripts=document.getElementsByTagName('script')\nthis_url=scripts[scripts.length-1].src}\nvar elts=this_url.split('/')\nelts.pop()\n$path=$B.brython_path=elts.join('/')+'/'}else{if(! $B.brython_path.endsWith(\"/\")){$B.brython_path+=\"/\"}\n$path=$B.brython_path}\nvar path=_window.location.origin+_window.location.pathname,path_elts=path.split(\"/\")\npath_elts.pop()\nvar $script_dir=$B.script_dir=path_elts.join(\"/\")\n$B.__ARGV=[]\n$B.webworkers={}\n$B.file_cache={}\n$B.$py_src={}\n$B.path=[$path+'Lib',$path+'libs',$script_dir,$path+'Lib/site-packages']\n$B.async_enabled=false\nif($B.async_enabled){$B.block={}}\n$B.imported={}\n$B.precompiled={}\n$B.frames_stack=[]\n$B.builtins=Object.create(null)\n$B.builtins_scope={id:'__builtins__',module:'__builtins__',binding:{}}\n$B.builtin_funcs={}\n$B.builtin_classes=[]\n$B.__getattr__=function(attr){return this[attr]}\n$B.__setattr__=function(attr,value){\nif(['debug','stdout','stderr'].indexOf(attr)>-1){$B[attr]=value}else{throw $B.builtins.AttributeError.$factory(\n'__BRYTHON__ object has no attribute '+attr)}}\n$B.language=_window.navigator.userLanguage ||_window.navigator.language\n$B.locale=\"C\" \n$B.PyCF_ONLY_AST=1024 \nif($B.isWebWorker){$B.charset=\"utf-8\"}else{\n$B.charset=document.characterSet ||document.inputEncoding ||\"utf-8\"}\n$B.max_int=Math.pow(2,53)-1\n$B.min_int=-$B.max_int\n$B.max_float=new Number(Number.MAX_VALUE)\n$B.min_float=new Number(Number.MIN_VALUE)\n$B.special_string_repr={8:\"\\\\x08\",9:\"\\\\t\",10:\"\\\\n\",11:\"\\\\x0b\",12:\"\\\\x0c\",13:\"\\\\r\",92:\"\\\\\\\\\",160:\"\\\\xa0\"}\n$B.$py_next_hash=Math.pow(2,53)-1\n$B.$py_UUID=0\n$B.lambda_magic=Math.random().toString(36).substr(2,8)\n$B.set_func_names=function(klass,module){if(klass.$infos){var name=klass.$infos.__name__\nklass.$infos.__module__=module\nklass.$infos.__qualname__=name}else{var name=klass.__name__\nklass.$infos={__name__:name,__module__:module,__qualname__:name}}\nklass.__module__=module\nfor(var attr in klass){if(typeof klass[attr]=='function'){klass[attr].$infos={__doc__:klass[attr].__doc__ ||\"\",__module__:module,__qualname__ :name+'.'+attr,__name__:attr}\nif(klass[attr].$type==\"classmethod\"){klass[attr].__class__=$B.method}}}}\nvar has_storage=typeof(Storage)!==\"undefined\"\nif(has_storage){$B.has_local_storage=false\ntry{if(localStorage){$B.local_storage=localStorage\n$B.has_local_storage=true}}catch(err){}\n$B.has_session_storage=false\ntry{if(sessionStorage){$B.session_storage=sessionStorage\n$B.has_session_storage=true}}catch(err){}}else{$B.has_local_storage=false\n$B.has_session_storage=false}\n$B.globals=function(){\nreturn $B.frames_stack[$B.frames_stack.length-1][3]}\n$B.scripts={}\n$B.$options={}\n$B.builtins_repr_check=function(builtin,args){\nvar $=$B.args('__repr__',1,{self:null},['self'],args,{},null,null),self=$.self,_b_=$B.builtins\nif(! _b_.isinstance(self,builtin)){throw _b_.TypeError.$factory(\"descriptor '__repr__' requires a \"+\n`'${builtin.$infos.__name__}' object but received a `+\n`'${$B.class_name(self)}'`)}}\n$B.update_VFS=function(scripts){$B.VFS=$B.VFS ||{}\nvar vfs_timestamp=scripts.$timestamp\nif(vfs_timestamp !==undefined){delete scripts.$timestamp}\nfor(var script in scripts){if($B.VFS.hasOwnProperty(script)){console.warn(\"Virtual File System: duplicate entry \"+script)}\n$B.VFS[script]=scripts[script]\n$B.VFS[script].timestamp=vfs_timestamp}}\n$B.add_files=function(files){\n$B.files=$B.files ||{}\nfor(var file in files){$B.files[file]=files[file]}}\n$B.has_file=function(file){\nreturn($B.files && $B.files.hasOwnProperty(file))}\n$B.python_to_js=function(src,script_id){$B.parse_options()\n$B.meta_path=$B.$meta_path.slice()\nif(!$B.use_VFS){$B.meta_path.shift()}\nif(script_id===undefined){script_id=\"__main__\"}\nvar root=__BRYTHON__.py2js(src,script_id,script_id),js=root.to_js()\njs=\"(function() {\\n var $locals_\"+script_id+\" = {}\\n\"+js+\"\\n}())\"\n    return js\n}\n    \n    window.pyexec = (code) => {\n        // const $B = brython;\n        $B.parse_options()\n        // observer.disconnect()\n    // console.log($locals_script)\n\n        const $locals_script = {json:JSON.stringify};\n\n        const root = $B.py2js(code, \"script\", \"script\")\n        const js = root.to_js()\n$B.set_import_paths()\n\n        // $B.debug = 0;\n        if ($B.debug > 1) { console.log(js) }\n        // console.log($locals_script)\n        eval(js)\n    };\n_window.py=function(src){\nvar root=$B.py2js(src[0],\"script\",\"script\"),js=root.to_js()\n$B.set_import_paths()\nnew Function(\"$locals_script\",js)({})}}\n\n\n\n\n)(__BRYTHON__)\n;\n__BRYTHON__.implementation=[3,10,4,'final',0]\n__BRYTHON__.__MAGIC__=\"3.10.4\"\n__BRYTHON__.version_info=[3,10,0,'final',0]\n__BRYTHON__.compiled_date=\"2021-12-31 10:38:32.934588\"\n__BRYTHON__.timestamp=1640943512934\n__BRYTHON__.builtin_module_names=[\"_aio\",\"_ajax\",\"_ast\",\"_base64\",\"_binascii\",\"_io_classes\",\"_json\",\"_jsre\",\"_locale\",\"_multiprocessing\",\"_posixsubprocess\",\"_profile\",\"_sre_utils\",\"_string\",\"_strptime\",\"_svg\",\"_webcomponent\",\"_webworker\",\"_zlib_utils\",\"array\",\"bry_re\",\"builtins\",\"dis\",\"encoding_cp932\",\"hashlib\",\"html_parser\",\"long_int\",\"marshal\",\"math\",\"modulefinder\",\"posix\",\"python_re\",\"random\",\"unicodedata\"]\n;\n;(function($B){function ord(char){if(char.length==1){return char.charCodeAt(0)}\nvar code=0x10000\ncode+=(char.charCodeAt(0)& 0x03FF)<< 10\ncode+=(char.charCodeAt(1)& 0x03FF)\nreturn code}\nfunction $last(array){return array[array.length-1]}\nvar ops='.,:;+-*/%~^|&=<>[](){}@',op2=['**','//','>>','<<'],augm_op='+-*/%~^|&=<>@',closing={'}':'{',']':'[',')':'('}\nfunction Token(type,string,start,end,line){var res={type,string,start,end,line}\nres[0]=type\nres[1]=string\nres[2]=start.slice(0,2)\nres[3]=end\nres[4]=line\nreturn res}\nfunction get_line_at(src,pos){\nvar end=src.substr(pos).search(/[\\r\\n]/)\nreturn end==-1 ? src.substr(pos):src.substr(pos,end)}\nfunction get_comment(src,pos,line_num,line_start,token_name,line){var start=pos,ix\nvar t=[]\nwhile(true){if(pos >=src.length ||(ix='\\r\\n'.indexOf(src[pos]))>-1){t.push(Token('COMMENT',src.substring(start-1,pos),[line_num,start-line_start],[line_num,pos-line_start+1],line))\nif(ix !==undefined){var nb=1\nif(src[pos]=='\\r' && src[pos+1]=='\\n'){nb++}else if(src[pos]===undefined){\nnb=0}\nt.push(Token(token_name,src.substr(pos,nb),[line_num,pos-line_start+1],[line_num,pos-line_start+nb+1],line))\nif(src[pos]===undefined){t.push(Token('NEWLINE','\\n',[line_num,pos-line_start+1],[line_num,pos-line_start+2],''))}\npos+=nb}\nreturn{t,pos}}\npos++}}\n$B.tokenizer=function*(src){var unicode_tables=$B.unicode_tables,whitespace=' \\t\\n',operators='*+-/%&^~=<>',allowed_after_identifier=',.()[]:;',string_prefix=/^(r|u|R|U|f|F|fr|Fr|fR|FR|rf|rF|Rf|RF)$/,bytes_prefix=/^(b|B|br|Br|bR|BR|rb|rB|Rb|RB)$/\nvar state=\"line_start\",char,cp,mo,pos=0,start,quote,triple_quote,escaped=false,string_start,string,prefix,name,operator,number,num_type,comment,indent,indents=[],braces=[],line_num=0,line_start=1,line\nyield Token('ENCODING','utf-8',[0,0],[0,0],'')\nwhile(pos < src.length){char=src[pos]\ncp=src.charCodeAt(pos)\nif(cp >=0xD800 && cp <=0xDBFF){\ncp=ord(src.substr(pos,2))\nchar=src.substr(pos,2)\npos++}\npos++\nswitch(state){case \"line_start\":\nline=get_line_at(src,pos-1)\nline_start=pos\nline_num++\nif(mo=/^\\f?(\\r\\n|\\r|\\n)/.exec(src.substr(pos-1))){\nyield Token('NL',mo[0],[line_num,0],[line_num,mo[0].length],line)\npos+=mo[0].length-1\ncontinue}else if(char=='#'){comment=get_comment(src,pos,line_num,line_start,'NL',line)\nfor(var item of comment.t){yield item}\npos=comment.pos\nstate='line_start'\ncontinue}\nindent=0\nif(char==' '){indent=1}else if(char=='\\t'){indent=8}\nif(indent){while(pos < src.length){if(src[pos]==' '){indent++}else if(src[pos]=='\\t'){indent+=8}else{break}\npos++}\nif(pos==src.length){\nline_num--\nbreak}\nif(src[pos]=='#'){\nvar comment=get_comment(src,pos+1,line_num,line_start,'NL',line)\nfor(var item of comment.t){yield item}\npos=comment.pos\ncontinue}else if(mo=/^\\f?(\\r\\n|\\r|\\n)/.exec(src.substr(pos))){\nyield Token('NL','',[line_num,pos-line_start+1],[line_num,pos-line_start+1+mo[0].length],line)\npos+=mo[0].length\ncontinue}\nif(indents.length==0 ||indent > $last(indents)){indents.push(indent)\nyield Token('INDENT','',[line_num,0],[line_num,indent],line)}else if(indent < $last(indents)){var ix=indents.indexOf(indent)\nif(ix==-1){var error=Error('unindent does not match '+\n'any outer indentation level')\nerror.type='IndentationError'\nerror.line_num=line_num\nthrow error }\nfor(var i=indents.length-1;i > ix;i--){indents.pop()\nyield Token('DEDENT','',[line_num,indent],[line_num,indent],line)}}\nstate=null}else{\nwhile(indents.length > 0){indents.pop()\nyield Token('DEDENT','',[line_num,indent],[line_num,indent],line)}\nstate=null\npos--}\nbreak\ncase null:\nswitch(char){case '\"':\ncase \"'\":\nquote=char\ntriple_quote=src[pos]==char && src[pos+1]==char\nstring_start=[line_num,pos-line_start,line_start]\nif(triple_quote){pos+=2}\nescaped=false\nstate='STRING'\nstring=\"\"\nprefix=\"\"\nbreak\ncase '#':\nvar token_name=braces.length > 0 ? 'NL' :'NEWLINE'\ncomment=get_comment(src,pos,line_num,line_start,token_name,line)\nfor(var item of comment.t){yield item}\npos=comment.pos\nif(braces.length==0){state='line_start'}else{state=null\nline_num++\nline_start=pos+1\nline=get_line_at(src,pos)}\nbreak\ncase '0':\nstate='NUMBER'\nnumber=char\nnum_type=''\nif(src[pos]&&\n'xbo'.indexOf(src[pos].toLowerCase())>-1){number+=src[pos]\nnum_type=src[pos].toLowerCase()\npos++}\nbreak\ncase '.':\nif(src[pos]&& unicode_tables.Nd[ord(src[pos])]){state='NUMBER'\nnum_type=''\nnumber=char}else{var op=char\nwhile(src[pos]==char){pos++\nop+=char}\nvar dot_pos=pos-line_start-op.length+1\nwhile(op.length >=3){\nyield Token('OP','...',[line_num,dot_pos],[line_num,dot_pos+3],line)\nop=op.substr(3)}\nfor(var i=0;i < op.length;i++){yield Token('OP','.',[line_num,dot_pos],[line_num,dot_pos+1],line)\ndot_pos++}}\nbreak\ncase '\\\\':\nif(mo=/^\\f?(\\r\\n|\\r|\\n)/.exec(src.substr(pos))){line_num++\npos+=mo[0].length\nline_start=pos+1\nline=get_line_at(src,pos)}else{yield Token('ERRORTOKEN',char,[line_num,pos-line_start],[line_num,pos-line_start+1],line)}\nbreak\ncase '\\n':\ncase '\\r':\nvar token_name=braces.length > 0 ? 'NL':'NEWLINE'\nmo=/^\\f?(\\r\\n|\\r|\\n)/.exec(src.substr(pos-1))\nyield Token(token_name,mo[0],[line_num,pos-line_start],[line_num,pos-line_start+mo[0].length],line)\npos+=mo[0].length-1\nif(token_name=='NEWLINE'){state='line_start'}else{line_num++\nline_start=pos+1\nline=get_line_at(src,pos)}\nbreak\ndefault:\nif(unicode_tables.XID_Start[ord(char)]){\nstate='NAME'\nname=char}else if(unicode_tables.Nd[ord(char)]){state='NUMBER'\nnum_type=''\nnumber=char}else if(ops.indexOf(char)>-1){var op=char\nif(op2.indexOf(char+src[pos])>-1){op=char+src[pos]\npos++}\nif(src[pos]=='=' &&(op.length==2 ||\naugm_op.indexOf(op)>-1)){op+=src[pos]\npos++}else if((char=='-' && src[pos]=='>')||\n(char==':' && src[pos]=='=')){op+=src[pos]\npos++}\nif('[({'.indexOf(char)>-1){braces.push(char)}else if('])}'.indexOf(char)>-1){if(braces && $last(braces)==closing[char]){braces.pop()}else{braces.push(char)}}\nyield Token('OP',op,[line_num,pos-line_start-op.length+1],[line_num,pos-line_start+1],line)}else if(char=='!' && src[pos]=='='){yield Token('OP','!=',[line_num,pos-line_start],[line_num,pos-line_start+2],line)\npos++}else if(char==' ' ||char=='\\t'){}else{yield Token('ERRORTOKEN',char,[line_num,pos-line_start],[line_num,pos-line_start+1],line)}}\nbreak\ncase 'NAME':\nif(unicode_tables.XID_Continue[ord(char)]){name+=char}else if(char=='\"' ||char==\"'\"){if(string_prefix.exec(name)||bytes_prefix.exec(name)){\nstate='STRING'\nquote=char\ntriple_quote=src[pos]==quote && src[pos+1]==quote\nprefix=name\nescaped=false\nstring_start=[line_num,pos-line_start-name.length,line_start]\nif(triple_quote){pos+=2}\nstring=''}else{yield Token('NAME',name,[line_num,pos-line_start-name.length],[line_num,pos-line_start],line)\nstate=null\npos--}}else{yield Token('NAME',name,[line_num,pos-line_start-name.length],[line_num,pos-line_start],line)\nstate=null\npos--}\nbreak\ncase 'STRING':\nswitch(char){case quote:\nif(! escaped){\nvar string_line=line\nif(line_num > string_start[0]){string_line=src.substring(\nstring_start[2]-1,pos+2)}\nif(! triple_quote){var full_string=prefix+quote+string+\nquote\nyield Token('STRING',full_string,string_start,[line_num,pos-line_start+1],string_line)\nstate=null}else if(char+src.substr(pos,2)==\nquote.repeat(3)){var full_string=prefix+quote.repeat(3)+\nstring+quote.repeat(3)\ntriple_quote_line=line\nyield Token('STRING',full_string,string_start,[line_num,pos-line_start+3],string_line)\npos+=2\nstate=null}else{string+=char}}else{string+=char}\nescaped=false\nbreak\ncase '\\r':\ncase '\\n':\nif(! escaped && ! triple_quote){\nvar quote_pos=string_start[1]+line_start-1,pos=quote_pos\nwhile(src[pos-1]==' '){pos--}\nwhile(pos < quote_pos){console.log('yield ERRORTOKEN, escaped',escaped)\nyield Token('ERRORTOKEN',' ',[line_num,pos-line_start+1],[line_num,pos-line_start+2],line)\npos++}\npos++\nyield Token('ERRORTOKEN',quote,[line_num,pos-line_start],[line_num,pos-line_start+1],line)\nstate=null\npos++\nbreak}\nstring+=char\nline_num++\nline_start=pos+1\nif(char=='\\r' && src[pos]=='\\n'){string+=src[pos]\nline_start++\npos++}\nline=get_line_at(src,pos)\nescaped=false\nbreak\ncase '\\\\':\nstring+=char\nescaped=! escaped\nbreak\ndefault:\nescaped=false\nstring+=char\nbreak}\nbreak\ncase 'NUMBER':\nif(num_type=='' && unicode_tables.Nd[ord(char)]){number+=char}else if(num_type=='b' && '01'.indexOf(char)>-1){number+=char}else if(num_type=='o' && '01234567'.indexOf(char)>-1){number+=char}else if(num_type=='x' &&\n'0123456789abcdef'.indexOf(char.toLowerCase())>-1){number+=char}else if(char=='_' && ! number.endsWith('.')){if(number.endsWith('_')){throw SyntaxError('consecutive _ in number')}\nnumber+=char}else if(char=='.' && number.indexOf(char)==-1){number+=char}else if(char.toLowerCase()=='e' &&\nnumber.toLowerCase().indexOf('e')==-1){number+=char}else if((char=='+' ||char=='-')&&\nnumber.toLowerCase().endsWith('e')){number+=char}else if(char.toLowerCase()=='j'){\nnumber+=char\nyield Token('NUMBER',number,[line_num,pos-line_start-number.length+1],[line_num,pos-line_start+1],line)\nstate=null}else{yield Token('NUMBER',number,[line_num,pos-line_start-number.length],[line_num,pos-line_start],line)\nstate=null\npos--}\nbreak}}\nif(braces.length > 0){throw SyntaxError('EOF in multi-line statement')}\nswitch(state){case 'line_start':\nline_num++\nbreak\ncase 'NAME':\nyield Token('NAME',name,[line_num,pos-line_start-name.length+1],[line_num,pos-line_start+1],line)\nbreak\ncase 'NUMBER':\nyield Token('NUMBER',number,[line_num,pos-line_start-number.length+1],[line_num,pos-line_start+1],line)\nbreak\ncase 'STRING':\nthrow SyntaxError(\n`unterminated string literal (detected at line ${line_num})`)}\nif(! src.endsWith('\\n')&& char !=' ' && state !=line_start){yield Token('NEWLINE','',[line_num,pos-line_start+1],[line_num,pos-line_start+2],'')\nline_num++}\nwhile(indents.length > 0){indents.pop()\nyield Token('DEDENT','',[line_num,0],[line_num,0],'')}\nyield Token('ENDMARKER','',[line_num,0],[line_num,0],'')}})(__BRYTHON__)\n;\n;(function($B){$B.ast_classes={Add:'',And:'',AnnAssign:'target,annotation,value,simple',Assert:'test,msg',Assign:'targets,value,type_comment',AsyncFor:'target,iter,body,orelse,type_comment',AsyncFunctionDef:'name,args,body,decorator_list,returns,type_comment',AsyncWith:'items,body,type_comment',Attribute:'value,attr,ctx',AugAssign:'target,op,value',Await:'value',BinOp:'left,op,right',BitAnd:'',BitOr:'',BitXor:'',BoolOp:'op,values',Break:'',Call:'func,args,keywords',ClassDef:'name,bases,keywords,body,decorator_list',Compare:'left,ops,comparators',Constant:'value,kind',Continue:'',Del:'',Delete:'targets',Dict:'keys,values',DictComp:'key,value,generators',Div:'',Eq:'',ExceptHandler:'type,name,body',Expr:'value',Expression:'body',FloorDiv:'',For:'target,iter,body,orelse,type_comment',FormattedValue:'value,conversion,format_spec',FunctionDef:'name,args,body,decorator_list,returns,type_comment',FunctionType:'argtypes,returns',GeneratorExp:'elt,generators',Global:'names',Gt:'',GtE:'',If:'test,body,orelse',IfExp:'test,body,orelse',Import:'names',ImportFrom:'module,names,level',In:'',Interactive:'body',Invert:'',Is:'',IsNot:'',JoinedStr:'values',LShift:'',Lambda:'args,body',List:'elts,ctx',ListComp:'elt,generators',Load:'',Lt:'',LtE:'',MatMult:'',Match:'subject,cases',MatchAs:'pattern,name',MatchClass:'cls,patterns,kwd_attrs,kwd_patterns',MatchMapping:'keys,patterns,rest',MatchOr:'patterns',MatchSequence:'patterns',MatchSingleton:'value',MatchStar:'name',MatchValue:'value',Mod:'',Module:'body,type_ignores',Mult:'',Name:'id,ctx',NamedExpr:'target,value',Nonlocal:'names',Not:'',NotEq:'',NotIn:'',Or:'',Pass:'',Pow:'',RShift:'',Raise:'exc,cause',Return:'value',Set:'elts',SetComp:'elt,generators',Slice:'lower,upper,step',Starred:'value,ctx',Store:'',Sub:'',Subscript:'value,slice,ctx',Try:'body,handlers,orelse,finalbody',Tuple:'elts,ctx',TypeIgnore:'lineno,tag',UAdd:'',USub:'',UnaryOp:'op,operand',While:'test,body,orelse',With:'items,body,type_comment',Yield:'value',YieldFrom:'value',alias:'name,asname',arg:'arg,annotation,type_comment',arguments:'posonlyargs,args,vararg,kwonlyargs,kw_defaults,kwarg,defaults',boolop:['And','Or'],cmpop:['Eq','NotEq','Lt','LtE','Gt','GtE','Is','IsNot','In','NotIn'],comprehension:'target,iter,ifs,is_async',excepthandler:['ExceptHandler'],expr:['BoolOp','NamedExpr','BinOp','UnaryOp','Lambda','IfExp','Dict','Set','ListComp','SetComp','DictComp','GeneratorExp','Await','Yield','YieldFrom','Compare','Call','FormattedValue','JoinedStr','Constant','Attribute','Subscript','Starred','Name','List','Tuple','Slice'],expr_context:['Load','Store','Del'],keyword:'arg,value',match_case:'pattern,guard,body',mod:['Module','Interactive','Expression','FunctionType'],operator:['Add','Sub','Mult','MatMult','Div','Mod','Pow','LShift','RShift','BitOr','BitXor','BitAnd','FloorDiv'],pattern:['MatchValue','MatchSingleton','MatchSequence','MatchMapping','MatchClass','MatchStar','MatchAs','MatchOr'],stmt:['FunctionDef','AsyncFunctionDef','ClassDef','Return','Delete','Assign','AugAssign','AnnAssign','For','AsyncFor','While','If','With','AsyncWith','Match','Raise','Try','Assert','Import','ImportFrom','Global','Nonlocal','Expr','Pass','Break','Continue'],type_ignore:['TypeIgnore'],unaryop:['Invert','Not','UAdd','USub'],withitem:'context_expr,optional_vars'}\nvar binary_ops={'+':'Add','-':'Sub','*':'Mult','/':'Div','//':'FloorDiv','%':'Mod','**':'Pow','<<':'LShift','>>':'RShift','|':'BitOr','^':'BitXor','&':'BitAnd','@':'MatMult'}\nvar boolean_ops={'and':'And','or':'Or'}\nvar comparison_ops={'==':'Eq','!=':'NotEq','<':'Lt','<=':'LtE','>':'Gt','>=':'GtE','is':'Is','is_not':'IsNot','in':'In','not_in':'NotIn'}\nvar unary_ops={unary_inv:'Invert',unary_pos:'UAdd',unary_neg:'USub'}\nvar op_types=[binary_ops,boolean_ops,comparison_ops,unary_ops]\nvar _b_=$B.builtins\nvar ast=$B.ast={}\nfor(var kl in $B.ast_classes){var args=$B.ast_classes[kl],js=''\nif(typeof args==\"string\"){js=`ast.${kl} = function(${args}){\\n`\nif(args.length > 0){for(var arg of args.split(',')){js+=` this.${arg} = ${arg}\\n`}}\njs+='}'}else{js=`ast.${kl} = [${args.map(x => 'ast.' + x).join(',')}]\\n`}\neval(js)\nast[kl].$name=kl\nif(typeof args==\"string\"){ast[kl]._fields=args.split(',')}}\n$B.create_python_ast_classes=function(){if($B.python_ast_classes){return}\n$B.python_ast_classes={}\nfor(var klass in $B.ast_classes){$B.python_ast_classes[klass]=(function(kl){var cls=$B.make_class(kl,function(js_node){return{\n__class__:$B.python_ast_classes[kl],js_node}}\n)\nif(typeof $B.ast_classes[kl]==\"string\"){cls._fields=$B.ast_classes[kl].split(',')}\ncls.__mro__=[$B.AST,_b_.object]\nreturn cls})(klass)}}\nvar op2ast_class=$B.op2ast_class={},ast_types=[ast.BinOp,ast.BoolOp,ast.Compare,ast.UnaryOp]\nfor(var i=0;i < 4;i++){for(var op in op_types[i]){op2ast_class[op]=[ast_types[i],ast[op_types[i][op]]]}}})(__BRYTHON__)\n;\n\n;(function($B){$B.produce_ast=false\nNumber.isInteger=Number.isInteger ||function(value){return typeof value==='number' &&\nisFinite(value)&&\nMath.floor(value)===value};\nNumber.isSafeInteger=Number.isSafeInteger ||function(value){return Number.isInteger(value)&& Math.abs(value)<=Number.MAX_SAFE_INTEGER;};\nvar js,$pos,res,$op\nvar _b_=$B.builtins\nvar _window\nif($B.isNode){_window={location:{href:'',origin:'',pathname:''}}}else{\n_window=self}\n$B.parser={}\nvar clone=$B.clone=function(obj){var res={}\nfor(var attr in obj){res[attr]=obj[attr]}\nreturn res}\n$B.last=function(table){if(table===undefined){console.log($B.frames_stack.slice())}\nreturn table[table.length-1]}\n$B.list2obj=function(list,value){var res={},i=list.length\nif(value===undefined){value=true}\nwhile(i--> 0){res[list[i]]=value}\nreturn res}\n$B.op2method={operations:{\"**\":\"pow\",\"//\":\"floordiv\",\"<<\":\"lshift\",\">>\":\"rshift\",\"+\":\"add\",\"-\":\"sub\",\"*\":\"mul\",\"/\":\"truediv\",\"%\":\"mod\",\"@\":\"matmul\" },augmented_assigns:{\"//=\":\"ifloordiv\",\">>=\":\"irshift\",\"<<=\":\"ilshift\",\"**=\":\"ipow\",\"+=\":\"iadd\",\"-=\":\"isub\",\"*=\":\"imul\",\"/=\":\"itruediv\",\"%=\":\"imod\",\"&=\":\"iand\",\"|=\":\"ior\",\"^=\":\"ixor\",\"@=\":\"imatmul\"},binary:{\"&\":\"and\",\"|\":\"or\",\"~\":\"invert\",\"^\":\"xor\"},comparisons:{\"<\":\"lt\",\">\":\"gt\",\"<=\":\"le\",\">=\":\"ge\",\"==\":\"eq\",\"!=\":\"ne\"},boolean:{\"or\":\"or\",\"and\":\"and\",\"in\":\"in\",\"not\":\"not\",\"is\":\"is\"},subset:function(){var res={},keys=[]\nif(arguments[0]==\"all\"){keys=Object.keys($B.op2method)\nkeys.splice(keys.indexOf(\"subset\"),1)}else{for(var arg of arguments){keys.push(arg)}}\nfor(var key of keys){var ops=$B.op2method[key]\nif(ops===undefined){throw Error(key)}\nfor(var attr in ops){res[attr]=ops[attr]}}\nreturn res}}\nvar $operators=$B.op2method.subset(\"all\")\nvar $augmented_assigns=$B.augmented_assigns=$B.op2method.augmented_assigns\nvar noassign=$B.list2obj(['True','False','None','__debug__'])\nvar $op_order=[['or'],['and'],['not'],['in','not_in'],['<','<=','>','>=','!=','==','is','is_not'],['|'],['^'],['&'],['>>','<<'],['+','-'],['*','@','/','//','%'],['unary_neg','unary_inv','unary_pos'],['**']\n]\nvar $op_weight={},$weight=1\nfor(var _tmp of $op_order){for(var item of _tmp){$op_weight[item]=$weight}\n$weight++}\nvar $loop_num=0\nif($B.ast_classes){var ast=$B.ast,op2ast_class=$B.op2ast_class\nfunction ast_body(block_ctx){\nvar body=[]\nfor(var child of block_ctx.node.children){var ctx=child.C.tree[0]\nif(['single_kw','except','decorator'].indexOf(ctx.type)>-1 ||\n(ctx.type=='condition' && ctx.token=='elif')){continue}\nvar child_ast=ast_or_obj(ctx)\nif(ast.expr.indexOf(child_ast.constructor)>-1){child_ast=new ast.Expr(child_ast)}\nbody.push(child_ast)}\nreturn body}\nfunction ast_dump(tree,indent){indent=indent ||0\nif(tree===_b_.None){\nreturn 'None'}else if(typeof tree=='string'){return `'${tree}'`}else if(typeof tree=='number'){return tree+''}else if(tree.imaginary){return tree.value+'j'}else if(Array.isArray(tree)){if(tree.length==0){return '[]'}\nres='[\\n'\nvar items=[]\nfor(var x of tree){try{items.push(ast_dump(x,indent+1))}catch(err){console.log('error',tree)\nconsole.log('for item',x)\nthrow err}}\nres+=items.join(',\\n')\nreturn res+']'}else if(tree.$name){return tree.$name+'()'}else if(tree instanceof ast.MatchSingleton){return `MatchSingleton(value=${tree.value})`}else if(tree instanceof ast.Constant){var value=tree.value\nif(value===undefined){console.log('bizarre',tree)}\nif(value.imaginary){return `Constant(value=${_b_.repr(value.value)}j)`}\nreturn `Constant(value=${_b_.repr(tree.value)})`}\nvar proto=Object.getPrototypeOf(tree).constructor\nvar res='  ' .repeat(indent)+proto.$name+'('\nif($B.ast_classes[proto.$name]===undefined){console.log('pas dans ast_classes',tree,proto,proto.$name)}\nvar attr_names=$B.ast_classes[proto.$name].split(','),attrs=[]\nif([ast.Name].indexOf(proto)>-1){for(var attr of attr_names){if(tree[attr]!==undefined){attrs.push(`${attr}=${ast_dump(tree[attr])}`)}}\nreturn res+attrs.join(', ')+')'}\nfor(var attr of attr_names){if(tree[attr]!==undefined){var value=tree[attr]\nattrs.push(attr+'='+\nast_dump(tree[attr],indent+1).trimStart())}}\nif(attrs.length > 0){res+='\\n'\nres+=attrs.map(x=> '  '.repeat(indent+1)+x).join(',\\n')}\nres+=')'\nreturn res}}\nfunction ast_or_obj(obj){\nif(obj.ast){return obj.ast()}else{console.log('no ast',obj.type ||typeof obj,obj)\nshow_line(obj)\nreturn obj}}\nvar create_temp_name=$B.parser.create_temp_name=function(prefix){var _prefix=prefix ||'$temp'\nreturn _prefix+$loop_num++}\nvar replace_node=$B.parser.replace_node=function(replace_what,replace_with){var parent=replace_what.parent\nvar pos=replace_what.parent.children.indexOf(replace_what)\nparent.children[pos]=replace_with\nreplace_with.parent=parent\nreplace_with.bindings=replace_what.bindings}\nvar chained_comp_num=0\nvar $_SyntaxError=$B.parser.$_SyntaxError=function(C,msg,indent){\nvar ctx_node=C\nwhile(ctx_node.type !=='node'){ctx_node=ctx_node.parent}\nvar tree_node=ctx_node.node,root=tree_node\nwhile(root.parent !==undefined){root=root.parent}\nvar module=tree_node.module ||$get_module(C).module,src=root.src,line_num=tree_node.line_num\nif(C.$pos !==undefined){$pos=C.$pos}\nif(src){line_num=src.substr(0,$pos).split(\"\\n\").length}\nif(root.line_info){line_num=root.line_info}\nif(indent===undefined){if(msg && Array.isArray(msg)){$B.$SyntaxError(module,msg[0],src,$pos,line_num,root)}\nif(msg===\"Triple string end not found\"){\n$B.$SyntaxError(module,'invalid syntax : triple string end not found',src,$pos,line_num,root)}\nvar message='invalid syntax'\nif(msg && !(msg.startsWith(\"token \"))){message+=' ('+msg+')'}\n$B.$SyntaxError(module,message,src,$pos,line_num,root)}else if(typeof indent=='number'){throw $B.$IndentationError(module,msg,src,$pos,line_num,root)}else{\nthrow $B.$IndentationError(module,msg,src,$pos,line_num,root,indent)}}\nfunction check_assignment(C,kwargs){\nvar once,action='assign to',augmented=false\nif(kwargs){once=kwargs.once\naction=kwargs.action ||action\naugmented=kwargs.augmented===undefined ? false :kwargs.augmented}\nvar ctx=C,forbidden=['assert','import','raise','return','decorator','comprehension','await']\nif(action !='delete'){\nforbidden.push('del')}\nfunction report(wrong_type){if(augmented){$_SyntaxError(C,[`'${wrong_type}' is an illegal expression `+\n'for augmented assignment'])}else{$_SyntaxError(C,[`cannot ${action} ${wrong_type}`])}}\nwhile(ctx){if(forbidden.indexOf(ctx.type)>-1){$_SyntaxError(C,'assign to '+ctx.type)}else if(ctx.type==\"expr\"){var assigned=ctx.tree[0]\nif(assigned.type==\"op\"){if($B.op2method.comparisons[ctx.tree[0].op]!==undefined){report('comparison')}else{report('operator')}}else if(assigned.type=='call'){report('function call')}else if(assigned.type=='id'){var name=assigned.value\nif(['None','True','False','__debug__'].indexOf(name)>-1){report(name)}\nif(noassign[name]===true){report(keyword)}}else if(['str','int','float','complex'].indexOf(assigned.type)>-1){report('literal')}else if(assigned.type==\"ellipsis\"){report('Ellipsis')}else if(assigned.type=='genexpr'){report('generator expression')}else if(assigned.type=='packed'){check_assignment(assigned.tree[0],{action,once:true})}else if(assigned.type=='named_expr'){report('named expression')}}else if(ctx.type=='list_or_tuple'){for(var item of ctx.tree){check_assignment(item,{action,once:true})}}else if(ctx.type=='ternary'){report('conditional expression')}else if(ctx.type=='op'){report('operator')}else if(ctx.type=='yield'){report('yield expression')}else if(ctx.comprehension){break}\nif(once){break}\nctx=ctx.parent}}\nfunction remove_abstract_expr(tree){if(tree.length > 0 && $B.last(tree).type=='abstract_expr'){tree.pop()}}\n$B.format_indent=function(js,indent){\nvar indentation='  ',lines=js.split('\\n'),level=indent,res='',last_is_closing_brace=false,last_is_backslash=false,last_is_var_and_comma=false\nfor(var i=0,len=lines.length;i < len;i++){var line=lines[i],add_closing_brace=false,add_spaces=true\nif(last_is_backslash){add_spaces=false}else if(last_is_var_and_comma){line='    '+line.trim()}else{line=line.trim()}\nif(add_spaces && last_is_closing_brace &&\n(line.startsWith('else')||\nline.startsWith('catch')||\nline.startsWith('finally'))){res=res.substr(0,res.length-1)\nadd_spaces=false}\nlast_is_closing_brace=line.endsWith('}')\nif(line.startsWith('}')){level--}else if(line.endsWith('}')){line=line.substr(0,line.length-1)\nadd_closing_brace=true}\nif(level < 0){if($B.debug > 2){console.log('wrong js indent')\nconsole.log(res)}\nlevel=0}\ntry{res+=(add_spaces ? indentation.repeat(level):'')+line+'\\n'}catch(err){console.log(res)\nthrow err}\nif(line.endsWith('{')){level++}else if(add_closing_brace){level--\ntry{res+=indentation.repeat(level)+'}\\n'}catch(err){console.log(res)\nthrow err}}\nlast_is_backslash=line.endsWith('\\\\')\nlast_is_var_and_comma=line.endsWith(',')&&\n(line.startsWith('var ')||last_is_var_and_comma)}\nreturn res}\nfunction show_line(ctx){\nvar lnum=$get_node(ctx).line_num,src=$get_module(ctx).src\nconsole.log('this',ctx,'\\nline',lnum,src.split('\\n')[lnum-1])}\nvar $Node=$B.parser.$Node=function(type){this.type=type\nthis.children=[]}\n$Node.prototype.add=function(child){\nthis.children[this.children.length]=child\nchild.parent=this\nchild.module=this.module}\n$Node.prototype.ast=function(){var root_ast=new ast.Module([],[])\nfor(var node of this.children){var t=node.C.tree[0]\nif(['single_kw','except','decorator'].indexOf(t.type)>-1 ||\n(t.type=='condition' && t.token=='elif')){continue}\nvar node_ast=ast_or_obj(node.C.tree[0])\nif(ast.expr.indexOf(node_ast.constructor)>-1){node_ast=new ast.Expr(node_ast)}\nroot_ast.body.push(node_ast)}\nreturn root_ast}\n$Node.prototype.get_indent=function(){var indent=0,node=this\nwhile(node.parent){indent++\nnode=node.parent}\nreturn indent}\n$Node.prototype.insert=function(pos,child){\nthis.children.splice(pos,0,child)\nchild.parent=this\nchild.module=this.module}\n$Node.prototype.toString=function(){return \"<object 'Node'>\"}\n$Node.prototype.show=function(indent){\nvar res=''\nif(this.type==='module'){for(var child of this.children){res+=child.show(indent)}\nreturn res}\nindent=indent ||0\nres+=' '.repeat(indent)\nres+=this.C\nif(this.children.length > 0){res+='{'}\nres+='\\n'\nfor(var child of this.children){res+=child.show(indent+4)}\nif(this.children.length > 0){res+=' '.repeat(indent)\nres+='}\\n'}\nreturn res}\n$Node.prototype.to_js=function(indent){\nif(this.js !==undefined){return this.js}\nthis.res=[]\nthis.unbound=[]\nif(this.type==='module'){for(var child of this.children){this.res.push(child.to_js())}\nthis.js=this.res.join('')\nreturn this.js}\nindent=indent ||0\nvar ctx_js=this.C.to_js()\nif(ctx_js){\nthis.res.push(' '.repeat(indent))\nthis.res.push(ctx_js)\nif(this.children.length > 0){this.res.push('{')}\nthis.res.push('\\n')\nfor(var child of this.children){this.res.push(child.to_js(indent+4))}\nif(this.children.length > 0){this.res.push(' '.repeat(indent))\nthis.res.push('}\\n')}}\nthis.js=this.res.join('')\nreturn this.js}\n$Node.prototype.transform=function(rank){\nif(this.awaits && this.awaits.length > 0){\nthis.parent.insert(rank,$NodeJS(\"var save_stack = $B.save_stack()\"))\nif(!(this.C && this.C.tree.length > 0 &&\nthis.C.tree[0].type=='return')){\nthis.parent.insert(rank+2,$NodeJS(\"$B.restore_stack(save_stack, $locals)\"))}\ndelete this.awaits \nreturn 1}\nif(this.has_yield && ! this.has_yield.transformed){\nvar parent=this.parent\nif(this.has_yield.from){var new_node=new $Node()\nvar new_ctx=new $NodeCtx(new_node)\nvar new_expr=new $ExprCtx(new_ctx,'js',false)\nvar _id=new $RawJSCtx(new_expr,`$locals.$expr${this.has_yield.from_num}`)\nvar assign=new $AssignCtx(new_expr)\nvar right=new $ExprCtx(assign)\nright.tree=this.has_yield.tree\nparent.insert(rank,new_node)\nvar pnode=$get_node(this.has_yield)\nvar n=this.has_yield.from_num\nvar replace_with=`$B.$import(\"sys\", [], {})\n            var _i${n} = _b_.iter($locals.$expr${n}),\n                _r${n}\n            var $failed${n} = false\n            try{\n                var _y${n} = _b_.next(_i${n})\n            }catch(_e){\n                $B.set_exc(_e)\n                $failed${n} = true\n                $B.pmframe = $B.last($B.frames_stack)\n                _e = $B.exception(_e)\n                if(_e.__class__ === _b_.StopIteration){\n                    var _r${n} = $B.$getattr(_e, \"value\")\n                }else{\n                    throw _e\n                }\n            }\n            if(! $failed${n}){\n                while(true){\n                    var $failed1${n} = false\n                    try{\n                        $B.leave_frame({$locals})\n                        var _s${n} = yield _y${n}\n                        $B.frames_stack.push($top_frame)\n                    }catch(_e){\n                        if(_e.__class__ === _b_.GeneratorExit){\n                            var $failed2${n} = false\n                            try{\n                                var _m${n} = $B.$getattr(_i${n}, \"close\")\n                            }catch(_e1){\n                                $failed2${n} = true\n                                if(_e1.__class__ !== _b_.AttributeError){\n                                    throw _e1\n                                }\n                            }\n                            if(! $failed2${n}){\n                                $B.$call(_m${n})()\n                            }\n                            throw _e\n                        }else if($B.is_exc(_e, [_b_.BaseException])){\n                            var _x = $B.$call($B.$getattr($locals.sys, \"exc_info\"))()\n                            var $failed3${n} = false\n                            try{\n                                var _m${n} = $B.$getattr(_i${n}, \"throw\")\n                            }catch(err){\n                                $failed3${n} = true\n                                if($B.is_exc(err, [_b_.AttributeError])){\n                                    throw err\n                                }\n                            }\n                            if(! $failed3${n}){\n                                try{\n                                    _y${n} = $B.$call(_m${n}).apply(null,\n                                        _b_.list.$factory(_x${n}))\n                                }catch(err){\n                                    if($B.$is_exc(err, [_b_.StopIteration])){\n                                        _r${n} = $B.$getattr(err, \"value\")\n                                        break\n                                    }\n                                    throw err\n                                }\n                            }\n                        }\n                    }\n                    if(! $failed1${n}){\n                        try{\n                            if(_s${n} === _b_.None){\n                                _y${n} = _b_.next(_i${n})\n                            }else{\n                                _y${n} = $B.$call($B.$getattr(_i${n}, \"send\"))(_s${n})\n                            }\n                        }catch(err){\n                            if($B.is_exc(err, [_b_.StopIteration])){\n                                _r${n} = $B.$getattr(err, \"value\")\n                                break\n                            }\n                            throw err\n                        }\n                    }\n                }\n            }`\nparent.insert(rank+1,$NodeJS(replace_with))\nreturn 3}\nparent.children.splice(rank,1)\nif(this.has_yield.tree.length===0){new_node=$NodeJS(\"var result = _b_.None\")}else{var new_node=new $Node()\nvar new_ctx=new $NodeCtx(new_node)\nvar new_expr=new $ExprCtx(new_ctx,'js',false)\nvar _id=new $RawJSCtx(new_expr,'var result')\nvar assign=new $AssignCtx(new_expr)\nassign.tree[1]=this.has_yield.tree[0]\n_id.parent=assign}\nnew_node.line_num=this.line_num\nparent.insert(rank,new_node)\nvar try_node=new $NodeJS(\"try\")\ntry_node.add($NodeJS(\"$B.leave_frame({$locals})\"))\ntry_node.add(this)\nparent.insert(rank+1,try_node)\nthis.has_yield.to_js=function(){return 'yield result'}\nthis.has_yield.transformed=true\nvar i=0\nwhile(i < try_node.children.length){var offset=try_node.children[i].transform(i)\nif(offset===undefined){offset=1}\ni+=offset}\nvar catch_node=$NodeJS(`catch(err${this.line_num})`)\ncatch_node.add($NodeJS(\"$B.frames_stack.push($top_frame)\"))\ncatch_node.add($NodeJS(`throw err${this.line_num}`))\nparent.insert(rank+2,catch_node)\nparent.insert(rank+3,$NodeJS(\"$B.frames_stack.push($top_frame)\"))\nreturn 2}\nif(this.type==='module'){\nthis.__doc__=$get_docstring(this)\nvar i=0\nwhile(i < this.children.length){var offset=this.children[i].transform(i)\nif(offset===undefined){offset=1}\ni+=offset}}else{var elt=this.C.tree[0],ctx_offset\nif(elt===undefined){console.log(this)}\nif(elt.transform !==undefined){ctx_offset=elt.transform(this,rank)}\nvar i=0\nwhile(i < this.children.length){var offset=this.children[i].transform(i)\nif(offset===undefined){offset=1}\ni+=offset}\nif(ctx_offset===undefined){ctx_offset=1}\nreturn ctx_offset}}\n$Node.prototype.clone=function(){var res=new $Node(this.type)\nfor(var attr in this){res[attr]=this[attr]}\nreturn res}\n$Node.prototype.clone_tree=function(){var res=new $Node(this.type)\nfor(var attr in this){res[attr]=this[attr]}\nres.children=[]\nfor(var child of this.children){res.add(child.clone_tree())}\nreturn res}\nvar $AbstractExprCtx=$B.parser.$AbstractExprCtx=function(C,with_commas){this.type='abstract_expr'\nthis.with_commas=with_commas\nthis.parent=C\nthis.tree=[]\nC.tree.push(this)}\n$AbstractExprCtx.prototype.toString=function(){return '(abstract_expr '+this.with_commas+') '+this.tree}\n$AbstractExprCtx.prototype.transition=function(token,value){var C=this\nvar packed=C.packed,is_await=C.is_await\nswitch(token){case 'await':\ncase 'id':\ncase 'imaginary':\ncase 'int':\ncase 'float':\ncase 'str':\ncase 'JoinedStr':\ncase 'bytes':\ncase 'ellipsis':\ncase '[':\ncase '(':\ncase '{':\ncase '.':\ncase 'not':\ncase 'lambda':\ncase 'yield':\nC.parent.tree.pop()\nvar commas=C.with_commas\nC=C.parent\nC.packed=packed\nC.is_await=is_await}\nswitch(token){case 'await':\nreturn new $AbstractExprCtx(new $AwaitCtx(\nnew $ExprCtx(C,'await',false)),true)\ncase 'id':\nreturn new $IdCtx(new $ExprCtx(C,'id',commas),value)\ncase 'str':\nreturn new $StringCtx(new $ExprCtx(C,'str',commas),value)\ncase 'JoinedStr':\nreturn new JoinedStrCtx(new $ExprCtx(C,'str',commas),value)\ncase 'bytes':\nreturn new $StringCtx(new $ExprCtx(C,'bytes',commas),value)\ncase 'int':\nreturn new $NumberCtx('int',new $ExprCtx(C,'int',commas),value)\ncase 'float':\nreturn new $NumberCtx('float',new $ExprCtx(C,'float',commas),value)\ncase 'imaginary':\nreturn new $NumberCtx('imaginary',new $ExprCtx(C,'imaginary',commas),value)\ncase '(':\nreturn new $ListOrTupleCtx(\nnew $ExprCtx(C,'tuple',commas),'tuple')\ncase '[':\nreturn new $ListOrTupleCtx(\nnew $ExprCtx(C,'list',commas),'list')\ncase '{':\nreturn new $DictOrSetCtx(\nnew $ExprCtx(C,'dict_or_set',commas))\ncase 'ellipsis':\nreturn new $EllipsisCtx(\nnew $ExprCtx(C,'ellipsis',commas))\ncase 'not':\nif(C.type=='op' && C.op=='is'){\nC.op='is_not'\nreturn C}\nreturn new $NotCtx(new $ExprCtx(C,'not',commas))\ncase 'lambda':\nreturn new $LambdaCtx(new $ExprCtx(C,'lambda',commas))\ncase 'op':\nvar tg=value\nswitch(tg){case '*':\nC.parent.tree.pop()\nvar commas=C.with_commas\nC=C.parent\nreturn new $PackedCtx(\nnew $ExprCtx(C,'expr',commas))\ncase '-':\ncase '~':\ncase '+':\nC.parent.tree.pop()\nreturn new $AbstractExprCtx(\nnew $UnaryCtx(\nnew $ExprCtx(C.parent,'unary',false),tg),false\n)\ncase 'not':\nC.parent.tree.pop()\nvar commas=C.with_commas\nC=C.parent\nreturn new $NotCtx(\nnew $ExprCtx(C,'not',commas))\ncase '...':\nreturn new $EllipsisCtx(new $ExprCtx(C,'ellipsis',commas))}\n$_SyntaxError(C,'token '+token+' after '+\nC)\ncase 'in':\nif(C.parent.type=='op' && C.parent.op=='not'){C.parent.op='not_in'\nreturn C}\n$_SyntaxError(C,'token '+token+' after '+\nC)\ncase '=':\nif(C.parent.type==\"yield\"){$_SyntaxError(C,[\"assignment to yield expression not possible\"])}\n$_SyntaxError(C,'token '+token+' after '+\nC)\ncase 'yield':\nreturn new $AbstractExprCtx(new $YieldCtx(C),true)\ncase ':':\nif(C.parent.type==\"sub\" ||\n(C.parent.type==\"list_or_tuple\" &&\nC.parent.parent.type==\"sub\")){return new $AbstractExprCtx(new $SliceCtx(C.parent),false)}\nreturn $transition(C.parent,token,value)\ncase ')':\ncase ',':\nswitch(C.parent.type){case 'list_or_tuple':\ncase 'slice':\ncase 'call_arg':\ncase 'op':\ncase 'yield':\nbreak\ncase 'match':\nif(token==','){\nC.parent.tree.pop()\nvar tuple=new $ListOrTupleCtx(C.parent,'tuple')\ntuple.implicit=true\ntuple.has_comma=true\ntuple.tree=[C]\nC.parent=tuple\nreturn tuple}\nbreak\ncase 'annotation':\n$_SyntaxError(C,\"empty annotation\")\ndefault:\n$_SyntaxError(C,token)}\nbreak\ncase '.':\n$_SyntaxError(C,'token '+token)}\nreturn $transition(C.parent,token,value)}\n$AbstractExprCtx.prototype.to_js=function(){this.js_processed=true\nif(this.type==='list'){return '['+$to_js(this.tree)+']'}\nreturn $to_js(this.tree)}\nvar $AliasCtx=$B.parser.$AliasCtx=function(C){\nthis.type='ctx_manager_alias'\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length-1].alias=this}\n$AliasCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case ',':\ncase ':':\nC.parent.set_alias(C.tree[0].tree[0])\nreturn $transition(C.parent,token,value)}\n$_SyntaxError(C,'token '+token+' after '+C)}\nvar $AnnotationCtx=$B.parser.$AnnotationCtx=function(C){\nthis.type='annotation'\nthis.parent=C\nthis.tree=[]\nC.annotation=this\nvar scope=$get_scope(C)\nif(scope.binding.__annotations__===undefined){\nscope.binding.__annotations__=true\nC.create_annotations=true}\nif(scope.ntype==\"def\" && C.tree && C.tree.length > 0 &&\nC.tree[0].type==\"id\"){var name=C.tree[0].value\nif(scope.globals && scope.globals.has(name)>-1){$_SyntaxError(C,[\"annotated name '\"+name+\n\"' can't be global\"])}\nscope.annotations=scope.annotations ||new Set()\nscope.annotations.add(name)\nif(! C.$in_parens){scope.binding=scope.binding ||{}\nscope.binding[name]=true}}}\n$AnnotationCtx.prototype.toString=function(){return '(annotation) '+this.tree}\n$AnnotationCtx.prototype.transition=function(token,value){var C=this\nif(token==\"eol\" && C.tree.length==1 &&\nC.tree[0].tree.length==0){$_SyntaxError(C,\"empty annotation\")}else if(token==':' && C.parent.type !=\"def\"){$_SyntaxError(C,\"more than one annotation\")}else if(token==\"augm_assign\"){$_SyntaxError(C,\"augmented assign as annotation\")}else if(token==\"op\"){$_SyntaxError(C,\"operator as annotation\")}\nreturn $transition(C.parent,token)}\n$AnnotationCtx.prototype.to_js=function(){if(this.tree[0].type=='expr' &&\nthis.tree[0].tree[0].type=='id'){return `\"${this.tree[0].tree[0].value}\"`}\nreturn $to_js(this.tree)}\nvar $AssertCtx=$B.parser.$AssertCtx=function(C){\nthis.type='assert'\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this}\n$AssertCtx.prototype.ast=function(){\nvar msg=this.tree[1]\nreturn new ast.Assert(ast_or_obj(this.tree[0]),msg===undefined ? msg :ast_or_obj(msg))}\n$AssertCtx.prototype.toString=function(){return '(assert) '+this.tree}\n$AssertCtx.prototype.transition=function(token,value){var C=this\nif(token==\",\"){if(this.tree.length > 1){$_SyntaxError(C,\"too many commas after assert\")}\nreturn new $AbstractExprCtx(this,false)}\nif(token=='eol'){return $transition(C.parent,token)}\n$_SyntaxError(C,token)}\n$AssertCtx.prototype.transform=function(node,rank){if(this.tree.length > 1){\nvar condition=this.tree[0]\nvar message=this.tree[1]}else{var condition=this.tree[0]\nvar message=null}\nif(this.tree[0].type==\"expr\" && this.tree[0].name==\"tuple\" &&\nthis.tree[0].tree[0].tree.length > 1){var warning=_b_.SyntaxWarning.$factory(\n\"assertion is always true, perhaps remove parentheses?\")\nvar module=$get_module(this)\n$B.$syntax_err_line(warning,module.filename,module.src,$pos,$get_node(this).line_num)\n$B.imported._warnings.warn(warning)}\nvar new_ctx=new $ConditionCtx(node.C,'if')\nvar not_ctx=new $NotCtx(new_ctx)\nnot_ctx.tree=[condition]\nnode.C=new_ctx\nvar js='throw _b_.AssertionError.$factory()'\nif(message !==null){js='throw _b_.AssertionError.$factory(_b_.str.$factory('+\nmessage.to_js()+'))'}\nnode.add($NodeJS(js))}\nfunction make_assign(left,right,module){var node=new $Node()\nnode.id=module\nvar C=new $NodeCtx(node)\nvar expr=new $ExprCtx(C,'left',true)\nexpr.tree=left.tree\nvar assign=new $AssignCtx(expr)\nassign.tree[1]=new $JSCode(right)\nreturn node}\nvar $AssignCtx=$B.parser.$AssignCtx=function(C,expression){\ncheck_assignment(C)\nif(C.type==\"expr\" && C.tree[0].type==\"lambda\"){$_SyntaxError(C,[\"cannot assign to lambda\"])}\nthis.type='assign'\nC.parent.tree.pop()\nC.parent.tree.push(this)\nthis.parent=C.parent\nthis.tree=[C]\nvar scope=$get_scope(this)\nif(C.type=='list_or_tuple' ||\n(C.type=='expr' && C.tree[0].type=='list_or_tuple')){if(C.type=='expr'){C=C.tree[0]}\nC.bind_ids(scope)}else if(C.type=='assign'){check_assignment(C.tree[1])\nfor(var elt of C.tree){var assigned=elt.tree[0]\nif(assigned.type=='id'){$bind(assigned.value,scope,this)}}}else{var assigned=C.tree[0]\nif(assigned && assigned.type=='id'){var name=assigned.value\nassigned.bound=true\nif(! scope.globals ||! scope.globals.has(assigned.value)){\nvar node=$get_node(this)\nnode.bound_before=Object.keys(scope.binding)\n$bind(assigned.value,scope,this)}else{\nvar module=$get_module(C)\nassigned.global_module=module.module\n$bind(assigned.value,module,this)}}else if(assigned.type==\"ellipsis\"){$_SyntaxError(C,['cannot assign to Ellipsis'])}else if(assigned.type==\"unary\"){$_SyntaxError(C,[\"cannot assign to operator\"])}else if(assigned.type==\"packed\"){if(assigned.tree[0].name=='id'){var id=assigned.tree[0].tree[0].value\nif(['None','True','False','__debug__'].indexOf(id)>-1){$_SyntaxError(C,['cannot assign to '+id])}}\nif(assigned.parent.in_tuple===undefined){$_SyntaxError(C,[\"starred assignment target must be in a list or tuple\"])}}}}\n$AssignCtx.prototype.ast=function(){var value=ast_or_obj(this.tree[1]),targets=[],target=this.tree[0]\nif(target.type=='expr' && target.tree[0].type=='list_or_tuple'){target=target.tree[0]}\nif(target.type=='list_or_tuple'){target=ast_or_obj(target)\nfor(var elt of target.elts){elt.ctx=new ast.Store()\nif(elt instanceof ast.Starred){elt.value.ctx=new ast.Store()}}\ntarget.ctx=new ast.Store()\ntargets=[target]}else{while(target.type=='assign'){targets.splice(0,0,ast_or_obj(target.tree[1]))\ntarget=target.tree[0]}\ntargets.splice(0,0,ast_or_obj(target))\nfor(var tg of targets){tg.ctx=new ast.Store()\nif(tg instanceof ast.Tuple){for(var elt of tg.elts){elt.ctx=new ast.Store()}}}}\nvalue.ctx=new ast.Load()\nif(target.annotation){var res=new ast.AnnAssign(\nast_or_obj(target.tree[0]),ast_or_obj(target.annotation.tree[0]),value,1)\nres.target.ctx=new ast.Store()\nreturn res}\nreturn new ast.Assign(targets,value)}\n$AssignCtx.prototype.guess_type=function(){return}\n$AssignCtx.prototype.toString=function(){return '(assign) '+this.tree[0]+'='+this.tree[1]}\n$AssignCtx.prototype.transition=function(token,value){var C=this\nif(token=='eol'){if(C.tree[1].type=='abstract_expr'){$_SyntaxError(C,'token '+token+' after '+\nC)}\nC.guess_type()\nreturn $transition(C.parent,'eol')}\nconsole.log('token',token,'after C',C)\n$_SyntaxError(C,'token '+token+' after '+C)}\n$AssignCtx.prototype.transform=function(node,rank){\nvar scope=$get_scope(this)\nvar left=this.tree[0],right=this.tree[1],assigned=[]\nwhile(left.type=='assign'){assigned.push(left.tree[1])\nleft=left.tree[0]}\nif(assigned.length > 0){assigned.push(left)\nvar ctx=node.C\nctx.tree=[]\nvar nleft=new $RawJSCtx(ctx,'var $temp'+$loop_num)\nnleft.tree=ctx.tree\nvar nassign=new $AssignCtx(nleft)\nnassign.tree[1]=right\nfor(var elt of assigned){if(elt.type==\"expr\" && elt.tree[0].type==\"list_or_tuple\" &&\nelt.tree[0].real==\"tuple\" &&\nelt.tree[0].tree.length==1){\nelt=elt.tree[0].tree[0]}\nvar new_node=new $Node(),node_ctx=new $NodeCtx(new_node)\nnew_node.locals=node.locals\nnew_node.line_num=node.line_num\nnode.parent.insert(rank+1,new_node)\nelt.parent=node_ctx\nvar assign=new $AssignCtx(elt)\nnew $RawJSCtx(assign,'$temp'+$loop_num)}\n$loop_num++\nthis.tree[0]=left\nreturn}\nvar left_items=null\nswitch(left.type){case 'expr':\nif(left.tree.length > 1){left_items=left.tree}else if(left.tree[0].type=='list_or_tuple' ||\nleft.tree[0].type=='target_list'){left_items=left.tree[0].tree}else if(left.tree[0].type=='id'){\nvar name=left.tree[0].value\nif(scope.globals && scope.globals.has(name)){}else{left.tree[0].bound=true}}\nbreak\ncase 'target_list':\ncase 'list_or_tuple':\nleft_items=left.tree}\nvar right=this.tree[1]\nif(left_items===null){if(left.tree[0].bound){if(right.type==\"expr\" && right.name==\"int\"){node.bindings=node.bindings ||{}\nnode.bindings[left.tree[0].value]=\"int\"}}\nreturn}\nvar right_items=null\nif(right.type=='list' ||right.type=='tuple'||\n(right.type=='expr' && right.tree.length > 1)){right_items=right.tree}\nif(right_items !==null){\nif(right_items.length > left_items.length){throw Error('ValueError : too many values to unpack (expected '+\nleft_items.length+')')}else if(right_items.length < left_items.length){throw Error('ValueError : need more than '+\nright_items.length+' to unpack')}\nvar new_nodes=[],pos=0\nvar new_node=new $Node()\nnew_node.line_num=node.line_num\nnew $NodeJSCtx(new_node,'void(0)')\nnew_nodes[pos++]=new_node\nvar $var='$temp'+$loop_num\nvar new_node=new $Node()\nnew_node.line_num=node.line_num\nnew $NodeJSCtx(new_node,'var '+$var+' = [], $pos = 0')\nnew_nodes[pos++]=new_node\nfor(var right_item of right_items){var js=$var+'[$pos++] = '+right_item.to_js()\nvar new_node=new $Node()\nnew_node.line_num=node.line_num\nnew $NodeJSCtx(new_node,js)\nnew_nodes[pos++]=new_node}\nvar this_node=$get_node(this)\nfor(var left_item of left_items){var new_node=new $Node()\nnew_node.id=this_node.module\nnew_node.locals=this_node.locals\nnew_node.line_num=node.line_num\nvar C=new $NodeCtx(new_node)\nleft_item.parent=C\nvar assign=new $AssignCtx(left_item,false)\nassign.tree[1]=new $JSCode($var+'['+i+']')\nnew_nodes[pos++]=new_node}\nnode.parent.children.splice(rank,1)\nfor(var i=new_nodes.length-1;i >=0;i--){node.parent.insert(rank,new_nodes[i])}\n$loop_num++}else{\nnode.parent.children.splice(rank,1)\nvar rname=create_temp_name('$right')\nvar rlname=create_temp_name('$rlist');\nvar new_node=$NodeJS('var '+rname+' = '+\n'$B.$getattr($B.$iter('+right.to_js()+\n'), \"__next__\");')\nnew_node.line_num=node.line_num \nnode.parent.insert(rank++,new_node)\nnode.parent.insert(rank++,$NodeJS('var '+rlname+'=[], $pos=0;'+\n'while(1){\\n'+\n'try{\\n'+\nrlname+'[$pos++] = '+rname+'()'+\n'}catch(err){\\n'+\n'break'+\n'}'+\n'}')\n)\nvar packed=null\nvar min_length=left_items.length\nfor(var i=0;i < left_items.length;i++){var expr=left_items[i]\nif(expr.type=='packed' ||\n(expr.type=='expr' && expr.tree[0].type=='packed')){packed=i\nmin_length--\nbreak}}\nnode.parent.insert(rank++,$NodeJS('if('+rlname+'.length<'+min_length+'){\\n'+\n'throw _b_.ValueError.$factory('+\n'\"need more than \" +'+rlname+\n'.length + \" value\" + ('+rlname+\n'.length > 1 ?'+' \"s\" : \"\") + \" to unpack\")}'\n)\n)\nif(packed==null){node.parent.insert(rank++,$NodeJS('if('+rlname+'.length>'+min_length+'){\\n'+\n'throw _b_.ValueError.$factory('+\n'\"too many values to unpack '+\n'(expected '+left_items.length+')\"'+\n')'+\n'}')\n)}\nleft_items.forEach(function(left_item,i){var new_node=new $Node()\nnew_node.id=scope.id\nnew_node.line_num=node.line_num\nnode.parent.insert(rank++,new_node)\nvar C=new $NodeCtx(new_node)\nleft_item.parent=C\nleft_item.in_tuple=true\nvar assign=new $AssignCtx(left_item,false)\nvar js=rlname\nif(packed==null ||i < packed){js+='['+i+']'}else if(i==packed){js+='.slice('+i+','+rlname+'.length-'+\n(left_items.length-i-1)+')'}else{js+='['+rlname+'.length-'+(left_items.length-i)+']'}\nassign.tree[1]=new $JSCode(js)})\n$loop_num++}}\n$AssignCtx.prototype.to_js=function(){this.js_processed=true\nif(this.parent.type=='call'){\nreturn '{$nat:\"kw\",name:'+this.tree[0].to_js()+\n',value:'+this.tree[1].to_js()+'}'}\nvar left=this.tree[0]\nwhile(left.type=='expr'){left=left.tree[0]}\nvar right=this.tree[1]\nif(left.type=='attribute' ||left.type=='sub'){\nvar right_js=right.to_js()\nvar res='',rvar='',$var='$temp'+$loop_num\nif(right.type=='expr' && right.tree[0]!==undefined &&\nright.tree[0].type=='call' &&\n('eval'==right.tree[0].func.value ||\n'exec'==right.tree[0].func.value)){res+='var '+$var+' = '+right_js+';\\n'\nrvar=$var}else if(right.type=='expr' && right.tree[0]!==undefined &&\nright.tree[0].type=='sub'){res+='var '+$var+' = '+right_js+';\\n'\nrvar=$var}else{rvar=right_js}\nif(left.type=='attribute'){\n$loop_num++\nleft.func='setattr'\nvar left_to_js=left.to_js()\nleft.func='getattr'\nif(left.assign_self){return res+left_to_js[0]+rvar+left_to_js[1]+rvar+')'}\nres+=left_to_js\nres=res.substr(0,res.length-1)\nreturn res+','+rvar+');_b_.None;'}\nif(left.type=='sub'){\nvar seq=left.value.to_js(),temp='$temp'+$loop_num,type\nif(left.value.type=='id'){type=$get_node(this).locals[left.value.value]}\n$loop_num++\nvar res='var '+temp+' = '+seq+'\\n'\nif(type !=='list'){res+='if(Array.isArray('+temp+') && !'+\ntemp+'.__class__){\\n'}\nif(left.tree.length==1){res+='$B.set_list_key('+temp+','+\n(left.tree[0].to_js()+'' ||'null')+','+\nright.to_js()+')'}else if(left.tree.length==2){res+='$B.set_list_slice('+temp+','+\n(left.tree[0].to_js()+'' ||'null')+','+\n(left.tree[1].to_js()+'' ||'null')+','+\nright.to_js()+')'}else if(left.tree.length==3){res+='$B.set_list_slice_step('+temp+','+\n(left.tree[0].to_js()+'' ||'null')+','+\n(left.tree[1].to_js()+'' ||'null')+','+\n(left.tree[2].to_js()+'' ||'null')+','+\nright.to_js()+')'}\nif(type=='list'){return res}\nres+='\\n}else{\\n'\nif(left.tree.length==1){res+='$B.$setitem('+left.value.to_js()+\n','+left.tree[0].to_js()+','+right_js+')};_b_.None;'}else{left.func='setitem' \nres+=left.to_js()\nres=res.substr(0,res.length-1)\nleft.func='getitem' \nres+=','+right_js+')};_b_.None;'}\nreturn res}}\nreturn left.to_js()+' = '+right.to_js()}\nvar $AsyncCtx=$B.parser.$AsyncCtx=function(C){\nthis.type='async'\nthis.parent=C\nC.async=true}\n$AsyncCtx.prototype.toString=function(){return '(async)'}\n$AsyncCtx.prototype.transition=function(token,value){var C=this\nif(token==\"def\"){return $transition(C.parent,token,value)}else if(token==\"for\" ||token==\"with\"){var ntype=$get_scope(C).ntype\nif(ntype !==\"def\" && ntype !=\"generator\"){$_SyntaxError(C,[\"'async \"+token+\n\"' outside async function\"])}\nvar ctx=$transition(C.parent,token,value)\nctx.parent.async=true \nreturn ctx}\n$_SyntaxError(C,'token '+token+' after '+C)}\nvar $AttrCtx=$B.parser.$AttrCtx=function(C){\nthis.type='attribute'\nthis.value=C.tree[0]\nthis.parent=C\nC.tree.pop()\nC.tree[C.tree.length]=this\nthis.tree=[]\nthis.func='getattr' }\n$AttrCtx.prototype.ast=function(){\nvar value=ast_or_obj(this.value),attr=this.unmangled_name,ctx=new ast.Load()\nif(this.func=='setattr'){ctx=new ast.Store()}else if(this.func=='delattr'){ctx=new ast.Delete()}\nreturn new ast.Attribute(value,attr,ctx)}\n$AttrCtx.prototype.toString=function(){return '(attr) '+this.value+'.'+this.name}\n$AttrCtx.prototype.transition=function(token,value){var C=this\nif(token==='id'){var name=value\nif(name=='__debug__'){$_SyntaxError(C,['cannot assign to __debug__'])}else if(noassign[name]===true){$_SyntaxError(C,`'${name}' cannot be an attribute`)}\nC.unmangled_name=name\nname=$mangle(name,C)\nC.name=name\nreturn C.parent}\n$_SyntaxError(C,token)}\n$AttrCtx.prototype.to_js=function(){this.js_processed=true\nvar js=this.value.to_js()\nif(this.func==\"setattr\" && this.value.type==\"id\"){var scope=$get_scope(this),parent=scope.parent\nif(scope.ntype==\"def\"){if(parent.ntype==\"class\"){var params=scope.C.tree[0].positional_list\nif(this.value.value==params[0]&& parent.C &&\nparent.C.tree[0].args===undefined){\nthis.assign_self=true\nreturn[js+\".__class__ && \"+js+\".__dict__ && !\"+\njs+\".__class__.$has_setattr && ! \"+js+\n\".$is_class ? _b_.dict.$setitem(\"+js+\n\".__dict__, '\"+this.name+\n\"', \",\") : $B.$setattr(\"+js+\n', \"'+this.name+'\", ']}}}}\nif(this.func=='setattr'){\nreturn '$B.$setattr('+js+',\"'+this.name+'\")'}else{return '$B.$getattr('+js+',\"'+this.name+'\")'}}\nvar $AugmentedAssignCtx=$B.parser.$AugmentedAssignCtx=function(C,op){\ncheck_assignment(C,{augmented:true})\nthis.type='augm_assign'\nthis.C=C\nthis.parent=C.parent\nC.parent.tree.pop()\nC.parent.tree[C.parent.tree.length]=this\nthis.op=op\nthis.tree=[C]\nvar scope=this.scope=$get_scope(this)\nif(C.type=='expr'){var assigned=C.tree[0]\nif(assigned.type=='id'){var name=assigned.value\nif((scope.ntype=='def' ||scope.ntype=='generator')&&\n(! scope.binding.hasOwnProperty(name))){if(scope.globals===undefined ||\n! scope.globals.has(name)){\nassigned.unbound=true}}}}\n$get_node(this).bound_before=Object.keys(scope.binding)\nthis.module=scope.module}\n$AugmentedAssignCtx.prototype.ast=function(){\nvar target=ast_or_obj(this.tree[0]),value=ast_or_obj(this.tree[1])\ntarget.ctx=new ast.Store()\nvalue.ctx=new ast.Load()\nvar op=this.op.substr(0,this.op.length-1),ast_type_class=op2ast_class[op],ast_class=ast_type_class[1]\nreturn new ast.AugAssign(target,new ast_class(),value)}\n$AugmentedAssignCtx.prototype.toString=function(){return '(augm assign) '+this.tree}\n$AugmentedAssignCtx.prototype.transition=function(token,value){var C=this\nif(token=='eol'){if(C.tree[1].type=='abstract_expr'){$_SyntaxError(C,'token '+token+' after '+\nC)}\nreturn $transition(C.parent,'eol')}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$AugmentedAssignCtx.prototype.to_js=function(){var target=this.tree[0].tree[0]\nif(target.type=='id'){var left_bound_to_int=\nthis.tree[0].tree[0].bindingType(this.scope)==\"int\"\nvar target_scope=find_scope(target.value,$get_scope(this)),scope_ref\nif(target_scope===undefined){\nscope_ref='$locals'}else{scope_ref='$locals_'+target_scope.id.replace(/\\./g,'_')}\ntarget.augm_assign=true\nvar right=this.tree[1].tree[0]\nif(right.type=='int'){var right_value=parseInt(right.value[1],right.value[0])\nif(right_value < $B.max_int && right_value > $B.min_int){var left_bound_to_int=\nthis.tree[0].tree[0].bindingType(this.scope)==\"int\"\nif(left_bound_to_int && this.op !=='//='){\nvar op1=this.op.substr(0,this.op.length-1),tg_js=target.to_js()\nreturn `${scope_ref}['${target.value}'] = `+\n`(typeof ${tg_js} == \"number\" && $B.is_safe_int(`+\n`$locals.$result = ${tg_js} ${op1} ${right.to_js()}`+\n`)) ? $locals.$result : $B.augm_assign(${tg_js}, `+\n`'${this.op}', ${right.to_js()})`}}}\nvar right=this.tree[1].to_js()\nreturn `${scope_ref}['${target.value}'] = `+\n`$B.augm_assign(${target.to_js()}, '${this.op}', `+\nright+')'}else if(target.type=='sub'){return `$B.$setitem(($locals.$tg = ${target.value.to_js()}), `+\n`($locals.$key = ${target.tree[0].to_js()}), $B.augm_assign($B.$getitem(`+\n`$locals.$tg, $locals.$key), '${this.op}', ${this.tree[1].to_js()}))`}else if(target.type=='attribute'){return `$B.$setattr(($locals.$tg = ${target.value.to_js()}), `+\n`'${target.name}', $B.augm_assign($B.$getattr(`+\n`$locals.$tg, '${target.name}'), '${this.op}', ${this.tree[1].to_js()}))`}\nreturn ''}\nvar $AwaitCtx=$B.parser.$AwaitCtx=function(C){\nthis.type='await'\nthis.parent=C\nthis.tree=[]\nC.tree.push(this)\nvar p=C\nwhile(p){if(p.type==\"list_or_tuple\"){p.is_await=true}\np=p.parent}\nvar node=$get_node(this)\nnode.awaits=node.awaits ||[]\nnode.awaits.push(this)}\n$AwaitCtx.prototype.ast=function(){\nreturn new ast.Await(ast_or_obj(this.tree[0]))}\n$AwaitCtx.prototype.transition=function(token,value){var C=this\nC.parent.is_await=true\nreturn $transition(C.parent,token,value)}\n$AwaitCtx.prototype.to_js=function(){return `await $B.promise(${$to_js(this.tree)})`}\nvar $BodyCtx=$B.parser.$BodyCtx=function(C){\nvar ctx_node=C.parent\nwhile(ctx_node.type !=='node'){ctx_node=ctx_node.parent}\nvar tree_node=ctx_node.node\nvar body_node=new $Node()\nbody_node.is_body_node=true\nbody_node.line_num=tree_node.line_num\ntree_node.insert(0,body_node)\nreturn new $NodeCtx(body_node)}\nvar set_loop_context=$B.parser.set_loop_context=function(C,kw){\nvar ctx_node=C\nwhile(ctx_node.type !=='node'){ctx_node=ctx_node.parent}\nvar tree_node=ctx_node.node\nvar loop_node=tree_node.parent\nvar break_flag=false\nwhile(1){if(loop_node.type=='module'){\n$_SyntaxError(C,kw+' outside of a loop')}else{var ctx=loop_node.C.tree[0]\nif(ctx.type=='condition' && ctx.token=='while'){this.loop_ctx=ctx\nctx['has_'+kw]=true\nbreak}\nswitch(ctx.type){case 'for':\nthis.loop_ctx=ctx\nctx['has_'+kw]=true\nbreak_flag=true\nbreak\ncase 'def':\ncase 'generator':\ncase 'class':\n$_SyntaxError(C,kw+' outside of a loop')\ndefault:\nloop_node=loop_node.parent}\nif(break_flag){break}}}}\nvar $BreakCtx=$B.parser.$BreakCtx=function(C){\nthis.type='break'\nthis.parent=C\nC.tree[C.tree.length]=this\nset_loop_context.apply(this,[C,'break'])}\n$BreakCtx.prototype.ast=function(){return new ast.Break()}\n$BreakCtx.prototype.toString=function(){return 'break '}\n$BreakCtx.prototype.transition=function(token,value){var C=this\nif(token=='eol'){return $transition(C.parent,'eol')}\n$_SyntaxError(C,token)}\n$BreakCtx.prototype.to_js=function(){this.js_processed=true\nvar res=';$no_break'+this.loop_ctx.loop_num+' = false'\nif(this.loop_ctx.type !='asyncfor'){res+=';break'}else{res+=';throw _b_.StopIteration.$factory('+\nthis.loop_ctx.loop_num+')'}\nreturn res}\nvar $CallArgCtx=$B.parser.$CallArgCtx=function(C){\nthis.type='call_arg'\nthis.parent=C\nthis.start=$pos\nthis.tree=[]\nC.tree.push(this)\nthis.expect='id'}\n$CallArgCtx.prototype.toString=function(){return 'call_arg '+this.tree}\n$CallArgCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'await':\ncase 'id':\ncase 'imaginary':\ncase 'int':\ncase 'float':\ncase 'str':\ncase 'JoinedStr':\ncase 'bytes':\ncase '[':\ncase '(':\ncase '{':\ncase '.':\ncase 'ellipsis':\ncase 'not':\ncase 'lambda':\nif(C.expect=='id'){C.expect=','\nvar expr=new $AbstractExprCtx(C,false)\nreturn $transition(expr,token,value)}\nbreak\ncase '=':\nif(C.expect==','){return new $ExprCtx(new $KwArgCtx(C),'kw_value',false)}\nbreak\ncase 'for':\nif(this.parent.tree.length > 1){$_SyntaxError(C,\"non-parenthesized generator expression\")}\nreturn new $TargetListCtx(new $ForExpr(new GeneratorExpCtx(C)))\ncase 'op':\nif(C.expect=='id'){var op=value\nC.expect=','\nswitch(op){case '+':\ncase '-':\ncase '~':\nreturn $transition(new $AbstractExprCtx(C,false),token,op)\ncase '*':\nC.parent.tree.pop()\nreturn new $StarArgCtx(C.parent)\ncase '**':\nC.parent.tree.pop()\nreturn new $DoubleStarArgCtx(C.parent)}}\n$_SyntaxError(C,'token '+token+' after '+C)\ncase ')':\nif(C.parent.kwargs &&\n$B.last(C.parent.tree).tree[0]&& \n['kwarg','star_arg','double_star_arg'].\nindexOf($B.last(C.parent.tree).tree[0].type)==-1){$_SyntaxError(C,['non-keyword argument after keyword argument'])}\nreturn $transition(C.parent,token)\ncase ':':\nif(C.expect==',' &&\nC.parent.parent.type=='lambda'){return $transition(C.parent.parent,token)}\nbreak\ncase ',':\nif(C.expect==','){if(C.parent.kwargs &&\n['kwarg','star_arg','double_star_arg'].\nindexOf($B.last(C.parent.tree).tree[0].type)==-1){$_SyntaxError(C,['non-keyword argument after keyword argument'])}\nreturn $transition(C.parent,token,value)}}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$CallArgCtx.prototype.to_js=function(){this.js_processed=true\nreturn $to_js(this.tree)}\nvar $CallCtx=$B.parser.$CallCtx=function(C){\nthis.type='call'\nthis.func=C.tree[0]\nif(this.func !==undefined){\nthis.func.parent=this}\nthis.parent=C\nif(C.type !='class'){C.tree.pop()\nC.tree[C.tree.length]=this}else{\nC.args=this}\nthis.expect='id'\nthis.tree=[]\nthis.start=$pos\nif(this.func && this.func.type==\"attribute\" && this.func.name==\"wait\"\n&& this.func.value.type==\"id\" && this.func.value.value==\"time\"){console.log('call',this.func)\n$get_node(this).blocking={'type':'wait','call':this}}\nif(this.func && this.func.value=='input'){$get_node(this).blocking={'type':'input'}}}\n$CallCtx.prototype.ast=function(){var res=new ast.Call(ast_or_obj(this.func),[],[])\nfor(var call_arg of this.tree){if(call_arg.type=='double_star_arg'){var value=ast_or_obj(call_arg.tree[0].tree[0]),keyword=new ast.keyword(_b_.None,value)\ndelete keyword.arg\nres.keywords.push(keyword)}else if(call_arg.type=='star_arg'){var starred=new ast.Starred(ast_or_obj(call_arg.tree[0]))\nstarred.ctx=new ast.Load()\nres.args.push(starred)}else if(call_arg.type=='genexpr'){res.args.push(call_arg.ast())}else{var item=call_arg.tree[0]\nif(item===undefined){\ncontinue}\nif(item.type=='kwarg'){res.keywords.push(new ast.keyword(item.tree[0].value,ast_or_obj(item.tree[1])))}else{res.args.push(ast_or_obj(item))}}}\nreturn res}\n$CallCtx.prototype.toString=function(){return '(call) '+this.func+'('+this.tree+')'}\n$CallCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case ',':\nif(C.expect=='id'){$_SyntaxError(C,token)}\nC.expect='id'\nreturn C\ncase 'await':\ncase 'id':\ncase 'imaginary':\ncase 'int':\ncase 'float':\ncase 'str':\ncase 'JoinedStr':\ncase 'bytes':\ncase '[':\ncase '(':\ncase '{':\ncase '.':\ncase 'not':\ncase 'lambda':\ncase 'ellipsis':\nC.expect=','\nreturn $transition(new $CallArgCtx(C),token,value)\ncase ')':\nC.end=$pos\nreturn C.parent\ncase 'op':\nC.expect=','\nswitch(value){case '-':\ncase '~':\ncase '+':\nC.expect=','\nreturn $transition(new $CallArgCtx(C),token,value)\ncase '*':\nC.has_star=true\nreturn new $StarArgCtx(C)\ncase '**':\nC.has_dstar=true\nreturn new $DoubleStarArgCtx(C)}\n$_SyntaxError(C,token)\ncase 'yield':\n$_SyntaxError(C,token)}\nreturn $transition(C.parent,token,value)}\n$CallCtx.prototype.to_js=function(){this.js_processed=true\nif(this.tree.length > 0){if(this.tree[this.tree.length-1].tree.length==0){\nthis.tree.pop()}}\nvar func_js=this.func.to_js()\nif(this.func !==undefined){switch(this.func.value){case 'classmethod':\nreturn '_b_.classmethod.$factory('+$to_js(this.tree)+')'\ndefault:\nif(this.func.type=='unary'){\nvar res='$B.$getattr('+$to_js(this.tree)\nswitch(this.func.op){case '+':\nreturn res+',\"__pos__\")()'\ncase '-':\nreturn res+',\"__neg__\")()'\ncase '~':\nreturn res+',\"__invert__\")()'}}}\nvar _block=false\nvar positional=[],kw_args=[],star_args=false,dstar_args=[]\nfor(var arg of this.tree){var type\nswitch(arg.type){case 'star_arg':\nstar_args=true\npositional.push([arg.tree[0].tree[0].to_js(),'*'])\nbreak\ncase 'double_star_arg':\ndstar_args.push(arg.tree[0].tree[0].to_js())\nbreak\ncase 'id':\npositional.push([arg.to_js(),'s'])\nbreak\ndefault:\ntype=arg.tree[0].type\nswitch(type){case 'expr':\npositional.push([arg.to_js(),'s'])\nbreak\ncase 'kwarg':\nkw_args.push(arg.tree[0].tree[0].value+\n':'+arg.tree[0].tree[1].to_js())\nbreak\ncase 'list_or_tuple':\ncase 'op':\npositional.push([arg.to_js(),'s'])\nbreak\ndefault:\npositional.push([arg.to_js(),'s'])\nbreak}\nbreak}}\nvar args_str\nif(star_args){\nvar p=[]\nfor(var i=0,len=positional.length;i < len;i++){arg=positional[i]\nif(arg[1]=='*'){\np.push('_b_.list.$factory('+arg[0]+')')}else{var elt=[positional[i][0]]\ni++\nwhile(i < len && positional[i][1]=='s'){elt.push(positional[i][0])\ni++}\ni--\np.push('['+elt.join(',')+']')}}\nargs_str=p[0]\nfor(var i=1;i < p.length;i++){args_str+='.concat('+p[i]+')'}}else{for(var i=0,len=positional.length;i < len;i++){positional[i]=positional[i][0]}\nargs_str=positional.join(', ')}\nvar kw_args_str='{'+kw_args.join(', ')+'}'\nif(dstar_args.length){kw_args_str='{$nat:\"kw\",kw:['+kw_args_str+','+\ndstar_args.join(', ')+']}'}else if(kw_args_str !='{}'){kw_args_str='{$nat:\"kw\",kw:'+kw_args_str+'}'}else{kw_args_str=''}\nif(star_args && kw_args_str){args_str+='.concat(['+kw_args_str+'])'}else{if(args_str && kw_args_str){args_str+=','+kw_args_str}\nelse if(!args_str){args_str=kw_args_str}}\nif(star_args){\nargs_str='.apply(null,'+args_str+')'}else{args_str='('+args_str+')'}\nvar default_res=\"$B.$call(\"+func_js+\")\"+args_str\nif(this.tree.length >-1 && this.func.type=='id' &&\nthis.func.is_builtin){\nvar classes=[\"complex\",\"bytes\",\"bytearray\",\"object\",\"memoryview\",\"int\",\"float\",\"str\",\"list\",\"tuple\",\"dict\",\"set\",\"frozenset\",\"range\",\"slice\",\"zip\",\"bool\",\"type\",\"classmethod\",\"staticmethod\",\"enumerate\",\"reversed\",\"property\",\"$$super\",\"zip\",\"map\",\"filter\"]\nif($B.builtin_funcs[this.func.value]!==undefined){if(classes.indexOf(this.func.value)==-1){\nreturn func_js+args_str}else{\nreturn func_js+\".$factory\"+args_str}}}\nreturn default_res}}\nvar $CaseCtx=$B.parser.$CaseCtx=function(node_ctx){\nthis.type=\"case\"\nnode_ctx.tree=[this]\nthis.parent=node_ctx\nthis.tree=[]\nthis.expect='as'}\n$CaseCtx.prototype.ast=function(){\nreturn new ast.match_case(ast_or_obj(this.tree[0]),this.has_guard ? ast_or_obj(this.tree[1].tree[0]):undefined,ast_body(this.parent))}\n$CaseCtx.prototype.set_alias=function(name){this.alias=name}\n$CaseCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'as':\nC.expect=':'\nreturn new $AbstractExprCtx(new $AliasCtx(C))\ncase ':':\nfunction is_irrefutable(pattern){var cause\nif(pattern.type==\"capture_pattern\"){return pattern.tree[0]}else if(pattern.type==\"or_pattern\"){for(var subpattern of pattern.tree){if(cause=is_irrefutable(subpattern)){return cause}}}else if(pattern.type==\"sequence_pattern\" &&\npattern.token=='(' &&\npattern.tree.length==1 &&\n(cause=is_irrefutable(pattern.tree[0]))){return cause}\nreturn false}\nvar cause\nif(cause=is_irrefutable(this.tree[0])){\n$get_node(C).parent.irrefutable=cause}\nswitch(C.expect){case 'id':\ncase 'as':\ncase ':':\nvar last=$B.last(C.tree)\nif(last && last.type=='sequence_pattern'){remove_empty_pattern(last)}\nreturn $BodyCtx(C)}\nbreak\ncase 'op':\nif(value=='|'){return new $PatternCtx(new $PatternOrCtx(C))}\n$_SyntaxError(C,['expected :'])\ncase ',':\nif(C.expect==':' ||C.expect=='as'){return new $PatternCtx(new $PatternSequenceCtx(C))}\ncase 'if':\nC.has_guard=true\nreturn new $AbstractExprCtx(new $ConditionCtx(C,token),false)\ndefault:\n$_SyntaxError(C,['expected :'])}}\n$CaseCtx.prototype.to_js=function(){var node=$get_node(this),rank=node.parent.children.indexOf(node),prefix=rank==0 ? 'if' :'else if'\nif(this.has_guard){\nvar guard=this.tree.pop(),guard_js=guard.to_js().substr(3),\nguard_js=guard_js.substr(0,guard_js.length-1)}\nreturn prefix+'(($locals.$line_info=\"'+node.line_num+','+\nnode.module+'\") && $B.pattern_match(subject, '+$to_js(this.tree)+\n(this.alias ? `, {as: \"${this.alias.value}\"}` :'')+')'+\n(this.has_guard ? ' && '+guard_js :'')+')'}\nvar $ClassCtx=$B.parser.$ClassCtx=function(C){\nthis.type='class'\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this\nthis.expect='id'\nvar scope=this.scope=$get_scope(this)\nthis.parent.node.parent_block=scope\nthis.parent.node.bound={}\nthis.parent.node.binding={__annotations__:true}}\n$ClassCtx.prototype.ast=function(){\nvar decorators=get_decorators(this.parent.node),bases=[],keywords=[]\nif(this.args){for(var arg of this.args.tree){if(arg.tree[0].type=='kwarg'){keywords.push(new ast.keyword(arg.tree[0].tree[0].value,ast_or_obj(arg.tree[0].tree[1])))}else{bases.push(ast_or_obj(arg.tree[0]))}}}\nreturn new ast.ClassDef(this.name,bases,keywords,ast_body(this.parent),decorators)}\n$ClassCtx.prototype.toString=function(){return '(class) '+this.name+' '+this.tree+' args '+this.args}\n$ClassCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\nif(C.expect=='id'){C.set_name(value)\nC.expect='(:'\nreturn C}\nbreak\ncase '(':\nreturn new $CallCtx(C)\ncase ':':\nif(this.args){for(var arg of this.args.tree){var param=arg.tree[0]\nif((param.type=='expr' && param.name=='id')||\nparam.type==\"kwarg\"){continue}\n$_SyntaxError(C,'invalid class parameter')}}\nreturn $BodyCtx(C)}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$ClassCtx.prototype.set_name=function(name){var C=this.parent\nthis.random=$B.UUID()\nthis.name=name\nthis.id=C.node.module+'_'+name+'_'+this.random\nthis.binding={}\nthis.parent.node.id=this.id\nvar scope=this.scope,parent_block=scope\nvar block=scope,parent_classes=[]\nwhile(block.ntype==\"class\"){parent_classes.splice(0,0,block.C.tree[0].name)\nblock=block.parent}\nthis.qualname=parent_classes.concat([name]).join(\".\")\nwhile(parent_block.C &&\nparent_block.C.tree[0].type=='class'){parent_block=parent_block.parent}\nwhile(parent_block.C &&\n'def' !=parent_block.C.tree[0].type &&\n'generator' !=parent_block.C.tree[0].type){parent_block=parent_block.parent}\nthis.parent.node.parent_block=parent_block\n$bind(name,scope,this)\nif(scope.is_function){if(scope.C.tree[0].locals.indexOf(name)==-1){scope.C.tree[0].locals.push(name)}}}\n$ClassCtx.prototype.transform=function(node,rank){\nthis.doc_string=$get_docstring(node)\nthis.module=$get_module(this).module.replace(/\\./g,'_')\nvar indent='\\n'+' '.repeat(node.indent+12),instance_decl=new $Node(),local_ns='$locals_'+this.id.replace(/\\./g,'_'),js='var '+local_ns+' = {'+\n'__annotations__: $B.empty_dict()}, '+\nindent+'$locals = '+local_ns\nnew $NodeJSCtx(instance_decl,js)\nnode.insert(0,instance_decl)\nvar global_scope=this.scope\nwhile(global_scope.parent_block.id !=='__builtins__'){global_scope=global_scope.parent_block}\nvar global_ns='$locals_'+global_scope.id.replace(/\\./g,'_')\nvar js=' '.repeat(node.indent+4)+\n'$locals.$name = \"'+this.name+'\"'+indent+\n'$locals.$qualname = \"'+this.qualname+'\"'+indent+\n'$locals.$is_class = true; '+indent+\n'$locals.$line_info = \"'+node.line_num+','+\nthis.module+'\";'+indent+\n'var $top_frame = [\"'+local_ns+'\", $locals,'+'\"'+\nglobal_scope.id+'\", '+global_ns+']'+\nindent+'$locals.$f_trace = $B.enter_frame($top_frame);'+\nindent+'if($locals.$f_trace !== _b_.None){\\n'+\n'$locals.$f_trace = $B.trace_line()}'\nnode.insert(1,$NodeJS(js))\nnode.add($NodeJS('if($locals.$f_trace !== _b_.None){\\n'+\n'$B.trace_return(_b_.None)}'))\nnode.add($NodeJS('$B.leave_frame({$locals})'))\nvar ret_obj=new $Node()\nnew $NodeJSCtx(ret_obj,'return '+local_ns+';')\nnode.insert(node.children.length,ret_obj)\nvar run_func=new $Node()\nnew $NodeJSCtx(run_func,')();')\nnode.parent.insert(rank+1,run_func)\nvar module_name='$locals_'+this.module+'.__name__'\nrank++\nnode.parent.insert(rank+1,$NodeJS('$'+this.name+'_'+this.random+\".__module__ = \"+\nmodule_name))\nvar scope=$get_scope(this)\nvar name_ref=';$locals_'+scope.id.replace(/\\./g,'_')\nname_ref+='[\"'+this.name+'\"]'\nvar js=[name_ref+' = $B.$class_constructor(\"'+this.name],pos=1\njs[pos++]='\", $'+this.name+'_'+this.random\nif(this.args !==undefined){\nvar arg_tree=this.args.tree,args=[],kw=[]\nfor(var _tmp of arg_tree){if(_tmp.tree[0].type=='kwarg'){kw.push(_tmp.tree[0])}\nelse{args.push(_tmp.to_js())}}\njs[pos++]=', _b_.tuple.$factory(['+args.join(',')+']),['\nvar _re=new RegExp('\"','g'),_r=[],rpos=0\nfor(var arg of args){_r[rpos++]='\"'+arg.replace(_re,'\\\\\"')+'\"'}\njs[pos++]=_r.join(',')+']'\n_r=[]\nrpos=0\nfor(var _tmp of kw){_r[rpos++]='[\"'+_tmp.tree[0].value+'\",'+\n_tmp.tree[1].to_js()+']'}\njs[pos++]=',['+_r.join(',')+']'}else{\njs[pos++]=', _b_.tuple.$factory([]),[],[]'}\njs[pos++]=')'\nvar cl_cons=new $Node()\nnew $NodeJSCtx(cl_cons,js.join(''))\nrank++\nnode.parent.insert(rank+1,cl_cons)\nrank++\nvar ds_node=new $Node()\njs=name_ref+'.__doc__ = '+(this.doc_string ||'_b_.None')+';'\nnew $NodeJSCtx(ds_node,js)\nnode.parent.insert(rank+1,ds_node)\nif(scope.ntype=='module'){var w_decl=new $Node()\nnew $NodeJSCtx(w_decl,'$locals[\"'+this.name+'\"] = '+\nthis.name)}\nnode.parent.insert(rank+2,$NodeJS(\"_b_.None;\"))\nthis.transformed=true}\n$ClassCtx.prototype.to_js=function(){this.js_processed=true\nreturn 'var $'+this.name+'_'+this.random+' = (function()'}\nvar Comprehension={admin_infos:function(comp){var id=comp.id,node=$get_node(comp)\nreturn `var $locals_${id} = {},\n            $locals = $locals_${id}\n        $locals.$line_info = '${node.line_num},${node.module}'\\n`+\nComprehension.code(comp)+\n`var $top_frame = [\"${id}\", $locals_${id}, \"${comp.module}\", $locals_${comp.module_ref}]\n        $locals.$f_trace = $B.enter_frame($top_frame)\n        `},code:function(comp){var node=$get_node(comp),varnames=Object.keys(comp.varnames ||{}).map(x=> `'${x}'`).join(', ')\nreturn `$locals.$comp_code = {\n            co_argcount: 1,\n            co_firstlineno:${node.line_num},\n            co_name: \"<${comp.type}>\",\n            co_flags: ${comp.type == 'genexpr' ? 115 : 83},\n            co_freevars: $B.fast_tuple([]),\n            co_kwonlyargcount: 0,\n            co_posonlyargount: 0,\n            co_varnames: $B.fast_tuple(['.0', ${varnames}])\n        }\n        $locals['.0'] = expr\\n`},generators:function(comp){\nvar comprehensions=[]\nfor(item of comp){if(item.type=='for'){comprehensions.push(\nnew ast.comprehension(\nast_or_obj(item.tree[0]),ast_or_obj(item.tree[1]),[],item.is_async ? 1 :0\n)\n)}else{$B.last(comprehensions).ifs.push(ast_or_obj(item.tree[0]))}}\nreturn comprehensions},make_comp:function(comp,C){comp.comprehension=true\ncomp.parent=C.parent\ncomp.binding={}\ncomp.id=comp.type+$B.UUID()\nvar scope=$get_scope(C)\ncomp.parent_block=scope\nwhile(scope){if(scope.C && scope.C.tree &&\nscope.C.tree.length > 0 &&\nscope.C.tree[0].async){comp.async=true\nbreak}\nscope=scope.parent_block}\ncomp.module=$get_module(C).module\ncomp.module_ref=comp.module.replace(/\\./g,'_')\nC.parent.tree[C.parent.tree.length-1]=comp\nComprehension.set_parent_block(C.tree[0],comp)},set_parent_block:function(ctx,parent_block){if(ctx.tree){for(var item of ctx.tree){if(item.comprehension){item.parent_block=parent_block}\nComprehension.set_parent_block(item,parent_block)}}},get_awaits:function(ctx,awaits){\nawaits=awaits ||[]\nif(ctx.type=='await'){awaits.push(ctx)}else if(ctx.tree){for(var item of ctx.tree){Comprehension.get_awaits(item,awaits)}}\nreturn awaits},has_await:function(ctx){\nvar node=$get_node(ctx),awaits=Comprehension.get_awaits(ctx)\nfor(var aw of awaits){var ix=node.awaits.indexOf(aw)\nif(ix >-1){node.awaits.splice(ix,1)}}\nreturn awaits.length > 0}}\nvar $ConditionCtx=$B.parser.$ConditionCtx=function(C,token){\nthis.type='condition'\nthis.token=token\nthis.parent=C\nthis.tree=[]\nthis.node=$get_node(this)\nthis.scope=$get_scope(this)\nif(token=='while'){this.loop_num=$loop_num++}\nif(token=='elif'){\nvar rank=this.node.parent.children.indexOf(this.node),previous=this.node.parent.children[rank-1]\nprevious.C.tree[0].orelse=this}\nC.tree.push(this)}\n$ConditionCtx.prototype.ast=function(){\nvar types={'if':'If','while':'While','elif':'If'}\nvar res=new ast[types[this.token]](ast_or_obj(this.tree[0]))\nif(this.orelse){if(this.orelse.token=='elif'){res.orelse=[ast_or_obj(this.orelse)]}else{res.orelse=ast_or_obj(this.orelse)}}else{res.orelse=[]}\nres.body=ast_body(this)\nreturn res}\n$ConditionCtx.prototype.toString=function(){return this.token+' '+this.tree}\n$ConditionCtx.prototype.transition=function(token,value){var C=this\nif(token==':'){if(C.tree[0].type==\"abstract_expr\" &&\nC.tree[0].tree.length==0){\n$_SyntaxError(C,'token '+token+' after '+C)}\nreturn $BodyCtx(C)}else if(this.in_comp && this.token=='if'){\nif(token==']'){return $transition(C.parent,token,value)}else if(token=='if'){var if_exp=new $ConditionCtx(C.parent,'if')\nif_exp.in_comp=true\nreturn new $AbstractExprCtx(if_exp,false)}else if(')]}'.indexOf(token)>-1){return $transition(this.parent,token,value)}}\n$_SyntaxError(C,[\"expected ':'\"])}\n$ConditionCtx.prototype.transform=function(node,rank){var scope=$get_scope(this)\nif(this.token==\"while\"){node.parent.insert(rank,$NodeJS('var $no_break'+this.loop_num+' = true'))\nvar module=$get_module(this).module\nif($B.last(node.children).C.tree[0].type !=\"return\"){var js='$locals.$line_info = \"'+node.line_num+\n','+module+'\";if($locals.$f_trace !== _b_.None){\\n'+\n'$B.trace_line()};_b_.None;'\nnode.add($NodeJS(js))}\nreturn 2}}\n$ConditionCtx.prototype.to_js=function(){this.js_processed=true\nvar tok=this.token\nif(tok=='elif'){tok='else if'}\nvar res=[tok+'($B.$bool(']\nif(tok=='while'){res.push('$no_break'+this.loop_num+' && ')}else if(tok=='else if'){var line_info=$get_node(this).line_num+','+\n$get_scope(this).id\nres.push('($B.set_line(\"'+line_info+'\")) && ')}\nif(this.tree.length==1){res.push($to_js(this.tree)+'))')}else{\nres.push(this.tree[0].to_js()+'))')\nif(this.tree[1].tree.length > 0){res.push('{'+this.tree[1].to_js()+'}')}}\nreturn res.join('')}\nvar $ContinueCtx=$B.parser.$ContinueCtx=function(C){\nthis.type='continue'\nthis.parent=C\n$get_node(this).is_continue=true\nC.tree[C.tree.length]=this\nset_loop_context.apply(this,[C,'continue'])}\n$ContinueCtx.prototype.ast=function(){return new ast.Continue()}\n$ContinueCtx.prototype.toString=function(){return '(continue)'}\n$ContinueCtx.prototype.transition=function(token,value){var C=this\nif(token=='eol'){return C.parent}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$ContinueCtx.prototype.to_js=function(){this.js_processed=true\nvar js='continue'\nif(this.loop_ctx.has_break){\njs=`$locals[\"$no_break${this.loop_ctx.loop_num}\"] = true;${js}`}\nreturn js}\nvar $DebuggerCtx=$B.parser.$DebuggerCtx=function(C){\nthis.type='continue'\nthis.parent=C\nC.tree[C.tree.length]=this}\n$DebuggerCtx.prototype.toString=function(){return '(debugger)'}\n$DebuggerCtx.prototype.transition=function(token,value){var C=this}\n$DebuggerCtx.prototype.to_js=function(){this.js_processed=true\nreturn 'debugger'}\nvar $DecoratorCtx=$B.parser.$DecoratorCtx=function(C){\nthis.type='decorator'\nthis.parent=C\nC.tree[C.tree.length]=this\nthis.tree=[]}\n$DecoratorCtx.prototype.toString=function(){return '(decorator) '+this.tree}\n$DecoratorCtx.prototype.transition=function(token,value){var C=this\nif(token=='id' && C.tree.length==0){return $transition(new $AbstractExprCtx(C,false),token,value)}\nif(token=='eol'){return $transition(C.parent,token)}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$DecoratorCtx.prototype.transform=function(node,rank){var func_rank=rank+1,children=node.parent.children,decorators=[this.tree]\nwhile(1){if(func_rank >=children.length){$_SyntaxError(node.C,['decorator expects function'])}\nelse if(children[func_rank].C.type=='node_js'){func_rank++}else if(children[func_rank].C.tree[0].type==\n'decorator'){decorators.push(children[func_rank].C.tree[0].tree)\nchildren.splice(func_rank,1)}else{break}}\nthis.dec_ids=[]\nvar pos=0\nfor(var _ of decorators){this.dec_ids.push('$id'+$B.UUID())}\nvar obj=children[func_rank].C.tree[0]\nif(obj.type=='def'){obj.decorated=true\nobj.alias='$dec'+$B.UUID()}\nvar tail='',scope=$get_scope(this),ref='$locals[\"'\nif(scope.globals && scope.globals.has(obj.name)){var module=$get_module(this)\nref='$locals_'+module.id+'[\"'}\nref+=obj.name+'\"]'\nvar res=ref+' = '\ndecorators.forEach(function(elt,i){res+='$B.$call('+this.dec_ids[i]+')('\ntail+=')'},this)\nres+=(obj.decorated ? obj.alias :ref)+tail+';'\n$bind(obj.name,scope,this)\nnode.parent.insert(func_rank+1,$NodeJS(res))\nthis.decorators=decorators}\n$DecoratorCtx.prototype.to_js=function(){this.js_processed=true\nvar res=[]\nthis.decorators.forEach(function(decorator,i){res.push('var '+this.dec_ids[i]+' = '+\n$to_js(decorator)+';')},this)\nreturn res.join('')}\nfunction get_decorators(node){var decorators=[]\nvar parent_node=node.parent\nvar rank=parent_node.children.indexOf(node)\nwhile(true){rank--\nif(rank < 0){break}else if(parent_node.children[rank].C.tree[0].type==\n'decorator'){var deco=parent_node.children[rank].C.tree[0].tree[0]\ndecorators.splice(0,0,ast_or_obj(deco))}else{break}}\nreturn decorators}\nvar $DefCtx=$B.parser.$DefCtx=function(C){this.type='def'\nthis.name=null\nthis.parent=C\nthis.tree=[]\nthis.async=C.async\nthis.locals=[]\nC.tree[C.tree.length]=this\nthis.enclosing=[]\nvar scope=this.scope=$get_scope(this)\nif(scope.C && scope.C.tree[0].type==\"class\"){this.class_name=scope.C.tree[0].name}\nC.node.binding={}\nvar parent_block=scope\nwhile(parent_block.C &&\nparent_block.C.tree[0].type=='class'){parent_block=parent_block.parent}\nwhile(parent_block.C &&\n'def' !=parent_block.C.tree[0].type){parent_block=parent_block.parent}\nthis.parent.node.parent_block=parent_block\nvar pb=parent_block\nthis.is_comp=pb.is_comp\nwhile(pb && pb.C){if(pb.C.tree[0].type=='def'){this.inside_function=true\nbreak}\npb=pb.parent_block}\nthis.module=scope.module\nthis.root=$get_module(this)\nthis.num=$loop_num\n$loop_num++\nthis.positional_list=[]\nthis.default_list=[]\nthis.other_args=null\nthis.other_kw=null\nthis.after_star=[]}\n$DefCtx.prototype.ast=function(){var args={posonlyargs:[],args:[],kwonlyargs:[],kw_defaults:[],defaults:[]},decorators=get_decorators(this.parent.node),func_args=this.tree[1],state='arg',default_value,res\nargs=ast_or_obj(func_args)\nif(this.async){res=new ast.AsyncFunctionDef(this.name,args,[],decorators)}else{res=new ast.FunctionDef(this.name,args,[],decorators)}\nif(this.annotation){res.returns=ast_or_obj(this.annotation.tree[0])}\nres.body=ast_body(this.parent)\nreturn res}\n$DefCtx.prototype.set_name=function(name){\nif([\"None\",\"True\",\"False\"].indexOf(name)>-1){$_SyntaxError(this,'invalid function name')}\nvar id_ctx=new $IdCtx(this,name)\nthis.name=name\nthis.id=this.scope.id+'_'+name\nthis.id=this.id.replace(/\\./g,'_')\nthis.id+='_'+$B.UUID()\nthis.parent.node.id=this.id\nthis.parent.node.module=this.module\nthis.binding={}\nvar scope=this.scope\nif(scope.globals !==undefined &&\nscope.globals.has(name)){\n$bind(name,this.root,this)}else{$bind(name,scope,this)}\nid_ctx.bound=true\nif(scope.is_function){if(scope.C.tree[0].locals.indexOf(name)==-1){scope.C.tree[0].locals.push(name)}}}\n$DefCtx.prototype.toString=function(){return 'def '+this.name+'('+this.tree+')'}\n$DefCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\nif(C.name){$_SyntaxError(C,'token '+token+' after '+C)}\nC.set_name(value)\nreturn C\ncase '(':\nif(C.name==null){$_SyntaxError(C,\"missing name in function definition\")}\nC.has_args=true;\nreturn new $FuncArgs(C)\ncase 'annotation':\nreturn new $AbstractExprCtx(new $AnnotationCtx(C),true)\ncase ':':\nif(C.has_args){return $BodyCtx(C)}else{$_SyntaxError(C,\"missing function parameters\")}\ncase 'eol':\nif(C.has_args){$_SyntaxError(C,\"missing colon\")}}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$DefCtx.prototype.transform=function(node,rank){if(this.is_comp){$get_node(this).is_comp=true}\nif(this.transformed !==undefined){return}\nvar scope=this.scope\nthis.doc_string=$get_docstring(node)\nthis.rank=rank \nvar indent=node.indent+12\nif(this.name.substr(0,15)=='lambda_'+$B.lambda_magic){var pblock=scope.parent_block\nif(pblock.C && pblock.C.tree[0].type==\"def\"){this.enclosing.push(pblock)}}\nvar pnode=this.parent.node\nwhile(pnode.parent && pnode.parent.is_def_func){this.enclosing.push(pnode.parent.parent)\npnode=pnode.parent.parent}\nvar defaults=[],defs1=[],has_end_pos=false\nthis.argcount=0\nthis.kwonlyargcount=0 \nthis.kwonlyargsdefaults=[]\nthis.otherdefaults=[]\nthis.varnames={}\nthis.args=[]\nthis.__defaults__=[]\nthis.slots=[]\nvar slot_list=[],slot_init=[],annotations=[]\nif(this.annotation){annotations.push('\"return\":'+this.annotation.to_js())}\nthis.func_name=this.tree[0].to_js()\nvar func_name1=this.func_name\nif(this.decorated){this.func_name='var '+this.alias\nfunc_name1=this.alias}\nvar func_args=this.tree[1].tree\nfor(var arg of func_args){if(arg.type=='end_positional'){this.args.push(\"/\")\nslot_list.push('\"/\"')\nhas_end_pos=true}else{this.args.push(arg.name)\nthis.varnames[arg.name]=true}\nif(arg.type=='func_arg_id'){if(this.star_arg){this.kwonlyargcount++\nif(arg.has_default){this.kwonlyargsdefaults.push(arg.name)}}\nelse{this.argcount++\nif(arg.has_default){this.otherdefaults.push(arg.name)}}\nthis.slots.push('\"'+arg.name+'\":null')\nslot_list.push('\"'+arg.name+'\"')\nslot_init.push('\"'+arg.name+'\": _'+arg.name)\nif(arg.tree.length > 0){defaults.push('\"'+arg.name+'\"')\ndefs1.push(arg.name+':'+$to_js(arg.tree))\nthis.__defaults__.push($to_js(arg.tree))}}else if(arg.type=='func_star_arg'){if(arg.op=='*'){this.star_arg=arg.name}\nelse if(arg.op=='**'){this.kw_arg=arg.name}}\nif(arg.annotation){var name=$mangle(arg.name,this)\nannotations.push(name+': '+arg.annotation.to_js())}}\nslot_init='{'+slot_init.join(\", \")+'}'\nvar flags=67\nif(this.star_arg){flags |=4}\nif(this.kw_arg){flags |=8}\nif(this.type=='generator'){flags |=32}\nif(this.async){flags |=128}\nvar nodes=[],js\nvar global_scope=scope\nwhile(global_scope.parent_block &&\nglobal_scope.parent_block.id !=='__builtins__'){global_scope=global_scope.parent_block}\nvar global_ns='$locals_'+global_scope.id.replace(/\\./g,'_')\nvar name=this.name+this.num\nvar local_ns='$locals_'+this.id,h='\\n'+' '.repeat(indent)\njs='var '+local_ns+' = {},'+\nh+'$locals = '+local_ns+';'\nvar new_node=new $Node()\nnew_node.locals_def=true\nnew_node.func_node=node\nnew $NodeJSCtx(new_node,js)\nnodes.push(new_node)\nvar enter_frame_nodes=[$NodeJS('$locals.$line_info = \"'+node.line_num+','+\nthis.module+'\"'),$NodeJS(`var $top_frame = [\"${this.id}\", $locals,`+\n'\"'+global_scope.id+'\", '+global_ns+', '+\n(this.is_comp ? this.name :name)+']'),$NodeJS('$locals.$f_trace = $B.enter_frame($top_frame)'),$NodeJS('var $stack_length = $B.frames_stack.length;')\n]\nif(this.type==\"generator\"){enter_frame_nodes.push($NodeJS(\"$locals.$is_generator = true\"))}\nif(this.async){enter_frame_nodes.splice(1,0,$NodeJS(`$locals.$async = \"${this.id}\"`))}\nfor(var _node of enter_frame_nodes){_node.enter_frame=true}\nif(this.is_comp){nodes.push($NodeJS(\"var $defaults = {}\"))}\nthis.env=[]\nvar make_args_nodes=[]\nvar js=local_ns+' = $locals = $B.args(\"'+this.name+'\", '+\nthis.argcount+', {'+this.slots.join(', ')+'}, '+\n'['+slot_list.join(', ')+'], arguments, $defaults, '+\nthis.other_args+', '+this.other_kw+');'\nvar new_node=new $Node()\nnew $NodeJSCtx(new_node,js)\nmake_args_nodes.push(new_node)\nvar only_positional=false\nif(this.other_args===null && this.other_kw===null &&\nthis.after_star.length==0 && !has_end_pos){\nonly_positional=true\nnodes.push($NodeJS('var $len = arguments.length;'))\nvar new_node=new $Node()\nvar js='var last_arg;if($len > 0 && ((last_arg = '+\n'arguments[$len - 1]) !== undefined) && last_arg.$nat '+\n'!== undefined)'\nnew $NodeJSCtx(new_node,js)\nnodes.push(new_node)\nfor(var item of make_args_nodes){new_node.add(item)}\nvar else_node=new $Node()\nnew $NodeJSCtx(else_node,'else')\nnodes.push(else_node)\nvar pos_len=this.slots.length\nvar test_node=$NodeJS('if($len == '+pos_len+')')\nelse_node.add(test_node)\ntest_node.add($NodeJS(local_ns+' = $locals = $B.conv_undef('+\nslot_init+')'))\nelse_node.add($NodeJS('else if($len > '+pos_len+\n'){\\n$B.wrong_nb_args(\"'+this.name+'\", $len, '+\npos_len+', ['+slot_list+'])}'))\nif(pos_len > 0){\nelse_node.add($NodeJS('else if($len + Object.keys($defaults).length < '+\npos_len+'){\\n$B.wrong_nb_args(\"'+this.name+\n'\", $len, '+pos_len+', ['+slot_list+'])}'))\nvar subelse_node=$NodeJS(\"else\")\nelse_node.add(subelse_node)\nsubelse_node.add($NodeJS(local_ns+' = $locals = '+\n'$B.conv_undef('+slot_init+')'))\nsubelse_node.add($NodeJS(\"var defparams = [\"+slot_list+\"]\"))\nsubelse_node.add($NodeJS(\"for(var i = $len; i < defparams.length\"+\n\"; i++){\\n$locals[defparams[i]] = $defaults[defparams[i]]}\"))}}else{nodes.push(make_args_nodes[0])\nif(make_args_nodes.length > 1){nodes.push(make_args_nodes[1])}}\nnodes=nodes.concat(enter_frame_nodes)\nvar is_method=scope.ntype==\"class\"\nif(is_method){var scope_ref='$locals_'+scope.parent_block.id.replace(/\\./g,'_'),class_ref=scope.C.tree[0].qualname\nvar had_class=this.parent.node.binding[\"__class__\"]\nthis.parent.node.binding[\"__class__\"]=true\nnodes.push($NodeJS('$locals.__class__ = $B.get_method_class('+\nscope_ref+', \"'+class_ref+'\")'))}\nnodes.push($NodeJS('$B.js_this = this;'))\nfor(var i=nodes.length-1;i >=0;i--){node.children.splice(0,0,nodes[i])}\nvar def_func_node=new $Node()\nthis.params=''\nif(only_positional){this.params=Object.keys(this.varnames).map(x=> '_'+x).join(', ')}\nnew $NodeJSCtx(def_func_node,'')\ndef_func_node.is_def_func=true\ndef_func_node.module=this.module\nvar last_node=node.children[node.children.length-1],indent=last_node.get_indent(),last_instr=last_node.C.tree[0]\nif(last_instr.type !='return'){\njs='if($locals.$f_trace !== _b_.None){\\n$B.trace_return(_b_.None)}\\n'+\n'    '.repeat(indent+1)\njs+='$B.leave_frame'\nif(this.id.substr(0,5)=='$exec'){js+='_exec'}\njs+='({$locals});return _b_.None'\nnode.add($NodeJS(js))}\nvar free_vars=[]\nif(this.parent.node.referenced){for(var attr in this.parent.node.referenced){if(! this.parent.node.binding.hasOwnProperty(attr)){free_vars.push('\"'+attr+'\"')}}}\nif(this.parent.node.nonlocals){for(var key of this.parent.node.nonlocals){var attr='\"'+key+'\"'\nif(free_vars.indexOf(attr)==-1){free_vars.push(attr)}}}\nnode.add(def_func_node)\nvar offset=1,indent=node.indent\nif(! this.is_comp){\nnode.parent.insert(rank+offset++,$NodeJS(name+'.$is_func = true'))\nif(this.$has_yield_in_cm){node.parent.insert(rank+offset++,$NodeJS(name+'.$has_yield_in_cm = true'))}\nnode.parent.insert(rank+offset++,$NodeJS(name+'.$infos = {'))\nvar __name__=this.name\nif(__name__.substr(0,15)=='lambda_'+$B.lambda_magic){__name__=\"<lambda>\"}\njs='    __name__:\"'+__name__+'\",'\nnode.parent.insert(rank+offset++,$NodeJS(js))\nvar __qualname__=__name__\nif(this.class_name){__qualname__=this.class_name+'.'+__name__}\njs='    __qualname__:\"'+__qualname__+'\",'\nnode.parent.insert(rank+offset++,$NodeJS(js))\nif(this.otherdefaults.length > 0){var def_names=[]\nfor(var _default of this.otherdefaults){def_names.push('$defaults.'+_default)}\nnode.parent.insert(rank+offset++,$NodeJS('    __defaults__ : '+\n'$B.fast_tuple(['+def_names.join(', ')+']),'))}else{node.parent.insert(rank+offset++,$NodeJS('    __defaults__ : '+\n'_b_.None,'))}\nif(this.kwonlyargsdefaults.lengh > 0){var def_names=[]\nfor(var _default of this.kwonlyargsdefaults){def_names.push('$defaults.'+_default)}\nnode.parent.insert(rank+offset++,$NodeJS('    __kwdefaults__ : '+\n'$B.fast_tuple(['+def_names.join(', ')+']),'))}else{node.parent.insert(rank+offset++,$NodeJS('    __kwdefaults__ : '+\n'_b_.None,'))}\nnode.parent.insert(rank+offset++,$NodeJS('    __annotations__: {'+annotations.join(',')+'},'))\nnode.parent.insert(rank+offset++,$NodeJS('    __dict__: $B.empty_dict(),'))\nnode.parent.insert(rank+offset++,$NodeJS('    __doc__: '+(this.doc_string ||'_b_.None')+','))\nvar root=$get_module(this)\nnode.parent.insert(rank+offset++,$NodeJS('    __module__ : \"'+root.module+'\",'))\nfor(var attr in this.parent.node.binding){\nif(attr==\"__class__\" && is_method && ! had_class){continue}\nthis.varnames[attr]=true}\nvar co_varnames=[]\nfor(var attr in this.varnames){co_varnames.push('\"'+attr+'\"')}\nvar CODE_MARKER='___%%%-CODE-%%%___'+this.name+this.num;\nvar h='\\n'+' '.repeat(indent+8)\njs='    __code__:{'+h+'    co_argcount:'+this.argcount\nvar h1=','+h+' '.repeat(4)\nvar module=$get_module(this).module\nvar co_name=this.name\nif(co_name.startsWith(\"lambda_\"+$B.lambda_magic)){co_name='<lambda>'}\njs+=h1+'co_filename:$locals_'+module.replace(/\\./g,'_')+\n'[\"__file__\"] || \"<string>\"'+\nh1+'co_firstlineno:'+node.line_num+\nh1+'co_flags:'+flags+\nh1+'co_freevars: ['+free_vars+']'+\nh1+'co_kwonlyargcount:'+this.kwonlyargcount+\nh1+'co_name: \"'+co_name+'\"'+\nh1+'co_nlocals: '+co_varnames.length+\nh1+'co_posonlyargcount: '+(this.pos_only ||0)+\nh1+'co_varnames: $B.fast_tuple(['+co_varnames.join(', ')+'])'+\nh+'}\\n'+' '.repeat(indent+4)+'};'\njs+='_b_.None;'\nnode.parent.insert(rank+offset++,$NodeJS(js))}\nthis.default_str='{'+defs1.join(', ')+'}'\nif(! this.is_comp){var name1=name\nif(this.type==\"generator\"){name1=`$B.generator.$factory(${name})`}\nvar res='return '+name1\nif(this.async){if(this.type==\"generator\"){res=`return $B.async_generator.$factory(${name})`}else{res='return $B.make_async('+name1+')'}}\nnode.parent.insert(rank+offset++,$NodeJS(res+'}'))\nnode.parent.insert(rank+offset++,$NodeJS(\nthis.func_name+\" = \"+this.name+'$'+this.num+\n'('+this.default_str+')'))\nnode.parent.insert(rank+offset++,$NodeJS(\nfunc_name1+\".$set_defaults = function(value){\\nreturn \"+\nfunc_name1+\" = \"+this.name+\"$\"+this.num+\n\"(value)}\"))\nif(this.$has_yield_in_cm){node.parent.insert(rank+offset++,$NodeJS(`${func_name1}.$has_yield_in_cm = true`))}}\nvar parent=node\nfor(var pos=0;pos < parent.children.length &&\nparent.children[pos]!==$B.last(enter_frame_nodes);pos++){}\nvar try_node=$NodeJS('try'),children=parent.children.slice(pos+1)\nparent.insert(pos+1,try_node)\nfor(var child of children){if(child.is_def_func){for(var grand_child of child.children){try_node.add(grand_child)}}else{try_node.add(child)}}\nparent.children.splice(pos+2,parent.children.length)\nvar except_node=$NodeJS('catch(err)')\nexcept_node.add($NodeJS('$B.set_exc(err)'))\nexcept_node.add($NodeJS('if((! err.$in_trace_func) && $locals.$f_trace !== _b_.None){\\n'+\n'$locals.$f_trace = $B.trace_exception()}'))\nexcept_node.add($NodeJS('$B.leave_frame({$locals});throw err'))\nparent.add(except_node)\nthis.transformed=true\nreturn offset}\n$DefCtx.prototype.to_js=function(func_name){this.js_processed=true\nif(this.is_comp){return \"var \"+this.name+\" = \"+\n(this.async ? ' async ' :'')+\n\"function* (_expr)\"}\nfunc_name=func_name ||this.tree[0].to_js()\nif(this.decorated){func_name='var '+this.alias}\nreturn \"var \"+this.name+'$'+this.num+\n' = function($defaults){\\n'+\n(this.async ? 'async ' :'')+'function'+\n(this.type=='generator' ? \"* \" :\" \")+\nthis.name+this.num+'('+this.params+')'}\nvar $DelCtx=$B.parser.$DelCtx=function(C){\nthis.type='del'\nthis.parent=C\nC.tree.push(this)\nthis.tree=[]}\n$DelCtx.prototype.ast=function(){var targets\nif(this.tree[0].type=='list_or_tuple'){\ntargets=this.tree[0].tree.map(ast_or_obj)}else if(this.tree[0].type=='expr' &&\nthis.tree[0].tree[0].type=='list_or_tuple'){\ntargets=ast_or_obj(this.tree[0].tree[0])\ntargets.ctx=new ast.Del()\nfor(var elt of targets.elts){elt.ctx=new ast.Del()}\nreturn new ast.Delete([targets])}else{targets=[ast_or_obj(this.tree[0].tree[0])]}\nfor(var target of targets){target.ctx=new ast.Del()}\nreturn new ast.Delete(targets)}\n$DelCtx.prototype.toString=function(){return 'del '+this.tree}\n$DelCtx.prototype.transition=function(token,value){var C=this\nif(token=='eol'){check_assignment(this.tree[0],{action:'delete'})\nreturn $transition(C.parent,token)}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$DelCtx.prototype.to_js=function(){this.js_processed=true\nvar C=this.parent\nif(this.tree[0].type=='list_or_tuple'){\nvar res=[]\nfor(var elt of this.tree[0].tree){var subdel=new $DelCtx(C)\nsubdel.tree=[elt]\nres.push(subdel.to_js())\nC.tree.pop()}\nthis.tree=[]\nreturn res.join(';')}else if(this.tree[0].type=='expr' &&\nthis.tree[0].tree[0].type=='list_or_tuple'){\nthis.tree[0]=this.tree[0].tree[0]\nreturn this.to_js()}else{var expr=this.tree[0].tree[0]\nswitch(expr.type){case 'id':\nvar scope=$get_scope(this),is_global=false\nif((scope.ntype==\"def\" ||scope.ntype==\"generator\")&&\nscope.globals && scope.globals.has(expr.value)){\nscope=scope.parent\nwhile(scope.parent &&\nscope.parent.id !==\"__builtins__\"){scope=scope.parent}\nis_global=true}\nvar res='$B.$delete(\"'+expr.value+'\"'+\n(is_global ? ', \"global\"' :'')+');'\ndelete scope.binding[expr.value]\nreturn res\ncase 'list_or_tuple':\nvar res=[]\nfor(var elt of expr.tree){res.push('delete '+elt.to_js())}\nreturn res.join(';')\ncase 'sub':\nexpr.func='delitem'\njs=expr.to_js()\nexpr.func='getitem'\nreturn js\ncase 'attribute':\nreturn '_b_.delattr('+expr.value.to_js()+',\"'+\nexpr.name+'\")'\ndefault:\n$_SyntaxError(this,[\"cannot delete \"+expr.type])}}}\nvar DictCompCtx=function(C){\nif(C.tree[0].type=='expr' &&\nC.tree[0].tree[0].comprehension){\nvar comp=C.tree[0].tree[0]\ncomp.parent_block=this}\nthis.type='dictcomp'\nthis.comprehension=true\nthis.parent=C.parent\nthis.key=C.tree[0]\nthis.value=C.tree[1]\nthis.key.parent=this\nthis.value.parent=this\nthis.tree=[]\nthis.binding={}\nthis.id='dictcomp'+$B.UUID()\nthis.parent_block=$get_scope(C)\nthis.module=$get_module(C).module\nC.parent.tree[C.parent.tree.length-1]=this\nthis.type='dictcomp'\nComprehension.make_comp(this,C)}\nDictCompCtx.prototype.ast=function(){\nreturn new ast.DictComp(\nast_or_obj(this.key),ast_or_obj(this.value),Comprehension.generators(this.tree)\n)}\nDictCompCtx.prototype.transition=function(token,value){var C=this\nif(token=='}'){this.has_await=Comprehension.has_await(this)\nreturn this.parent}\n$_SyntaxError(C,'token '+token+'after list comp')}\nDictCompCtx.prototype.to_js=function(){var node=$get_node(this),indent=node.get_indent()\nvar id=this.id,first_for=this.tree[0],outmost_expr=first_for.tree[1].to_js()\nfirst_for.comp_body=true\nfirst_for.iterable_is_outermost=true\nvar module_id=this.module.replace(/\\./g,'_')\nvar js=`(${this.has_await ? 'async ' : ''}function(expr){`+\nComprehension.admin_infos(this)+\n`\\nvar $result_${id} = $B.empty_dict()\\n`\njs+=first_for.to_js(indent)\nvar nb=-1\nfor(var i=1;i < this.tree.length;i++){nb++\nvar stmt=this.tree[i]\nif(stmt.type=='for'){stmt.comp_body=true\njs+='\\n'+stmt.to_js(indent+nb)}else if(stmt.type=='condition' && stmt.token=='if'){js+='\\n'+' '.repeat(12+4*nb)+stmt.to_js()+'{'}}\nvar expr_has_await=Comprehension.has_await(this.value)\njs+='\\n'+' '.repeat(16+4*nb)+\n(expr_has_await ? 'var save_stack = $B.save_stack();\\n' :'')+\n`try{\\n  _b_.dict.$setitem($result_${id}, ${this.key.to_js()}, `+\n`${this.value.to_js()})\\n}catch(err){\\n`+\n(expr_has_await ? '$B.restore_stack(save_stack, $locals);' :'')+\n`$B.leave_frame($locals)\\n`+\n`  throw err\\n}`+\n(expr_has_await ? '$B.restore_stack(save_stack, $locals);' :'')\nfor(var i=0;i < this.tree.length;i++){js+='\\n'+' '.repeat(12+4*nb--)+'}'}\njs+=`\\n$B.leave_frame({$locals, value: _b_.None})`\njs+=`\\nreturn $result_${id}`\njs+=`\\n}\\n)(${outmost_expr})`\nreturn js}\nvar $DictOrSetCtx=$B.parser.$DictOrSetCtx=function(C){\nthis.type='dict_or_set'\nthis.real='dict_or_set'\nthis.expect='id'\nthis.closed=false\nthis.start=$pos\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this}\n$DictOrSetCtx.prototype.ast=function(){\nif(this.real=='dict'){var keys=[],values=[]\nfor(var i=0,len=this.items.length;i < len;i++){if(this.items[i].packed){keys.push(_b_.None)\nvalues.push(ast_or_obj(this.items[i]))}else{keys.push(ast_or_obj(this.items[i]))\nvalues.push(ast_or_obj(this.items[i+1]))\ni++}}\nreturn new ast.Dict(keys,values)}else if(this.real=='set'){return new ast.Set(this.items.map(ast_or_obj))}\nreturn this}\n$DictOrSetCtx.prototype.toString=function(){switch(this.real){case 'dict':\nreturn '(dict) {'+this.items+'}'\ncase 'set':\nreturn '(set) {'+this.tree+'}'}\nreturn '(dict_or_set) {'+this.tree+'}'}\n$DictOrSetCtx.prototype.transition=function(token,value){var C=this\nif(C.closed){switch(token){case '[':\nreturn new $AbstractExprCtx(new $SubCtx(C.parent),false)\ncase '(':\nreturn new $CallArgCtx(new $CallCtx(C.parent))}\nreturn $transition(C.parent,token,value)}else{if(C.expect==','){switch(token){case '}':\nswitch(C.real){case 'dict_or_set':\nif(C.tree.length !=1){break}\nC.real='set' \ncase 'set':\nC.items=C.tree\nC.tree=[]\nC.closed=true\nreturn C\ncase 'dict':\nif($B.last(this.tree).type=='abstract_expr'){$_SyntaxError(C,[\"expression expected after dictionary key and ':'\"])}else if(C.nb_dict_items()% 2 !=0){$_SyntaxError(C,[\"':' expected after dictionary key\"])}\nC.items=C.tree\nC.tree=[]\nC.closed=true\nreturn C}\n$_SyntaxError(C,'token '+token+\n' after '+C)\ncase ',':\nif(C.real=='dict_or_set'){C.real='set'}\nif(C.real=='dict' &&\nC.nb_dict_items()% 2){$_SyntaxError(C,[\"':' expected after dictionary key\"])}\nC.expect='id'\nreturn C\ncase ':':\nif(C.real=='dict_or_set'){C.real='dict'}\nif(C.real=='dict'){C.expect='value'\nC.value_pos=$pos\nreturn C}else{$_SyntaxError(C,'token '+token+\n' after '+C)}\ncase 'for':\nif(C.real==\"set\" && C.tree.length > 1){C.$pos=C.tree[0].$pos\n$_SyntaxError(C,[\"did you forget \"+\n\"parentheses around the comprehension target?\"])}\nif(C.real=='dict_or_set'){return new $TargetListCtx(new $ForExpr(\nnew SetCompCtx(this)))}else{return new $TargetListCtx(new $ForExpr(\nnew DictCompCtx(this)))}}\n$_SyntaxError(C,'token '+token+' after '+C)}else if(C.expect=='id'){switch(token){case '}':\nif(C.tree.length==0){\nC.items=[]\nC.real='dict'}else{\nC.items=C.tree}\nC.tree=[]\nC.closed=true\nreturn C\ncase 'id':\ncase 'imaginary':\ncase 'int':\ncase 'float':\ncase 'str':\ncase 'JoinedStr':\ncase 'bytes':\ncase '[':\ncase '(':\ncase '{':\ncase '.':\ncase 'not':\ncase 'lambda':\nC.expect=','\nvar expr=new $AbstractExprCtx(C,false)\nreturn $transition(expr,token,value)\ncase 'op':\nswitch(value){case '*':\ncase '**':\nC.expect=\",\"\nvar expr=new $AbstractExprCtx(C,false)\nexpr.packed=value.length \nif(C.real==\"dict_or_set\"){C.real=value==\"*\" ? \"set\" :\n\"dict\"}else if(\n(C.real==\"set\" && value==\"**\")||\n(C.real==\"dict\" && value==\"*\")){$_SyntaxError(C,'token '+token+\n' after '+C)}\nreturn expr\ncase '+':\nreturn C\ncase '-':\ncase '~':\nC.expect=','\nvar left=new $UnaryCtx(C,value)\nif(value=='-'){var op_expr=new $OpCtx(left,'unary_neg')}else if(value=='+'){var op_expr=new $OpCtx(left,'unary_pos')}else{var op_expr=new $OpCtx(left,'unary_inv')}\nreturn new $AbstractExprCtx(op_expr,false)}\n$_SyntaxError(C,'token '+token+\n' after '+C)}\n$_SyntaxError(C,'token '+token+' after '+C)}else if(C.expect=='value'){try{C.expect=','\nreturn $transition(new $AbstractExprCtx(C,false),token,value)}catch(err){C.$pos=C.value_pos\n$_SyntaxError(C,[\"expression expected after \"+\n\"dictionary key and ':'\"])}}\nreturn $transition(C.parent,token,value)}}\n$DictOrSetCtx.prototype.nb_dict_items=function(){var nb=0\nfor(var item of this.tree){if(item.packed){nb+=2}else{nb++}}\nreturn nb}\n$DictOrSetCtx.prototype.packed_indices=function(){var ixs=[]\nthis.items.forEach(function(t,i){if(t.type==\"expr\" && t.packed){ixs.push(i)}})\nreturn ixs}\n$DictOrSetCtx.prototype.unpack_dict=function(packed){var js=\"\",res,first,i=0,item,elts=[]\nwhile(i < this.items.length){item=this.items[i]\nfirst=i==0\nif(item.type==\"expr\" && item.packed){res=\"_b_.list.$factory(_b_.dict.items(\"+item.to_js()+\"))\"\ni++}else{if(this.items[i+1]===undefined){console.log('stack',$B.frames_stack.slice(),'this.items',this.items,'i',i)}\nres=\"[[\"+item.to_js()+\",\"+\nthis.items[i+1].to_js()+\"]]\"\ni+=2}\nif(! first){res=\".concat(\"+res+\")\"}\njs+=res}\nreturn js}\n$DictOrSetCtx.prototype.unpack_set=function(packed){var js=\"\",res\nthis.items.forEach(function(t,i){if(packed.indexOf(i)>-1){res=\"_b_.list.$factory(\"+t.to_js()+\")\"}else{res=\"[\"+t.to_js()+\"]\"}\nif(i > 0){res=\".concat(\"+res+\")\"}\njs+=res})\nreturn js}\n$DictOrSetCtx.prototype.to_js=function(){this.js_processed=true\nvar packed=this.packed_indices()\nif(this.real=='dict'){if(packed.length > 0){return '_b_.dict.$factory('+this.unpack_dict(packed)+\n')'+$to_js(this.tree)}\nvar res=[]\nfor(var i=0;i < this.items.length;i+=2){res.push('['+this.items[i].to_js()+','+\nthis.items[i+1].to_js()+']')}\nreturn '_b_.dict.$factory(['+res.join(',')+'])'+\n$to_js(this.tree)}else if(packed.length > 0){return '_b_.set.$factory('+this.unpack_set(packed)+')'}\nreturn '_b_.set.$factory(['+$to_js(this.items)+'])'+$to_js(this.tree)}\nvar $DoubleStarArgCtx=$B.parser.$DoubleStarArgCtx=function(C){\nthis.type='double_star_arg'\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this}\n$DoubleStarArgCtx.prototype.toString=function(){return '**'+this.tree}\n$DoubleStarArgCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\ncase 'imaginary':\ncase 'int':\ncase 'float':\ncase 'str':\ncase 'JoinedStr':\ncase 'bytes':\ncase '[':\ncase '(':\ncase '{':\ncase '.':\ncase 'not':\ncase 'lambda':\nreturn $transition(new $AbstractExprCtx(C,false),token,value)\ncase ',':\ncase ')':\nreturn $transition(C.parent,token)\ncase ':':\nif(C.parent.parent.type=='lambda'){return $transition(C.parent.parent,token)}}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$DoubleStarArgCtx.prototype.to_js=function(){this.js_processed=true\nreturn '{$nat:\"pdict\",arg:'+$to_js(this.tree)+'}'}\nvar $EllipsisCtx=$B.parser.$EllipsisCtx=function(C){\nthis.type='ellipsis'\nthis.parent=C\nthis.start=$pos\nC.tree[C.tree.length]=this}\n$EllipsisCtx.prototype.ast=function(){return new ast.Constant({type:'ellipsis'})}\n$EllipsisCtx.prototype.toString=function(){return 'ellipsis'}\n$EllipsisCtx.prototype.transition=function(token,value){var C=this\nreturn $transition(C.parent,token,value)}\n$EllipsisCtx.prototype.to_js=function(){this.js_processed=true\nreturn '$B.builtins[\"Ellipsis\"]'}\nvar $EndOfPositionalCtx=$B.parser.$EndOfConditionalCtx=function(C){\nthis.type=\"end_positional\"\nthis.parent=C\nC.has_end_positional=true\nC.parent.pos_only=C.tree.length\nC.tree.push(this)}\n$EndOfPositionalCtx.prototype.transition=function(token,value){var C=this\nif(token==\",\" ||token==\")\"){return $transition(C.parent,token,value)}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$EndOfPositionalCtx.prototype.to_js=function(){return \"/\"}\nvar $ExceptCtx=$B.parser.$ExceptCtx=function(C){\nthis.type='except'\nthis.parent=C\nC.tree[C.tree.length]=this\nthis.tree=[]\nthis.expect='id'\nthis.scope=$get_scope(this)}\n$ExceptCtx.prototype.ast=function(){\nreturn new ast.ExceptHandler(\nthis.tree.length==1 ? ast_or_obj(this.tree[0]):undefined,this.has_alias ? this.tree[0].alias :undefined,ast_body(this.parent)\n)}\n$ExceptCtx.prototype.toString=function(){return '(except) '}\n$ExceptCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\ncase 'imaginary':\ncase 'int':\ncase 'float':\ncase 'str':\ncase 'JoinedStr':\ncase 'bytes':\ncase '[':\ncase '(':\ncase '{':\ncase 'not':\ncase 'lambda':\nif(C.expect=='id'){C.expect='as'\nreturn $transition(new $AbstractExprCtx(C,false),token,value)}\ncase 'as':\nif(C.expect=='as' &&\nC.has_alias===undefined){C.expect='alias'\nC.has_alias=true\nreturn C}\ncase 'id':\nif(C.expect=='alias'){C.expect=':'\nC.set_alias(value)\nreturn C}\nbreak\ncase ':':\nvar _ce=C.expect\nif(_ce=='id' ||_ce=='as' ||_ce==':'){return $BodyCtx(C)}\nbreak\ncase '(':\nif(C.expect=='id' && C.tree.length==0){C.parenth=true\nreturn C}\nbreak\ncase ')':\nif(C.expect==',' ||C.expect=='as'){C.expect='as'\nreturn C}\ncase ',':\nif(C.parenth !==undefined &&\nC.has_alias===undefined &&\n(C.expect=='as' ||C.expect==',')){C.expect='id'\nreturn C}else if(C.parenth===undefined){$_SyntaxError(C,[\"multiple exception types must be parenthesized\"])}}\nconsole.log('error',C,token)\n$_SyntaxError(C,'token '+token+' after '+C.expect)}\n$ExceptCtx.prototype.set_alias=function(alias){this.tree[0].alias=$mangle(alias,this)\n$bind(alias,this.scope,this)}\n$ExceptCtx.prototype.transform=function(node,rank){\nvar linenum_node=$NodeJS(\"void(0)\")\nlinenum_node.line_num=node.line_num\nnode.insert(0,linenum_node)\nvar last_child=$B.last(node.children)\nif(last_child.C.tree && last_child.C.tree[0]&&\nlast_child.C.tree[0].type==\"return\"){}\nelse{node.add($NodeJS(\"$B.del_exc()\"))}}\n$ExceptCtx.prototype.to_js=function(){\nthis.js_processed=true\nswitch(this.tree.length){case 0:\nreturn 'else'\ncase 1:\nif(this.tree[0].name=='Exception'){return 'else if(1)'}}\nvar res=[]\nfor(var elt of this.tree){res.push(elt.to_js())}\nvar lnum=''\nif($B.debug > 0){var module=$get_module(this)\nlnum='($locals.$line_info = \"'+$get_node(this).line_num+\n','+module.id+'\") && '}\nreturn 'else if('+lnum+'$B.is_exc('+this.error_name+\n',['+res.join(',')+']))'}\nvar $ExprCtx=$B.parser.$ExprCtx=function(C,name,with_commas){\nthis.type='expr'\nthis.name=name\nthis.$pos=$pos\nthis.with_commas=with_commas\nthis.expect=',' \nthis.parent=C\nif(C.packed){this.packed=C.packed}\nthis.tree=[]\nC.tree[C.tree.length]=this}\n$ExprCtx.prototype.ast=function(){var res=ast_or_obj(this.tree[0])\nif(this.packed){}else if(this.annotation){res=new ast.AnnAssign(\nres,ast_or_obj(this.annotation.tree[0]),undefined,1)\nreturn res}\nreturn res}\n$ExprCtx.prototype.toString=function(){return '(expr '+this.with_commas+') '+this.tree}\n$ExprCtx.prototype.transition=function(token,value){var C=this\nif(python_keywords.indexOf(token)>-1 &&\n['as','else','if','for','from','in'].indexOf(token)==-1){C.$pos=$pos\n$_SyntaxError(C,`'${token}' after expression`)}\nswitch(token){case 'bytes':\ncase 'float':\ncase 'id':\ncase 'imaginary':\ncase 'int':\ncase 'lambda':\ncase 'pass':\ncase 'str':\ncase 'JoinedStr':\nif(C.parent.type=='dict_or_set' &&\nC.parent.expect==','){$_SyntaxError(C,[\"invalid syntax. Perhaps you forgot a comma?\"])}\n$_SyntaxError(C,'token '+token+' after '+\nC)\nbreak\ncase '{':\nif(C.tree[0].type !=\"id\" ||\n[\"print\",\"exec\"].indexOf(C.tree[0].value)==-1){$_SyntaxError(C,'token '+token+' after '+\nC)}\nreturn new $DictOrSetCtx(C)\ncase '[':\ncase '(':\ncase '.':\ncase 'not':\nif(C.expect=='expr'){C.expect=','\nreturn $transition(new $AbstractExprCtx(C,false),token,value)}}\nswitch(token){case 'not':\nif(C.expect==','){return new $ExprNot(C)}\nbreak\ncase 'in':\nif(C.parent.type=='target_list'){\nreturn $transition(C.parent,token)}\nif(C.expect==','){return $transition(C,'op','in')}\ncase ',':\nif(C.expect==','){if(C.with_commas ||\n[\"assign\",\"return\"].indexOf(C.parent.type)>-1){if($parent_match(C,{type:\"yield\",\"from\":true})){$_SyntaxError(C,\"no implicit tuple for yield from\")}\nC.parent.tree.pop()\nvar tuple=new $ListOrTupleCtx(C.parent,'tuple')\ntuple.implicit=true\ntuple.has_comma=true\ntuple.tree=[C]\nC.parent=tuple\nreturn tuple}}\nreturn $transition(C.parent,token)\ncase '.':\nreturn new $AttrCtx(C)\ncase '[':\nreturn new $AbstractExprCtx(new $SubCtx(C),true)\ncase '(':\nreturn new $CallCtx(C)\ncase 'op':\nvar op_parent=C.parent,op=value\nif(op_parent.type=='ternary' && op_parent.in_else){var new_op=new $OpCtx(C,op)\nreturn new $AbstractExprCtx(new_op,false)}\nvar op1=C.parent,repl=null\nwhile(1){if(op1.type=='unary' && op !=='**'){repl=op1\nop1=op1.parent}else if(op1.type=='expr'){op1=op1.parent}else if(op1.type=='op' &&\n$op_weight[op1.op]>=$op_weight[op]&&\n!(op1.op=='**' && op=='**')){\nrepl=op1\nop1=op1.parent}else if(op1.type==\"not\" &&\n$op_weight['not']> $op_weight[op]){repl=op1\nop1=op1.parent}else{break}}\nif(repl===null){if(op1.type=='op'){\nvar right=op1.tree.pop(),expr=new $ExprCtx(op1,'operand',C.with_commas)\nexpr.tree.push(right)\nright.parent=expr\nvar new_op=new $OpCtx(expr,op)\nreturn new $AbstractExprCtx(new_op,false)}\nwhile(C.parent !==op1){C=C.parent\nop_parent=C.parent}\nC.parent.tree.pop()\nvar expr=new $ExprCtx(op_parent,'operand',C.with_commas)\nexpr.expect=','\nC.parent=expr\nvar new_op=new $OpCtx(C,op)\nreturn new $AbstractExprCtx(new_op,false)}else{\nif(op==='and' ||op==='or'){while(repl.parent.type=='not' ||\n(repl.parent.type=='expr' &&\nrepl.parent.parent.type=='not')){\nrepl=repl.parent\nop_parent=repl.parent}}}\nif(repl.type=='op'){var _flag=false\nswitch(repl.op){case '<':\ncase '<=':\ncase '==':\ncase '!=':\ncase 'is':\ncase '>=':\ncase '>':\n_flag=true}\nif(_flag){switch(op){case '<':\ncase '<=':\ncase '==':\ncase '!=':\ncase 'is':\ncase '>=':\ncase '>':\ncase 'in':\ncase 'not_in':\nrepl.ops=repl.ops ||[repl.op]\nrepl.ops.push(op)\nreturn new $AbstractExprCtx(repl,false)}}}\nrepl.parent.tree.pop()\nvar expr=new $ExprCtx(repl.parent,'operand',false)\nexpr.tree=[op1]\nrepl.parent=expr\nvar new_op=new $OpCtx(repl,op)\nreturn new $AbstractExprCtx(new_op,false)\ncase 'augm_assign':\nvar parent=C\nwhile(parent){if(parent.type==\"assign\" ||parent.type==\"augm_assign\"){$_SyntaxError(C,\"augmented assignment inside assignment\")}else if(parent.type==\"op\"){$_SyntaxError(C,[\"cannot assign to operator\"])}else if(parent.type==\"list_or_tuple\"){$_SyntaxError(C,[`'${parent.real}' is an illegal`+\n\" expression for augmented assignment\"])}else if(['list','tuple'].indexOf(parent.name)>-1){$_SyntaxError(C,[`'${parent.name}' is an illegal`+\n\" expression for augmented assignment\"])}else if(['dict_or_set'].indexOf(parent.name)>-1){$_SyntaxError(C,[`'${parent.tree[0].real } display'`+\n\" is an illegal expression for augmented assignment\"])}\nparent=parent.parent}\nif(C.expect==','){return new $AbstractExprCtx(\nnew $AugmentedAssignCtx(C,value),true)}\nreturn $transition(C.parent,token,value)\ncase \":\":\nif(C.parent.type==\"sub\" ||\n(C.parent.type==\"list_or_tuple\" &&\nC.parent.parent.type==\"sub\")){return new $AbstractExprCtx(new $SliceCtx(C.parent),false)}else if(C.parent.type==\"slice\"){return $transition(C.parent,token,value)}else if(C.parent.type==\"node\"){\nif(C.tree.length==1){var child=C.tree[0]\ncheck_assignment(child)\nif([\"id\",\"sub\",\"attribute\"].indexOf(child.type)>-1){return new $AbstractExprCtx(new $AnnotationCtx(C),false)}else if(child.real==\"tuple\" && child.expect==\",\" &&\nchild.tree.length==1){return new $AbstractExprCtx(new $AnnotationCtx(child.tree[0]),false)}}\n$_SyntaxError(C,\"invalid target for annotation\")}\nbreak\ncase '=':\nfunction has_parent(ctx,type){\nwhile(ctx.parent){if(ctx.parent.type==type){return ctx.parent}\nctx=ctx.parent}\nreturn false}\nvar annotation\nif(C.expect==','){if(C.parent.type==\"call_arg\"){\nif(C.tree[0].type !=\"id\"){$_SyntaxError(C,['expression cannot contain'+\n' assignment, perhaps you meant \"==\"?'])}\nreturn new $AbstractExprCtx(new $KwArgCtx(C),true)}else if(annotation=has_parent(C,\"annotation\")){return $transition(annotation,token,value)}else if(C.parent.type==\"op\"){\n$_SyntaxError(C,[\"cannot assign to operator\"])}else if(C.parent.type==\"not\"){\n$_SyntaxError(C,[\"cannot assign to operator\"])}else if(C.parent.type==\"with\"){$_SyntaxError(C,[\"expected :\"])}else if(C.parent.type==\"list_or_tuple\"){\nfor(var i=0;i < C.parent.tree.length;i++){var item=C.parent.tree[i]\nif(item.type==\"expr\" && item.name==\"operand\"){$_SyntaxError(C,[\"cannot assign to operator\"])}}}else if(C.parent.type==\"expr\" &&\nC.parent.name==\"iterator\"){$_SyntaxError(C,['expected :'])}else if(C.parent.type==\"lambda\"){if(C.parent.parent.parent.type !=\"node\"){$_SyntaxError(C,['expression cannot contain'+\n' assignment, perhaps you meant \"==\"?'])}}else if(C.parent.type=='target_list'){$_SyntaxError(C,\"assign to target in iteration\")}\nwhile(C.parent !==undefined){C=C.parent\nif(C.type==\"condition\"){$_SyntaxError(C,[\"invalid syntax. Maybe you\"+\n\" meant '==' or ':=' instead of '='?\"])}else if(C.type==\"augm_assign\"){$_SyntaxError(C,\"assignment inside augmented assignment\")}}\nC=C.tree[0]\nreturn new $AbstractExprCtx(new $AssignCtx(C),true)}\nbreak\ncase ':=':\nvar ptype=C.parent.type\nif([\"node\",\"assign\",\"kwarg\",\"annotation\"].\nindexOf(ptype)>-1){$_SyntaxError(C,':= invalid, parent '+ptype)}else if(ptype==\"func_arg_id\" &&\nC.parent.tree.length > 0){\n$_SyntaxError(C,':= invalid, parent '+ptype)}else if(ptype==\"call_arg\" &&\nC.parent.parent.type==\"call\" &&\nC.parent.parent.parent.type==\"lambda\"){\n$_SyntaxError(C,':= invalid inside function arguments' )}\nif(C.tree.length==1 && C.tree[0].type==\"id\"){var scope=$get_scope(C),name=C.tree[0].value\nif(['None','True','False'].indexOf(name)>-1){$_SyntaxError(C,[`cannot use assignment expressions with ${name}`])}else if(name=='__debug__'){$_SyntaxError(C,['cannot assign to __debug__'])}\nwhile(scope.comprehension){scope=scope.parent_block}\nC.tree[0].binding_scope=$bind(name,scope,C)\nreturn new $AbstractExprCtx(new NamedExprCtx(C),false)}\n$_SyntaxError(C,'token '+token+' after '+C)\ncase 'if':\nvar in_comp=false,ctx=C.parent\nwhile(ctx){if(ctx.comprehension){in_comp=true\nbreak}else if(ctx.type==\"list_or_tuple\"){\nbreak}else if(ctx.type=='comp_for'){break}else if(ctx.type=='comp_if'){\nin_comp=true\nbreak}else if(ctx.type=='call_arg' ||ctx.type=='sub'){\nbreak}else if(ctx.type=='expr'){if(ctx.parent.type=='comp_iterable'){\nin_comp=true\nbreak}}\nctx=ctx.parent}\nif(in_comp){break}\nvar ctx=C\nwhile(ctx.parent &&\n(ctx.parent.type=='op' ||\nctx.parent.type=='not' ||\nctx.parent.type=='unary' ||\n(ctx.parent.type==\"expr\" && ctx.parent.name==\"operand\"))){ctx=ctx.parent}\nreturn new $AbstractExprCtx(new $TernaryCtx(ctx),true)\ncase 'eol':\nif(C.tree.length==2 &&\nC.tree[0].type==\"id\" &&\n[\"print\",\"exec\"].indexOf(C.tree[0].value)>-1){$_SyntaxError(C,[\"Missing parentheses in call \"+\n\"to '\"+C.tree[0].value+\"'.\"])}\nif([\"dict_or_set\",\"list_or_tuple\",\"str\"].indexOf(C.parent.type)==-1){var t=C.tree[0]\nif(t.type==\"packed\"){$pos=t.pos\n$_SyntaxError(C,[\"can't use starred expression here\"])}else if(t.type==\"call\" && t.func.type==\"packed\"){$pos=t.func.pos\n$_SyntaxError(C,[\"can't use starred expression here\"])}}}\nreturn $transition(C.parent,token)}\n$ExprCtx.prototype.to_js=function(arg){var res\nthis.js_processed=true\nif(this.type=='list'){res='['+$to_js(this.tree)+']'}else if(this.tree.length==1){if(this.tree[0].to_js===undefined){console.log('pas de to_js',this)}\nres=this.tree[0].to_js(arg)}else{res='_b_.tuple.$factory(['+$to_js(this.tree)+'])'}\nif(this.is_await){res=\"await ($B.promise(\"+res+\"))\"}\nif(this.name==\"call\"){\nres+='()'}\nreturn res}\nvar $ExprNot=$B.parser.$ExprNot=function(C){\nthis.type='expr_not'\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this}\n$ExprNot.prototype.transition=function(token,value){var C=this\nif(token=='in'){\nC.parent.tree.pop()\nvar op1=C.parent\nwhile(op1.type !=='expr'){op1=op1.parent}\nreturn op1.transition('op','not_in')}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$ExprNot.prototype.toString=function(){return '(expr_not)'}\nvar $ForExpr=$B.parser.$ForExpr=function(C){\nif(C.node && C.node.parent.is_comp){\nC.node.parent.first_for=this}\nthis.type='for'\nthis.parent=C\nthis.tree=[]\nC.tree.push(this)\nthis.loop_num=$loop_num\nthis.scope=$get_scope(this)\nif(this.scope.is_comp){}\nthis.module=this.scope.module\n$loop_num++}\n$ForExpr.prototype.ast=function(){\nvar target=ast_or_obj(this.tree[0]),iter=ast_or_obj(this.tree[1]),orelse=this.orelse ? ast_or_obj(this.orelse):[],type_comment,body=ast_body(this.parent)\nreturn new ast.For(target,iter,body,orelse,type_comment)}\n$ForExpr.prototype.toString=function(){return '(for) '+this.tree}\n$ForExpr.prototype.transition=function(token,value){var C=this\nswitch(token){case 'in':\nvar targets=C.tree[0].tree\nfor(var target_expr of C.tree[0].tree){check_assignment(target_expr.tree[0])\nif(target_expr.tree[0].type=='id'){var id=target_expr.tree[0]\n$bind(id.value,this.scope,id)}}\nif(C.tree[0].tree.length==0){\n$_SyntaxError(C,\"missing target between 'for' and 'in'\")}\nreturn new $AbstractExprCtx(\nnew $ExprCtx(C,'iterator',true),false)\ncase ':':\nif(C.tree.length < 2 \n||C.tree[1].tree[0].type==\"abstract_expr\"){$_SyntaxError(C,'token '+token+' after '+\nC)}\nreturn $BodyCtx(C)}\nif(this.parent.comprehension){switch(token){case ']':\nif(this.parent.type=='listcomp'){return $transition(this.parent,token,value)}\nbreak\ncase ')':\nif(this.parent.type=='genexpr'){return $transition(this.parent,token,value)}\nbreak\ncase '}':\nif(this.parent.type=='dictcomp' ||\nthis.parent.type=='setcomp'){return $transition(this.parent,token,value)}\nbreak\ncase 'for':\nreturn new $TargetListCtx(new $ForExpr(this.parent))\ncase 'if':\nvar if_ctx=new $ConditionCtx(this.parent,'if')\nif_ctx.in_comp=true\nreturn new $AbstractExprCtx(if_ctx,false)}}\n$_SyntaxError(C,'token '+token+' after '+C)}\nfunction tg_to_js(target,iterable,unpack){\nif(target.type=='simple'){var item=target.item\nvar assign,assign_to=unpack\n? target.starred\n? `${iterable}.read_rest()`\n:`${iterable}.read_one()`\n:target.starred\n? `$B.read_rest(${iterable})`\n:iterable\nswitch(item.type){case 'id':\nassign=`${item.to_js()} = ${assign_to}`\nbreak\ncase 'sub':\nassign='$B.$setitem('+item.value.to_js()+\n', '+item.tree[0].to_js()+', '+assign_to+')'\nbreak\ncase 'attribute':\nassign='$B.$setattr('+item.value.to_js()+\n', \"'+item.name+'\", '+assign_to+')'\nbreak\ncase 'packed':\nassign=item.tree[0].to_js()+\n(unpacked ? ' = $next_${id}.read_rest()' :\n' = $B.rest_iter($next_${id})')\nbreak\ndefault:\nconsole.log('-- unexpected target type',item.type,item)\nbreak}\nif(assign){return assign+'\\n'}}else{var new_id=$B.UUID(),nb_targets=target.items.length,has_starred=!! $B.last(target.items).starred\nvar nxt=unpack ? `${iterable}.read_one()` :iterable\nvar js=`try{\\n var $next_${new_id} = $B.unpacker(${nxt}, `+\n`${nb_targets}, ${has_starred})\\n}`+\n`catch(err){\\n console.log(\"erreur\");$B.leave_frame($locals); throw err\\n}\\n`\nfor(var item of target.items){js+=tg_to_js(item,`$next_${new_id}`,true)}}\nreturn js+'\\n'}\nfunction make_target(target){\nif(target.type=='expr'){return make_target(target.tree[0])}else if(target.tree===undefined ||target.tree.length==0){var res={type:'simple',item:target}}else if(target.tree.length > 1 ||target.implicit_tuple){var res={type:'tuple',items:target.tree.map(make_target)}}else if(target.tree[0].type=='list_or_tuple'){var res={type:'tuple',items:target.tree[0].tree.map(make_target)}}else{var item=target.tree[0]\nif(item.type=='expr'){item=item.tree[0]}\nvar res={type:'simple',item}\nif(target.packed){res=make_target(target.tree[0])\nres.starred=true}else if(target.tree[0].type=='packed'){res=make_target(target.tree[0].tree[0])\nres.starred=true}}\nreturn res}\n$ForExpr.prototype.to_js=function(indent){this.js_processed=true\nvar node=$get_node(this),indent=indent ||node.get_indent(),targets=this.tree[0].tree,iterable=this.tree[1],id=$B.UUID()\nif(node.module===undefined){var module_id=$get_module(this).module}else{var module_id=node.module}\nmodule_id=module_id.replace(/\\./g,'_')\nvar target=make_target(this.tree[0])\nvar assignment=tg_to_js(target,`$next_${id}`)\nvar it=this.iterable_is_outermost ? 'expr' :iterable.to_js(),iteration=this.comp_body ? '' :\n`var $no_break${this.loop_num} = true\\n`\nif(this.async){iteration+=`var $iter_${id} = ${it}\\n`+\n`var $type_${id} = _b_.type.$factory($iter_${id})\\n`+\n`$iter_${id} = $B.$call($B.$getattr($type_${id}, \"__aiter__\"))($iter_${id})\\n`+\n`var $next_func_${id} = $B.$call(`+\n`$B.$getattr($type_${id}, '__anext__'))\\n`+\n`while(true){\\n`+\n`  try{\\n`+\n`    var $next_${id} = await $B.promise($next_func_${id}($iter_${id}))\\n`+\n`  }catch(err){\\n`+\n`    if($B.is_exc(err, [_b_.StopAsyncIteration])){\\nbreak}\\n`+\n`    else{\\n$B.leave_frame({$locals, value: _b_.None});throw err}\\n`+\n`  }\\n`}else{iteration+=`var $next_func_${id} = $B.next_of(${it})\\n`+\n`while(true){\\n`+\n`  try{\\n`+\n`    var $next_${id} = $next_func_${id}()\\n`+\n`  }catch(err){\\n`+\n`    if($B.is_exc(err, [_b_.StopIteration])){\\nbreak}\\n`+\n`    else{\\n$B.leave_frame({$locals, value: _b_.None});throw err}\\n`+\n`  }\\n`}\nvar body=''\nif(! this.comp_body){\nfor(var child of node.children){body+='\\n'+child.to_js()}\nbody+=`;$locals.$line_info = \"${node.line_num},${module_id}\";`+\n'if($locals.$f_trace !== _b_.None){$B.trace_line()};_b_.None;'\nbody+='\\n}\\n'\nnode.children=[]}\nreturn(iteration+assignment+body).split('\\n').\nmap(x=> '    '.repeat(indent)+x).join('\\n')}\nvar $FromCtx=$B.parser.$FromCtx=function(C){\nthis.type='from'\nthis.parent=C\nthis.module=''\nthis.names=[]\nC.tree[C.tree.length]=this\nthis.expect='module'\nthis.scope=$get_scope(this)}\n$FromCtx.prototype.ast=function(){\nvar module=this.module,level=0\nwhile(module.length > 0 && module.startsWith('.')){level++\nmodule=module.substr(1)}\nvar res={module:module ||undefined,names:[],level}\nfor(var name of this.names){if(Array.isArray(name)){res.names.push(new ast.alias(name[0],name[1]))}else{res.names.push(new ast.alias(name))}}\nreturn new ast.ImportFrom(res.module,res.names,res.level)}\n$FromCtx.prototype.add_name=function(name){this.names[this.names.length]=name\nif(name=='*'){this.scope.blurred=true}}\n$FromCtx.prototype.bind_names=function(){\nvar scope=$get_scope(this)\nfor(var name of this.names){if(Array.isArray(name)){name=name[1]}\n$bind(name,scope,this)}}\n$FromCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\nif(C.expect=='id'){C.add_name(value)\nC.expect=','\nreturn C}\nif(C.expect=='alias'){C.names[C.names.length-1]=\n[$B.last(C.names),value]\nC.expect=','\nreturn C}\ncase '.':\nif(C.expect=='module'){if(token=='id'){C.module+=value}\nelse{C.module+='.'}\nreturn C}\ncase 'import':\nif(C.names.length > 0){\n$_SyntaxError(C,[\"only one 'import' allowed after 'from'\"])}\nif(C.expect=='module'){C.expect='id'\nreturn C}\ncase 'op':\nif(value=='*' && C.expect=='id'\n&& C.names.length==0){if($get_scope(C).ntype !=='module'){$_SyntaxError(C,[\"import * only allowed at module level\"])}\nC.add_name('*')\nC.expect='eol'\nreturn C}\ncase ',':\nif(C.expect==','){C.expect='id'\nreturn C}\ncase 'eol':\nswitch(C.expect){case ',':\ncase 'eol':\nC.bind_names()\nreturn $transition(C.parent,token)\ncase 'id':\n$_SyntaxError(C,['trailing comma not allowed without '+\n'surrounding parentheses'])\ndefault:\n$_SyntaxError(C,['invalid syntax'])}\ncase 'as':\nif(C.expect==',' ||C.expect=='eol'){C.expect='alias'\nreturn C}\ncase '(':\nif(C.expect=='id'){C.expect='id'\nreturn C}\ncase ')':\nif(C.expect==',' ||C.expect=='id'){C.expect='eol'\nreturn C}}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$FromCtx.prototype.toString=function(){return '(from) '+this.module+' (import) '+this.names}\n$FromCtx.prototype.to_js=function(){this.js_processed=true\nvar scope=$get_scope(this),module=$get_module(this),mod=module.module,res=[],pos=0,indent=$get_node(this).indent,head=' '.repeat(indent)\nif(mod.startsWith(\"$exec\")){var frame=$B.last($B.frames_stack)[1]\nif(frame.module && frame.module.__name__){mod=frame.module.__name__}}\nvar mod_elts=this.module.split(\".\")\nfor(var i=0;i < mod_elts.length;i++){module.imports[mod_elts.slice(0,i+1).join(\".\")]=true}\nvar _mod=this.module.replace(/\\$/g,''),$package,packages=[]\nwhile(_mod.length > 0){if(_mod.charAt(0)=='.'){if($package===undefined){if($B.imported[mod]!==undefined){$package=$B.imported[mod].__package__\npackages=$package.split('.')}}else{$package=$B.imported[$package]\npackages.pop()}\nif($package===undefined){return 'throw _b_.SystemError.$factory(\"Parent module \\'\\' '+\n'not loaded, cannot perform relative import\")'}else if($package==='None'){console.log('package is None !')}\n_mod=_mod.substr(1)}else{break}}\nif(_mod){packages.push(_mod)}\nthis.module=packages.join('.')\nvar mod_name=this.module.replace(/\\$/g,'')\nres[pos++]='var module = $B.$import(\"'\nres[pos++]=mod_name+'\",[\"'\nvar names=[]\nfor(var i=0,len=this.names.length;i < len;i++){if(Array.isArray(this.names[i])){names.push(this.names[i][0])}else{names.push(this.names[i])}}\nres[pos++]=names.join('\",\"')+'\"], {'\nvar sep=''\nfor(var attr in this.aliases){res[pos++]=sep+'\"'+attr+'\": \"'+this.aliases[attr]+'\"'\nsep=','}\nres[pos++]='}, {}, true);'\nif(this.names[0]=='*'){\nscope.blurred=true\nres[pos++]='\\n'+head+'$B.import_all($locals, module);'}else{for(var name of this.names){var alias=name\nif(Array.isArray(name)){alias=name[1]\nname=name[0]}\nmodule.imports[this.module+'.'+name]=true\nres[pos++]='\\n'+head+'$locals[\"'+\nalias+'\"] = $B.$getattr($B.imported[\"'+\nmod_name+'\"], \"'+name+'\");'}}\nres[pos++]='\\n'+head+'_b_.None;'\nreturn res.join('');}\nvar $FuncArgs=$B.parser.$FuncArgs=function(C){\nthis.type='func_args'\nthis.parent=C\nthis.tree=[]\nthis.names=[]\nC.tree[C.tree.length]=this\nthis.expect='id'\nthis.has_default=false\nthis.has_star_arg=false\nthis.has_kw_arg=false}\n$FuncArgs.prototype.ast=function(){var args={posonlyargs:[],args:[],kwonlyargs:[],kw_defaults:[],defaults:[]},state='arg',default_value\nfor(var arg of this.tree){if(arg.type=='end_positional'){args.posonlyargs=args.args\nargs.args=[]}else if(arg.type=='func_star_arg'){state='kwonly'\nif(arg.op=='*' && arg.name !='*'){args.vararg=new ast.arg(arg.name)}else if(arg.op=='**'){args.kwarg=new ast.arg(arg.name)}}else{default_value=false\nif(arg.has_default){default_value=ast_or_obj(arg.tree[0])}\nvar argument=new ast.arg(arg.name)\nif(arg.annotation){argument.annotation=ast_or_obj(arg.annotation.tree[0])}\nif(state=='kwonly'){args.kwonlyargs.push(argument)\nif(default_value){args.kw_defaults.push(default_value)}else{args.kw_defaults.push(_b_.None)}}else{args.args.push(argument)\nif(default_value){args.defaults.push(default_value)}}}}\nreturn new ast.arguments(args.posonlyargs,args.args,args.vararg,args.kwonlyargs,args.kw_defaults,args.kwarg,args.defaults)}\n$FuncArgs.prototype.toString=function(){return 'func args '+this.tree}\n$FuncArgs.prototype.transition=function(token,value){var C=this\nfunction check(){if(C.tree.length==0){return}\nvar last=$B.last(C.tree)\nif(C.has_default && ! last.has_default){if(last.type=='func_star_arg' ||\nlast.type=='end_positional'){return}\nif(C.names.indexOf('*')>-1){\nreturn}\n$_SyntaxError(C,['non-default argument follows default argument'])}\nif(last.has_default){C.has_default=true}}\nswitch(token){case 'id':\nif(C.has_kw_arg){$_SyntaxError(C,'duplicate keyword argument')}\nif(C.expect=='id'){C.expect=','\nif(C.names.indexOf(value)>-1){$_SyntaxError(C,['duplicate argument '+value+\n' in function definition'])}}\nreturn new $FuncArgIdCtx(C,value)\ncase ',':\nif(C.expect==','){check()\nC.expect='id'\nreturn C}\n$_SyntaxError(C,'token '+token+' after '+\nC)\ncase ')':\ncheck()\nvar last=$B.last(C.tree)\nif(last && last.type==\"func_star_arg\"){if(last.name==\"*\"){if(C.op=='*'){\n$_SyntaxError(C,['named arguments must follow bare *'])}else{$_SyntaxError(C,'invalid syntax')}}}\nreturn C.parent\ncase 'op':\nif(C.has_kw_arg){$_SyntaxError(C,'duplicate keyword argument')}\nvar op=value\nC.expect=','\nif(op=='*'){if(C.has_star_arg){$_SyntaxError(C,'duplicate star argument')}\nreturn new $FuncStarArgCtx(C,'*')}else if(op=='**'){return new $FuncStarArgCtx(C,'**')}else if(op=='/'){\nif(C.has_end_positional){$_SyntaxError(C,['duplicate / in function parameters'])}else if(C.has_star_arg){$_SyntaxError(C,['/ after * in function parameters'])}\nreturn new $EndOfPositionalCtx(C)}\n$_SyntaxError(C,'token '+op+' after '+C)\ncase ':':\nif(C.parent.type==\"lambda\"){return $transition(C.parent,token)}}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$FuncArgs.prototype.to_js=function(){this.js_processed=true\nreturn $to_js(this.tree)}\nvar $FuncArgIdCtx=$B.parser.$FuncArgIdCtx=function(C,name){\nthis.type='func_arg_id'\nif([\"None\",\"True\",\"False\"].indexOf(name)>-1){$_SyntaxError(C,'invalid name')}\nthis.name=name\nthis.parent=C\nif(C.has_star_arg){C.parent.after_star.push(name)}else{C.parent.positional_list.push(name)}\nif(C.parent.type !=\"lambda\"){var node=$get_node(this)\nif(node.binding.hasOwnProperty(name)){$_SyntaxError(C,[\"duplicate argument '\"+name+\"' in function definition\"])}\n$bind(name,node,this)}\nthis.tree=[]\nC.tree[C.tree.length]=this\nvar ctx=C\nwhile(ctx.parent !==undefined){if(ctx.type=='def'){ctx.locals.push(name)\nbreak}\nctx=ctx.parent}\nthis.expect='='}\n$FuncArgIdCtx.prototype.toString=function(){return 'func arg id '+this.name+'='+this.tree}\n$FuncArgIdCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case '=':\nif(C.expect=='='){C.has_default=true\nvar def_ctx=C.parent.parent\nif(C.parent.has_star_arg){def_ctx.default_list.push(def_ctx.after_star.pop())}else{def_ctx.default_list.push(def_ctx.positional_list.pop())}\nreturn new $AbstractExprCtx(C,false)}\nbreak\ncase ',':\ncase ')':\nif(C.parent.has_default && C.tree.length==0 &&\nC.parent.has_star_arg===undefined){$pos-=C.name.length\n$_SyntaxError(C,['non-default argument follows default argument'])}else{return $transition(C.parent,token)}\ncase ':':\nif(C.parent.parent.type==\"lambda\"){\nreturn $transition(C.parent.parent,\":\")}\nif(C.has_default){\n$_SyntaxError(C,'token '+token+' after '+\nC)}\nreturn new $AbstractExprCtx(new $AnnotationCtx(C),false)}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$FuncArgIdCtx.prototype.to_js=function(){this.js_processed=true\nreturn this.name+$to_js(this.tree)}\nvar $FuncStarArgCtx=$B.parser.$FuncStarArgCtx=function(C,op){\nthis.type='func_star_arg'\nthis.op=op\nthis.parent=C\nthis.node=$get_node(this)\nC.has_star_arg=op=='*'\nC.has_kw_arg=op=='**'\nC.tree[C.tree.length]=this}\n$FuncStarArgCtx.prototype.toString=function(){return '(func star arg '+this.op+') '+this.name}\n$FuncStarArgCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\nif(C.name===undefined){if(C.parent.names.indexOf(value)>-1){$_SyntaxError(C,['duplicate argument '+value+\n' in function definition'])}}\nif([\"None\",\"True\",\"False\"].indexOf(value)>-1){$_SyntaxError(C,'invalid name')}\nC.set_name(value)\nC.parent.names.push(value)\nreturn C\ncase ',':\ncase ')':\nif(C.name===undefined){\nC.set_name('*')\nC.parent.names.push('*')}\nreturn $transition(C.parent,token)\ncase ':':\nif(C.parent.parent.type==\"lambda\"){\nreturn $transition(C.parent.parent,\":\")}\nif(C.name===undefined){$_SyntaxError(C,'annotation on an unnamed parameter')}\nreturn new $AbstractExprCtx(\nnew $AnnotationCtx(C),false)}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$FuncStarArgCtx.prototype.set_name=function(name){this.name=name\nif(this.parent.parent.type !=\"lambda\"){if(this.node.binding.hasOwnProperty(name)){$_SyntaxError(C,[\"duplicate argument '\"+name+\"' in function definition\"])}\n$bind(name,this.node,this)}\nvar ctx=this.parent\nwhile(ctx.parent !==undefined){if(ctx.type=='def'){ctx.locals.push(name)\nbreak}\nctx=ctx.parent}\nif(this.op=='*'){ctx.other_args='\"'+name+'\"'}\nelse{ctx.other_kw='\"'+name+'\"'}}\nvar GeneratorExpCtx=function(C){\nthis.type='genexpr'\nthis.tree=[C.tree[0]]\nthis.tree[0].parent=this\nComprehension.make_comp(this,C)}\nGeneratorExpCtx.prototype.ast=function(){\nreturn new ast.GeneratorExp(\nast_or_obj(this.tree[0]),Comprehension.generators(this.tree.slice(1))\n)}\nGeneratorExpCtx.prototype.transition=function(token,value){var C=this\nif(token==')'){this.has_await=Comprehension.has_await(this)\nif(this.parent.type=='call'){return this.parent.parent}\nreturn this.parent}\n$_SyntaxError(C,'token '+token+'after gen expr')}\nGeneratorExpCtx.prototype.to_js=function(){var node=$get_node(this),indent=node.get_indent()\nvar id=this.id,expr=this.tree[0],first_for=this.tree[1]\noutmost_expr=first_for.tree[1].to_js()\nfirst_for.comp_body=true\nfirst_for.iterable_is_outermost=true\nvar module_id=this.module.replace(/\\./g,'_')\nvar js=`(${this.has_await ? 'async ' : ''}function(expr){\n        var $locals_${id} = {},\n            $locals = $locals_${id}\n        $locals.$line_info = '${node.line_num},${node.module}'\\n`+\nComprehension.code(this)+\n`\n        var $top_frame = [\"${id}\", $locals_${id}, \"${this.module}\", $locals_${module_id}]\n        $locals.$f_trace = $B.enter_frame($top_frame)\n        `+\n`var ${id} = ${this.has_await ? 'async ' : ''}function*(expr){\n          var $top_frame = [\"${id}\", $locals_${id}, \"${this.module}\", $locals_${module_id}]\n          $locals.$f_trace = $B.enter_frame($top_frame)\n        `\njs+=first_for.to_js(indent)\nvar nb=-1\nfor(var i=2;i < this.tree.length;i++){nb++\nvar stmt=this.tree[i]\nif(stmt.type=='for'){stmt.comp_body=true\njs+='\\n'+stmt.to_js(indent+nb)}else if(stmt.type=='condition' && stmt.token=='if'){js+='\\n'+' '.repeat(12+4*nb)+stmt.to_js()+'{'}}\nvar expr_has_await=Comprehension.has_await(expr)\njs+='\\n'+' '.repeat(16+4*nb)+\n(expr_has_await ? 'var save_stack = $B.save_stack();\\n' :'')+\n`try{\n                var result = ${expr.to_js()}\n             }catch(err){\n             `+\n(expr_has_await ? '$B.restore_stack(save_stack, $locals);' :'')+\n`\n                 $B.leave_frame($locals)\n                 throw err\n             }\n             `+\n(expr_has_await ? '\\n$B.restore_stack(save_stack, $locals);' :'')+\n`\n             try{\n                $B.leave_frame($locals)\n                yield result\n                $B.frames_stack.push($top_frame)\n             }catch(err1){\n                $B.frames_stack.push($top_frame)\n                throw err1\n             }`\nfor(var i=1;i < this.tree.length;i++){js+='\\n'+' '.repeat(12+4*nb--)+'}'}\njs+=`\n            $B.leave_frame($locals)\n        }\n           $B.leave_frame($locals)\n           return $B.generator.$factory(${id})(expr)\n          }\n          )(${outmost_expr})`\nreturn js}\nvar $GlobalCtx=$B.parser.$GlobalCtx=function(C){\nthis.type='global'\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this\nthis.expect='id'\nthis.scope=$get_scope(this)\nthis.scope.globals=this.scope.globals ||new Set()\nthis.module=$get_module(this)\nwhile(this.module.module !=this.module.id){this.module=this.module.parent_block}\nthis.module.binding=this.module.binding ||{}\nthis.$pos=$pos}\n$GlobalCtx.prototype.ast=function(){\nreturn new ast.Global(this.tree.map(item=> item.value))}\n$GlobalCtx.prototype.toString=function(){return 'global '+this.tree}\nfunction check_global_nonlocal(C,value,type){var scope=C.scope\nif(type=='nonlocal' && scope.globals && scope.globals.has(value)){$_SyntaxError(C,[`name '${value}' is nonlocal and global`])}\nif(type=='global' && scope.nonlocals && scope.nonlocals.has(value)){$_SyntaxError(C,[`name '${value}' is nonlocal and global`])}\nif(['def','generator'].indexOf(scope.ntype)>-1){var params=scope.C.tree[0]\nif(params.locals && params.locals.indexOf(value)>-1){$_SyntaxError(C,[`name '${value}' is parameter and ${type}`])}\nif(scope.binding[value]){console.log('scope ntype',scope)\n$_SyntaxError(C,[`name '${value}' is assigned to before ${type} declaration`])}\nif(scope.referenced && scope.referenced[value]){$_SyntaxError(C,[`name '${value}' is used prior to ${type} declaration`])}}}\n$GlobalCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\nif(C.expect=='id'){check_global_nonlocal(C,value,'global')\nnew $IdCtx(C,value)\nC.add(value)\nC.expect=','\nreturn C}\nbreak\ncase ',':\nif(C.expect==','){C.expect='id'\nreturn C}\nbreak\ncase 'eol':\nif(C.expect==','){return $transition(C.parent,token)}\nbreak}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$GlobalCtx.prototype.add=function(name){if(this.scope.annotations && this.scope.annotations.has(name)){$_SyntaxError(this,[\"annotated name '\"+name+\n\"' can't be global\"])}\nif(this.scope.type==\"module\"){\nreturn}\nif(this.scope.binding && this.scope.binding[name]){console.log('error globals, scope',this.scope)\n$pos=this.$pos-1\n$_SyntaxError(this,[`name '${name}' is parameter and global`])}\nthis.scope.globals.add(name)\nvar mod=this.scope.parent_block\nif(this.module.module.startsWith(\"$exec\")){while(mod && mod.parent_block !==this.module){\nmod._globals=mod._globals ||new Map()\nmod._globals.set(name,this.module.id)\ndelete mod.binding[name]\nmod=mod.parent_block}}\nthis.module.binding[name]=true}\n$GlobalCtx.prototype.to_js=function(){this.js_processed=true\nreturn ''}\nvar $IdCtx=$B.parser.$IdCtx=function(C,value){\nthis.type='id'\nthis.value=value \nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this\nvar scope=this.scope=$get_scope(this)\nthis.blurred_scope=this.scope.blurred\nthis.env=clone(this.scope.binding)\nif([\"def\",\"generator\"].indexOf(scope.ntype)>-1){if((!(C instanceof $GlobalCtx))&&\n!(C instanceof $NonlocalCtx)){scope.referenced=scope.referenced ||{}\nif(! $B.builtins[this.value]){scope.referenced[this.value]=true}}}\nif(C.parent.type=='call_arg'){this.call_arg=true}\nvar ctx=C\nwhile(ctx.parent !==undefined){switch(ctx.type){case 'ctx_manager_alias':\n$bind(value,scope,this)\nbreak\ncase 'list_or_tuple':\ncase 'dict_or_set':\ncase 'call_arg':\ncase 'def':\ncase 'lambda':\nif(ctx.vars===undefined){ctx.vars=[value]}\nelse if(ctx.vars.indexOf(value)==-1){ctx.vars.push(value)}\nif(this.call_arg&&ctx.type=='lambda'){if(ctx.locals===undefined){ctx.locals=[value]}\nelse{ctx.locals.push(value)}}}\nctx=ctx.parent}\nvar target_list=$parent_match(C,{type:'target_list'})\nif(target_list){\nthis.no_bindings=true\nthis.bound=true}\nif([\"def\",\"generator\"].indexOf(scope.ntype)>-1){\nvar _ctx=this.parent\nwhile(_ctx){if(_ctx.comprehension){this.in_comp=true\nbreak}\n_ctx=_ctx.parent}\nif(C.type=='expr' && C.parent.type=='comp_if'){}else if(C.type=='global'){if(scope.globals===undefined){scope.globals=new Set([value])}else{scope.globals.add(value)}}}}\n$IdCtx.prototype.ast=function(){if(['True','False','None'].indexOf(this.value)>-1){return new ast.Constant(_b_[this.value])}\nreturn new ast.Name(this.value,this.bound ? new ast.Store():new ast.Load())}\n$IdCtx.prototype.toString=function(){return '(id) '+this.value+':'+(this.tree ||'')}\n$IdCtx.prototype.transition=function(token,value){var C=this\nif(C.value=='case' && C.parent.parent.type==\"node\"){\nvar start=C.parent.$pos,src=$get_module(this).src\ntry{var flag=line_ends_with_comma(src.substr(start))}catch(err){$pos=start+err.offset\n$_SyntaxError(C,[err.message])}\nif(flag){var node=$get_node(C),parent=node.parent\nif((! node.parent)||!(node.parent.is_match)){$_SyntaxError(C,'\"case\" not inside \"match\"')}else{if(node.parent.irrefutable){\nvar name=node.parent.irrefutable,msg=name=='_' ? 'wildcard' :\n`name capture '${name}'`\n$_SyntaxError(C,[`${msg} makes remaining patterns unreachable`])}}\nreturn $transition(new $PatternCtx(\nnew $CaseCtx(C.parent.parent)),token,value)}}else if(C.value=='match' && C.parent.parent.type==\"node\"){\nvar start=C.parent.$pos,src=$get_module(this).src,flag=line_ends_with_comma(src.substr(start))\nif(flag){return $transition(new $AbstractExprCtx(\nnew $MatchCtx(C.parent.parent),true),token,value)}}\nswitch(token){case '=':\nif(C.parent.type=='expr' &&\nC.parent.parent !==undefined &&\nC.parent.parent.type=='call_arg'){return new $AbstractExprCtx(\nnew $KwArgCtx(C.parent),false)}\nreturn $transition(C.parent,token,value)\ncase '.':\ndelete this.bound\nreturn $transition(C.parent,token,value)\ncase 'op':\nreturn $transition(C.parent,token,value)\ncase 'id':\ncase 'str':\ncase 'JoinedStr':\ncase 'int':\ncase 'float':\ncase 'imaginary':\nif([\"print\",\"exec\"].indexOf(C.value)>-1 ){$_SyntaxError(C,[\"missing parenthesis in call to '\"+\nC.value+\"'\"])}\n$_SyntaxError(C,'token '+token+' after '+\nC)}\nif(this.parent.parent.type==\"packed\"){if(['.','[','('].indexOf(token)==-1){return this.parent.parent.transition(token,value)}}\nreturn $transition(C.parent,token,value)}\n$IdCtx.prototype.firstBindingScopeId=function(){\nvar scope=this.scope,found=[],nb=0\nwhile(scope){if(scope.globals && scope.globals.has(this.value)){return $get_module(this).id}\nif(scope.binding && scope.binding[this.value]){return scope.id}\nscope=scope.parent}}\n$IdCtx.prototype.boundBefore=function(scope){\nfunction test(node,name){if(node.bindings && node.bindings[name]){\nvar ctx=node.C.tree[0]\nif(['def','generator'].indexOf(ctx.type)>-1 &&\nctx.locals.indexOf(name)>-1){return false}\nreturn true}}\nvar node=$get_node(this),found=false\nvar $test=this.value==\"wxc\"\nif($test){console.log(this.value,\"bound before\")\nconsole.log(\"node\",node)\nconsole.log('scope',scope)}\nif((scope.ntype==\"def\" ||scope.ntype==\"generator\")&&\nscope.C.tree[0].args.indexOf(this.value)>-1){return true}\nwhile(!found && node.parent){var pnode=node.parent\nif(test(pnode,this.value)){if($test){console.log(\"bound in\",pnode)}\nreturn pnode.bindings[this.value]}\nfor(var i=0;i < pnode.children.length;i++){var child=pnode.children[i]\nif(child===node){break}\nif(test(child,this.value)){if($test){console.log(\"bound in child\",child)}\nreturn child.bindings[this.value]}}\nif(pnode===scope){break}\nnode=pnode}\nreturn found}\n$IdCtx.prototype.bindingType=function(scope){\nvar nb=0,node=$get_node(this),found=false,unknown,ix\nwhile(!found && node.parent && nb++< 100){var pnode=node.parent\nif(pnode.bindings && pnode.bindings[this.value]){return pnode.bindings[this.value]}\nfor(var i=0;i < pnode.children.length;i++){var child=pnode.children[i]\nif(child===node){break}\nif(child.bindings && child.bindings[this.value]){found=child.bindings[this.value]\nix=i}}\nif(found){for(var j=ix+1;j < pnode.children.length;j++){child=pnode.children[j]\nif(child.children.length > 0){unknown=true\nbreak}else if(child===node){break}}\nreturn found ||unknown}\nif(pnode===scope){break}\nnode=pnode}\nreturn found}\n$IdCtx.prototype.to_js=function(arg){\nvar innermost=$get_scope(this),scope=innermost,found=[]\nif(this.result !==undefined && scope.ntype=='generator'){return this.result}\nvar val=$mangle(this.value,this)\nvar $test=false \nif($test){console.log(\"ENTER IdCtx.py2js line\",$get_node(this).line_num,\"\\nthis\",this,'\\nscope',scope)}\nif(val=='__BRYTHON__' ||val=='$B'){return val}\nif(val.startsWith(\"comp_result_\"+$B.lambda_magic)){if(this.bound){return \"var \"+val}\nreturn val}\nthis.js_processed=true\nif(scope._globals && scope._globals.has(val)){this.global_module=scope._globals.get(val)}\nif(this.global_module){if(this.bound){return '$locals_'+this.global_module.replace(/\\./g,\"_\")+\n'[\"'+val+'\"]'}else{return '$B.$check_def_global(\"'+val+'\", $locals_'+\nthis.global_module.replace(/\\./g,\"_\")+')'}}\nvar is_local=scope.binding[val]!==undefined,this_node=$get_node(this),bound_before=scope.comprehension ?[]:this_node.bound_before\nif($test){console.log('scope',this.scope,'\\nbound before',bound_before,'\\nthis',this)}\nthis.nonlocal=scope.nonlocals && scope.nonlocals.has(val)\nthis.unbound=this.unbound ||(is_local && !this.bound &&\nbound_before && bound_before.indexOf(val)==-1)\nif((!this.bound)&& scope.C\n&& scope.ntype=='class' &&\nscope.C.tree[0].name==val){\nreturn '$B.$search(\"'+val+'\")'}\nif(this.unbound && ! this.nonlocal){if(scope.ntype=='def' ||scope.ntype=='generator' ||\nscope.comprehension){return `$B.$local_search('${val}')`}else{return '$B.$search(\"'+val+'\")'}}\nif($test){console.log(\"innermost\",innermost)}\nvar search_ids=['\"'+innermost.id+'\"']\nvar gs=innermost\nwhile(true){if($test){console.log(val,gs.id,gs,search_ids)\nalert()}\nif(gs.parent_block){if(gs.parent_block==$B.builtins_scope){break}else if(gs.parent_block.id===undefined){break}\ngs=gs.parent_block}\nif(innermost.ntype !=\"class\" ||gs.parent_block===$B.builtins_scope){search_ids.push('\"'+gs.id+'\"')}}\nsearch_ids=\"[\"+search_ids.join(\", \")+\"]\"\nif(innermost.globals && innermost.globals.has(val)){search_ids=['\"'+gs.id+'\"']\ninnermost=gs}\nif($test){console.log(\"search ids\",search_ids)}\nif(this.nonlocal ||this.bound){var bscope=this.firstBindingScopeId()\nif($test){console.log(\"binding\",bscope)}\nif(bscope !==undefined){return \"$locals_\"+bscope.replace(/\\./g,\"_\")+'[\"'+\nval+'\"]'}else if(this.bound){return \"$locals_\"+innermost.id.replace(/\\./g,\"_\")+\n'[\"'+val+'\"]'}}\nvar global_ns='$locals_'+gs.id.replace(/\\./g,'_')\nwhile(1){if(scope.globals !==undefined && scope.globals.has(val)){if($test){console.log(\"in globals of\",scope.id,'globals',gs)}\nif(this.boundBefore(gs)){if($test){console.log(\"bound before in gs\",gs,global_ns)}\nreturn global_ns+'[\"'+val+'\"]'}else{if($test){console.log(\"use global search\",this)}\nif(this.augm_assign){return global_ns+'[\"'+val+'\"]'}else{return '$B.$check_def(\"'+val+'\", '+global_ns+\n'[\"'+val+'\"])'}}}\nif($test){console.log(\"scope\",scope.id,scope,\"\\ninnermost\",innermost,\"\\nscope is innermost\",scope===innermost,\"\\nbound_before\",bound_before,\"\\nfound\",found.slice())}\nif(scope===innermost){\nif(bound_before && bound_before.length > 0){if(bound_before.indexOf(val)>-1){if($test){console.log('add innermost because of bound_before',scope)}\nfound.push(scope)}else if(scope.C &&\nscope.C.tree[0].type=='def' &&\nscope.C.tree[0].env.indexOf(val)>-1){found.push(scope)}}else{if(scope.binding[val]){if($test){console.log(val,'in bindings of',scope.id,this_node.locals[val])}\nif(this_node.locals[val]===undefined){\nif(!scope.is_comp &&\n(!scope.parent_block ||\n!scope.parent_block.is_comp)){\nfound.push(scope)}}else{found.push(scope)\nbreak}\nif($test){console.log(val,\"found in\",scope.id)}}}}else{if(scope.binding===undefined){console.log(\"scope\",scope,val,\"no binding\",innermost)}\nif(innermost.binding[val]&& innermost.ntype==\"class\"){\nif(scope.binding[val]&&\n(! scope.parent_block ||\nscope.parent_block.id==\"__builtins__\")){found.push(scope)\nconsole.l }}else if(scope.binding[val]){found.push(scope)}}\nif(scope.parent_block){scope=scope.parent_block}else{break}}\nthis.found=found\nif($test){console.log(val,\"found\",found)\nfor(var item of found){console.log(item.id)}}\nif(this.nonlocal && found[0]===innermost){found.shift()}\nif(found.length > 0){\nif(found[0].C && found[0]===innermost\n&& val.charAt(0)!='$'){var locs=this_node.locals ||{},nonlocs=innermost.nonlocals\ntry{if(locs[val]===undefined &&\n! this.augm_assign &&\n((innermost.type !='def' ||\ninnermost.type !='generator')&&\ninnermost.ntype !='class' &&\ninnermost.C.tree[0].args &&\ninnermost.C.tree[0].args.indexOf(val)==-1)&&\n(nonlocs===undefined ||nonlocs[val]===undefined)){if($test){console.log(\"$local search\",val,\"found\",found,\"innermost\",innermost,\"this\",this)}\nthis.result='$B.$local_search(\"'+val+'\")'\nreturn this.result}}catch(err){console.log(\"error\",val,innermost)\nthrow err}}\nif(found.length > 1 && found[0].C){if(found[0].C.tree[0].type=='class'){var ns0='$locals_'+found[0].id.replace(/\\./g,'_'),ns1='$locals_'+found[1].id.replace(/\\./g,'_'),res\nif(bound_before){if(bound_before.indexOf(val)>-1){this.found=found[0].binding[val]\nres=ns0}else{this.found=found[1].binding[val]\nres=ns1}\nthis.result=res+'[\"'+val+'\"]'\nreturn this.result}else{this.found=false\nvar res=ns0+'[\"'+val+'\"] !== undefined ? '\nres+=ns0+'[\"'+val+'\"] : '\nthis.result=\"(\"+res+ns1+'[\"'+val+'\"])'\nreturn this.result}}}\nvar scope=found[0]\nif($test){console.log(val,'in scope',scope)}\nthis.found=scope.binding[val]\nvar scope_ns='$locals_'+scope.id.replace(/\\./g,'_')\nif(scope.C===undefined && ! scope.comprehension){if($test){console.log(\"module level\",scope.id,scope.module)}\nif(scope.id=='__builtins__'){if(gs.blurred){\nval='('+global_ns+'[\"'+val+'\"] || _b_.'+val+')'}else{\nval='_b_.'+val\nthis.is_builtin=true}}else{\nif($test){console.log(\"name found at module level\")}\nif(this.bound ||this.augm_assign){\nval=scope_ns+'[\"'+val+'\"]'}else{if(scope===innermost && this.env[val]===undefined){\nthis.result='$B.$search(\"'+val+'\")'\nreturn this.result}else{if($test){console.log(\"boudn before ?\",scope,this.boundBefore(scope))}\nif(this.boundBefore(scope)){\nval=scope_ns+'[\"'+val+'\"]'}else{\nif($test){console.log(\"use check def\",scope)}\nval='$B.$check_def(\"'+val+'\",'+\nscope_ns+'[\"'+val+'\"])'}}}}}else if(scope===innermost){if($test){console.log(\"scope is innermost\",scope.id)}\nif(scope.globals && scope.globals.has(val)){val=global_ns+'[\"'+val+'\"]'}else if(!this.bound && !this.augm_assign){\nif(this.boundBefore(scope)){val='$locals[\"'+val+'\"]'}else{val='$B.$check_def_local(\"'+val+'\",$locals[\"'+\nval+'\"])'}}else{val='$locals[\"'+val+'\"]'}}else if(!this.augm_assign){\nval='$B.$check_def_free(\"'+val+'\",'+scope_ns+\n'[\"'+val+'\"])'}else{val=scope_ns+'[\"'+val+'\"]'}\nthis.result=val+$to_js(this.tree,'')\nreturn this.result}else{\nthis.unknown_binding=true\nthis.result='$B.$global_search(\"'+val+'\", '+search_ids+')'\nreturn this.result}}\nvar $ImportCtx=$B.parser.$ImportCtx=function(C){\nthis.type='import'\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this\nthis.expect='id'}\n$ImportCtx.prototype.ast=function(){\nvar names=[]\nfor(var item of this.tree){var alias=new ast.alias(item.name)\nif(item.alias !=item.name){alias.asname=item.alias}\nnames.push(alias)}\nreturn new ast.Import(names)}\n$ImportCtx.prototype.toString=function(){return 'import '+this.tree}\n$ImportCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\nif(C.expect=='id'){new $ImportedModuleCtx(C,value)\nC.expect=','\nreturn C}\nif(C.expect=='qual'){C.expect=','\nC.tree[C.tree.length-1].name+=\n'.'+value\nC.tree[C.tree.length-1].alias+=\n'.'+value\nreturn C}\nif(C.expect=='alias'){C.expect=','\nC.tree[C.tree.length-1].alias=\nvalue\nreturn C}\nbreak\ncase '.':\nif(C.expect==','){C.expect='qual'\nreturn C}\nbreak\ncase ',':\nif(C.expect==','){C.expect='id'\nreturn C}\nbreak\ncase 'as':\nif(C.expect==','){C.expect='alias'\nreturn C}\nbreak\ncase 'eol':\nif(C.expect==','){C.bind_names()\nreturn $transition(C.parent,token)}\nbreak}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$ImportCtx.prototype.bind_names=function(){\nvar scope=$get_scope(this)\nfor(var item of this.tree){if(item.name==item.alias){var name=item.name,parts=name.split('.'),bound=name\nif(parts.length>1){bound=parts[0]}}else{bound=item.alias}\n$bind(bound,scope,this)}}\n$ImportCtx.prototype.to_js=function(){this.js_processed=true\nvar scope=$get_scope(this),res=[],module=$get_module(this)\nfor(var item of this.tree){var mod_name=item.name,aliases=(item.name==item.alias)?\n'{}' :('{\"'+mod_name+'\" : \"'+\nitem.alias+'\"}'),localns='$locals_'+scope.id.replace(/\\./g,'_'),mod_elts=item.name.split(\".\")\nfor(var i=0;i < mod_elts.length;i++){module.imports[mod_elts.slice(0,i+1).join(\".\")]=true}\nvar js='$B.$import(\"'+mod_name+'\", [],'+aliases+\n','+localns+', true);'\nres.push(js)}\nreturn res.join('')+'_b_.None;'}\nvar $ImportedModuleCtx=$B.parser.$ImportedModuleCtx=function(C,name){this.type='imported module'\nthis.parent=C\nthis.name=name\nthis.alias=name\nC.tree[C.tree.length]=this}\n$ImportedModuleCtx.prototype.toString=function(){return ' (imported module) '+this.name}\n$ImportedModuleCtx.prototype.transition=function(token,value){var C=this}\n$ImportedModuleCtx.prototype.to_js=function(){this.js_processed=true\nreturn '\"'+this.name+'\"'}\nvar JoinedStrCtx=$B.parser.JoinedStrCtx=function(C,values){\nthis.type='JoinedStr'\nthis.parent=C\nthis.tree=[]\nthis.scope=$get_scope(C)\nvar line_num=$get_node(C).line_num\nfor(var value of values){if(typeof value==\"string\"){new $StringCtx(this,\"'\"+\nvalue.replace(new RegExp(\"'\",\"g\"),\"\\\\\"+\"'\")+\"'\")}else{if(value.format !==undefined){value.format=new JoinedStrCtx(this,value.format)\nthis.tree.pop()}\nvar src=value.expression,save_pos=$pos,root=$create_root_node({src},this.scope.module,this.scope.id,this.scope.parent_block,line_num)\nroot.binding=$B.clone(this.scope.binding)\ntry{dispatch_tokens(root,src)}catch(err){err.args[1][1]+=line_num-1\nvar line_start=save_pos,source=$get_module(this).src\nwhile(line_start--> 0 && source[line_start]!='\\n'){}\nerr.args[1][2]+=value.start+save_pos-line_start\nerr.lineno+=line_num-1\nerr.args[1][3]=$get_module(this).src.split('\\n')[line_num-1]\nthrow err}\n$pos=save_pos\nvar expr=root.children[0].C.tree[0]\nthis.tree.push(expr)\nexpr.parent=this\nexpr.elt=value}}\nC.tree.push(this)\nthis.raw=false\nthis.$pos=$pos}\nJoinedStrCtx.prototype.ast=function(){var res={type:'JoinedStr',values:[]}\nvar state\nfor(var item of this.tree){if(item instanceof $StringCtx){if(state=='string'){\n$B.last(res.values).value+=eval(item.value)}else{res.values.push(new ast.Constant(eval(item.value)))}\nstate='string'}else{var conv_num={a:97,r:114,s:115},format=item.elt.format\nformat=format===undefined ? format :ast_or_obj(format)\nvalue=new ast.FormattedValue(\nast_or_obj(item),conv_num[item.elt.conversion]||-1,format)\nvar format=item.format\nif(format !==undefined){value.format=item.format.ast()}\nres.values.push(value)\nstate='formatted_value'}}\nreturn new ast.JoinedStr(res.values)}\nJoinedStrCtx.prototype.toString=function(){return 'f-string '+(this.tree ||'')}\nJoinedStrCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case '[':\nreturn new $AbstractExprCtx(new $SubCtx(C.parent),false)\ncase '(':\nC.parent.tree[0]=C\nreturn new $CallCtx(C.parent)\ncase 'str':\nif(C.tree.length > 0 &&\ntypeof $B.last(C.tree)==\"string\"){C.tree[C.tree.length-1]=\n$B.last(C.tree)+eval(value)}else{new $StringCtx(this,value)}\nreturn C\ncase 'JoinedStr':\nvar joined_expr=new JoinedStrCtx(C.parent,value)\nC.parent.tree.pop()\nif(C.tree.length > 0 &&\n$B.last(C.tree)instanceof $StringCtx &&\njoined_expr.tree[0]instanceof $StringCtx){\n$B.last(C.tree).value+=' + '+joined_expr.tree[0].value\nC.tree=C.tree.concat(joined_expr.tree.slice(1))}else{C.tree=C.tree.concat(joined_expr.tree)}\nreturn C}\nreturn $transition(C.parent,token,value)}\nJoinedStrCtx.prototype.to_js=function(){this.js_processed=true\nvar res='',elts=[]\nfor(var value of this.tree){if(value instanceof $StringCtx){elts.push(value.to_js())}else{\nvar elt=value.elt,js=value.to_js()\nvar pos=0,br_stack=[]\nswitch(elt.conversion){case \"a\":\njs='_b_.ascii('+js+')'\nbreak\ncase \"r\":\njs='_b_.repr('+js+')'\nbreak\ncase \"s\":\njs='_b_.str.$factory('+js+')'\nbreak}\nvar fmt=elt.format\nif(fmt !==undefined){js=\"_b_.str.format('{0:' + \"+\nfmt.to_js()+\" + '}', \"+js+\")\"}else{if(elt.conversion===null){js='_b_.str.$factory('+js+')'}}\nelts.push(js)}}\nreturn \"$B.String(\"+(elts.join(' + ')||\"''\")+\")\"}\nvar $JSCode=$B.parser.$JSCode=function(js){this.js=js}\n$JSCode.prototype.toString=function(){return this.js}\n$JSCode.prototype.transition=function(token,value){var C=this}\n$JSCode.prototype.to_js=function(){this.js_processed=true\nreturn this.js}\nvar $KwArgCtx=$B.parser.$KwArgCtx=function(C){\nthis.type='kwarg'\nthis.parent=C.parent\nthis.tree=[C.tree[0]]\nC.parent.tree.pop()\nC.parent.tree.push(this)\nC.parent.parent.has_kw=true\nvar value=this.tree[0].value\nvar ctx=C.parent.parent \nif(ctx.kwargs===undefined){ctx.kwargs=[value]}\nelse if(ctx.kwargs.indexOf(value)==-1){ctx.kwargs.push(value)}\nelse{$_SyntaxError(C,['keyword argument repeated'])}}\n$KwArgCtx.prototype.toString=function(){return 'kwarg '+this.tree[0]+'='+this.tree[1]}\n$KwArgCtx.prototype.transition=function(token,value){var C=this\nif(token==','){return new $CallArgCtx(C.parent.parent)}\nreturn $transition(C.parent,token)}\n$KwArgCtx.prototype.to_js=function(){this.js_processed=true\nvar key=this.tree[0].value\nvar res='{$nat:\"kw\",name:\"'+key+'\",'\nreturn res+'value:'+\n$to_js(this.tree.slice(1,this.tree.length))+'}'}\nvar $LambdaCtx=$B.parser.$LambdaCtx=function(C){\nthis.type='lambda'\nthis.parent=C\nC.tree[C.tree.length]=this\nthis.tree=[]\nthis.args_start=$pos+6\nthis.vars=[]\nthis.locals=[]\nthis.node=$get_node(this)\nthis.positional_list=[]\nthis.default_list=[]\nthis.other_args=null\nthis.other_kw=null\nthis.after_star=[]}\n$LambdaCtx.prototype.ast=function(){\nvar args\nif(this.args.length==0){args=new ast.arguments([],[],undefined,[],[],undefined,[])}else{args=this.args[0].ast()}\nreturn new ast.Lambda(args,ast_or_obj(this.tree[0]))}\n$LambdaCtx.prototype.toString=function(){return '(lambda) '+this.args_start+' '+this.body_start}\n$LambdaCtx.prototype.transition=function(token,value){var C=this\nif(token==':' && C.args===undefined){C.args=C.tree\nC.tree=[]\nC.body_start=$pos\nreturn new $AbstractExprCtx(C,false)}\nif(C.args !==undefined){\nC.body_end=$pos\nreturn $transition(C.parent,token)}\nif(C.args===undefined && token !=\"(\"){return $transition(new $FuncArgs(C),token,value)}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$LambdaCtx.prototype.to_js=function(){this.js_processed=true\nvar C=this.parent,node=this.node,module=$get_module(this),src=$get_src(C),args=src.substring(this.args_start,this.body_start),body=src.substring(this.body_start+1,this.body_end)\nbody=body.replace(/\\\\\\n/g,' ')\nvar scope=$get_scope(this)\nvar rand=$B.UUID(),func_name='lambda_'+$B.lambda_magic+'_'+rand,py='def '+func_name+'('+args+'):\\n'\npy+='    return ('+body+'\\n)'\nvar lambda_name='lambda'+rand,module_name=module.id.replace(/\\./g,'_')\nvar root=$B.py2js(py,module_name,lambda_name,scope,node.line_num)\nvar js=root.to_js()\nvar params=`$locals_${lambda_name}`,args=\"{}\"\nif(module.is_comp){\nparams+=`, $locals_${module.id.replace(/\\./g, '_')}`\nargs+=`, typeof $locals_${module.id.replace(/\\./g, '_')} `+\n` === \"undefined\" ? {} : $locals_${module.id.replace(/\\./g, '_')}`}\njs=`(function(${params}){\\n`+js+\n`\\nreturn $locals.${func_name}})(${args})`\n$B.clear_ns(lambda_name)\n$B.$py_src[lambda_name]=null\ndelete $B.$py_src[lambda_name]\nreturn js}\nvar ListCompCtx=function(C){\nthis.type='listcomp'\nthis.tree=[C.tree[0]]\nthis.tree[0].parent=this\nComprehension.make_comp(this,C)}\nListCompCtx.prototype.ast=function(){\nreturn new ast.ListComp(\nast_or_obj(this.tree[0]),Comprehension.generators(this.tree.slice(1))\n)}\nListCompCtx.prototype.transition=function(token,value){var C=this\nif(token==']'){this.has_await=Comprehension.has_await(this)\nreturn this.parent}\n$_SyntaxError(C,'token '+token+'after list comp')}\nListCompCtx.prototype.to_js=function(){var node=$get_node(this),indent=node.get_indent()\nvar id=this.id,expr=this.tree[0],first_for=this.tree[1],outmost_expr=first_for.tree[1].to_js()\nfirst_for.comp_body=true\nfirst_for.iterable_is_outermost=true\nvar js=`(${this.has_await ? 'async ' : ''}function(expr){`+\nComprehension.admin_infos(this)+\n`var $result_${id} = []\\n`\njs+=first_for.to_js(indent)\nvar nb=-1\nfor(var i=2;i < this.tree.length;i++){nb++\nvar stmt=this.tree[i]\nif(stmt.type=='for'){stmt.comp_body=true\njs+='\\n'+stmt.to_js(indent+nb)}else if(stmt.type=='condition' && stmt.token=='if'){js+='\\n'+' '.repeat(12+4*nb)+stmt.to_js()+'{'}}\nvar expr_has_await=Comprehension.has_await(expr)\njs+='\\n'+' '.repeat(16+4*nb)+\n(expr_has_await ? 'var save_stack = $B.save_stack();\\n' :'')+\n`try{\\n`+\n` $result_${id}.push(${expr.to_js()})\\n`+\n`}catch(err){\\n`+\n(expr_has_await ? '$B.restore_stack(save_stack, $locals);' :'')+\n`$B.leave_frame($locals); throw err\\n}`+\n(expr_has_await ? '\\n$B.restore_stack(save_stack, $locals);' :'')\nfor(var i=1;i < this.tree.length;i++){js+='\\n'+' '.repeat(12+4*nb--)+'}'}\njs+=`\\n$B.leave_frame({$locals, value: _b_.None})`\njs+=`\\nreturn $result_${id}`\njs+=`\\n}\\n)(${outmost_expr})`\nreturn js}\nvar $ListOrTupleCtx=$B.parser.$ListOrTupleCtx=function(C,real){\nthis.type='list_or_tuple'\nthis.start=$pos\nthis.real=real\nthis.expect='id'\nthis.closed=false\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this}\n$ListOrTupleCtx.prototype.ast=function(){var elts=this.tree.map(ast_or_obj)\nif(this.real=='list'){return new ast.List(elts,new ast.Load())}else if(this.real=='tuple'){return new ast.Tuple(elts,new ast.Load())}else{console.log('list_or_tuple ast, real',this.real)\nreturn this}}\n$ListOrTupleCtx.prototype.toString=function(){switch(this.real){case 'list':\nreturn '(list) ['+this.tree+']'\ndefault:\nreturn '(tuple) ('+this.tree+')'}}\n$ListOrTupleCtx.prototype.transition=function(token,value){var C=this\nif(C.closed){if(token=='['){return new $AbstractExprCtx(\nnew $SubCtx(C.parent),false)}\nif(token=='('){return new $CallCtx(C.parent)}\nreturn $transition(C.parent,token,value)}else{if(C.expect==','){switch(C.real){case 'tuple':\nif(token==')'){var close=true\nif(C.tree.length==1){\nvar grandparent=C.parent.parent\ngrandparent.tree.pop()\ngrandparent.tree.push(C.tree[0])\nC.tree[0].parent=grandparent\nreturn C.tree[0]}\nif(C.packed ||\n(C.type=='list_or_tuple' &&\nC.tree.length==1 &&\nC.tree[0].type=='expr' &&\nC.tree[0].tree[0].type=='packed')){\n$_SyntaxError(C,[\"cannot use starred expression here\"])}\nif(close){C.close()}\nif(C.parent.type==\"packed\"){return C.parent.parent}\nreturn C.parent}\nbreak\ncase 'list':\nif(token==']'){C.close()\nif(C.parent.type==\"packed\"){if(C.parent.tree.length > 0){return C.parent.tree[0]}else{return C.parent.parent}}\nreturn C.parent}\nbreak}\nswitch(token){case ',':\nif(C.real=='tuple'){C.has_comma=true}\nC.expect='id'\nreturn C\ncase 'for':\nif(C.real=='list'){if(this.tree.length > 1){\n$_SyntaxError(C,[\"did you forget \"+\n\"parentheses around the comprehension target?\"])}\nreturn new $TargetListCtx(new $ForExpr(\nnew ListCompCtx(C)))}\nelse{return new $TargetListCtx(new $ForExpr(\nnew GeneratorExpCtx(C)))}}\nreturn $transition(C.parent,token,value)}else if(C.expect=='id'){switch(C.real){case 'tuple':\nif(token==')'){C.close()\nreturn C.parent}\nif(token=='eol' &&\nC.implicit===true){C.close()\nreturn $transition(C.parent,token)}\nbreak\ncase 'list':\nif(token==']'){C.close()\nreturn C}\nbreak}\nswitch(token){case '=':\nif(C.real=='tuple' &&\nC.implicit===true){C.close()\nC.parent.tree.pop()\nvar expr=new $ExprCtx(C.parent,'tuple',false)\nexpr.tree=[C]\nC.parent=expr\nreturn $transition(C.parent,token)}\n$_SyntaxError(C,'unexpected = inside list')\nbreak\ncase ')':\nbreak\ncase ']':\nif(C.real=='tuple' &&\nC.implicit===true){\nreturn $transition(C.parent,token,value)}else{break}\n$_SyntaxError(C,'unexpected \"if\" inside list')\ncase ',':\n$_SyntaxError(C,'unexpected comma inside list')\ncase 'str':\ncase 'JoinedStr':\ncase 'int':\ncase 'float':\ncase 'imaginary':\ncase 'ellipsis':\ncase 'lambda':\ncase 'yield':\ncase 'id':\ncase '(':\ncase '[':\ncase '{':\ncase 'await':\ncase 'not':\ncase ':':\nC.expect=','\nvar expr=new $AbstractExprCtx(C,false)\nreturn $transition(expr,token,value)\ncase 'op':\nif('+-~*'.indexOf(value)>-1 ||value=='**'){C.expect=','\nvar expr=new $AbstractExprCtx(C,false)\nreturn $transition(expr,token,value)}\n$_SyntaxError(C,'unexpected operator: '+value)\ndefault:\n$_SyntaxError(C,'token '+token)}}else{return $transition(C.parent,token,value)}}}\n$ListOrTupleCtx.prototype.close=function(){this.closed=true\nthis.src=$get_module(this).src\nfor(var i=0,len=this.tree.length;i < len;i++){\nvar elt=this.tree[i]\nif(elt.type==\"expr\" &&\nelt.tree[0].type==\"list_or_tuple\" &&\nelt.tree[0].real==\"tuple\" &&\nelt.tree[0].tree.length==1 &&\nelt.tree[0].expect==\",\"){this.tree[i]=elt.tree[0].tree[0]\nthis.tree[i].parent=this}}}\n$ListOrTupleCtx.prototype.get_src=function(){\nvar src=$get_module(this).src\nvar scope=$get_scope(this)\nif(scope.comments===undefined){return src}\nfor(var comment of scope.comments){var start=comment[0],len=comment[1]\nsrc=src.substr(0,start)+' '.repeat(len+1)+\nsrc.substr(start+len+1)}\nreturn src}\n$ListOrTupleCtx.prototype.bind_ids=function(scope){\nfor(var item of this.tree){if(item.type=='id'){$bind(item.value,scope,this)\nitem.bound=true}else if(item.type=='expr' && item.tree[0].type==\"id\"){$bind(item.tree[0].value,scope,this)\nitem.tree[0].bound=true}else if(item.type=='expr' && item.tree[0].type==\"packed\"){var ctx=item.tree[0].tree[0]\nif(ctx.type=='expr' && ctx.tree[0].type=='id'){$bind(ctx.tree[0].value,scope,this)\nctx.tree[0].bound=true}}else if(item.type=='list_or_tuple' ||\n(item.type==\"expr\" &&\nitem.tree[0].type=='list_or_tuple')){if(item.type==\"expr\"){item=item.tree[0]}\nitem.bind_ids(scope)}}}\n$ListOrTupleCtx.prototype.packed_indices=function(){var ixs=[]\nfor(var i=0;i < this.tree.length;i++){var t=this.tree[i]\nif(t.type==\"expr\"){t=t.tree[0]\nif(t.type==\"packed\" ||\n(t.type==\"call\" && t.func.type==\"packed\")){ixs.push(i)}}}\nreturn ixs}\n$ListOrTupleCtx.prototype.unpack=function(packed){var js=\"\",res\nfor(var i=0;i < this.tree.length;i++){if(packed.indexOf(i)>-1){res=\"_b_.list.$factory(\"+this.tree[i].to_js()+\")\"}else{res=\"[\"+this.tree[i].to_js()+\"]\"}\nif(i > 0){res=\".concat(\"+res+\")\"}\njs+=res}\nreturn js}\n$ListOrTupleCtx.prototype.to_js=function(){this.js_processed=true\nvar scope=$get_scope(this),sc=scope,scope_id=scope.id.replace(/\\//g,'_'),pos=0\nvar root=$get_module(this),module_name=root.module\nswitch(this.real){case 'list':\nvar packed=this.packed_indices()\nif(packed.length > 0){return '$B.$list('+this.unpack(packed)+')'}\nreturn '$B.$list(['+$to_js(this.tree)+'])'\ncase 'tuple':\nvar packed=this.packed_indices()\nif(packed.length > 0){return '$B.fast_tuple('+this.unpack(packed)+')'}\nif(this.tree.length==1 && this.has_comma===undefined){return this.tree[0].to_js()}\nreturn '$B.fast_tuple(['+$to_js(this.tree)+'])'}}\nvar $MatchCtx=$B.parser.$MatchCtx=function(node_ctx){\nthis.type=\"match\"\nnode_ctx.tree=[this]\nnode_ctx.node.is_match=true\nthis.parent=node_ctx\nthis.tree=[]\nthis.expect='as'}\n$MatchCtx.prototype.ast=function(){\nvar res=new ast.Match(ast_or_obj(this.tree[0]),ast_body(this.parent))\nres.$line_num=$get_node(this).line_num\nreturn res}\n$MatchCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'as':\nreturn new $AbstractExprCtx(new $AliasCtx(C))\ncase ':':\nif(this.tree[0].type=='list_or_tuple'){remove_abstract_expr(this.tree[0].tree)}\nswitch(C.expect){case 'id':\ncase 'as':\ncase ':':\nreturn $BodyCtx(C)}\nbreak}}\n$MatchCtx.prototype.to_js=function(){return 'var subject = '+$to_js(this.tree)+';if(true)'}\nvar NamedExprCtx=function(C){\nthis.type='named_expr'\nthis.target=C.tree[0]\nthis.target.scope_ref=this.target.binding_scope.id.replace(/\\./g,'_')\nC.tree.pop()\nC.tree.push(this)\nthis.parent=C\nthis.target.parent=this\nthis.tree=[]}\nNamedExprCtx.prototype.ast=function(){var res=new ast.NamedExpr(ast_or_obj(this.target),ast_or_obj(this.tree[0]))\nres.target.ctx=new ast.Store()\nreturn res}\nNamedExprCtx.prototype.transition=function(token,value){return $transition(this.parent,token,value)}\nNamedExprCtx.prototype.to_js=function(){return `($locals_${this.target.scope_ref}.${this.target.value} `+\n`= ${this.tree[0].to_js()})`}\nvar $NodeCtx=$B.parser.$NodeCtx=function(node){\nthis.node=node\nnode.C=this\nthis.tree=[]\nthis.type='node'\nvar scope=null\nvar tree_node=node\nwhile(tree_node.parent && tree_node.parent.type !='module'){var ntype=tree_node.parent.C.tree[0].type,_break_flag=false\nswitch(ntype){case 'def':\ncase 'class':\ncase 'generator':\nscope=tree_node.parent\n_break_flag=true}\nif(_break_flag){break}\ntree_node=tree_node.parent}\nif(scope===null){scope=tree_node.parent ||tree_node }\nthis.node.locals=clone(scope.binding)\nthis.scope=scope}\n$NodeCtx.prototype.toString=function(){return 'node '+this.tree}\n$NodeCtx.prototype.transition=function(token,value){var C=this\nif(this.node.parent && this.node.parent.C){var pctx=this.node.parent.C\nif(pctx.tree && pctx.tree.length==1 &&\npctx.tree[0].type==\"match\"){if(token !='eol' &&(token !=='id' ||value !=='case')){C.$pos=$pos\n$_SyntaxError(C,'line does not start with \"case\"')}}}\nif(this.tree.length==0 && this.node.parent){var rank=this.node.parent.children.indexOf(this.node)\nif(rank > 0){var previous=this.node.parent.children[rank-1]\nif(previous.C.tree[0].type=='try' &&\n['except','finally'].indexOf(token)==-1){$_SyntaxError(C,[\"expected 'except' or 'finally' block\"])}}}\nswitch(token){case ',':\nif(C.tree && C.tree.length==0){$_SyntaxError(C,'token '+token+' after '+C)}\nvar first=C.tree[0]\nC.tree=[]\nvar implicit_tuple=new $ListOrTupleCtx(C)\nimplicit_tuple.real=\"tuple\"\nimplicit_tuple.implicit=0\nimplicit_tuple.tree.push(first)\nfirst.parent=implicit_tuple\nreturn implicit_tuple\ncase '[':\ncase '(':\ncase '{':\ncase '.':\ncase 'bytes':\ncase 'float':\ncase 'id':\ncase 'imaginary':\ncase 'int':\ncase 'str':\ncase 'JoinedStr':\ncase 'not':\ncase 'lambda':\nvar expr=new $AbstractExprCtx(C,true)\nreturn $transition(expr,token,value)\ncase 'assert':\nreturn new $AbstractExprCtx(\nnew $AssertCtx(C),false,true)\ncase 'async':\nreturn new $AsyncCtx(C)\ncase 'await':\nreturn new $AbstractExprCtx(new $AwaitCtx(C),true)\ncase 'break':\nreturn new $BreakCtx(C)\ncase 'class':\nreturn new $ClassCtx(C)\ncase 'continue':\nreturn new $ContinueCtx(C)\ncase '__debugger__':\nreturn new $DebuggerCtx(C)\ncase 'def':\nreturn new $DefCtx(C)\ncase 'del':\nreturn new $AbstractExprCtx(new $DelCtx(C),true)\ncase 'elif':\ntry{var previous=$previous(C)}catch(err){$_SyntaxError(C,\"'elif' does not follow 'if'\")}\nif(['condition'].indexOf(previous.type)==-1 ||\nprevious.token=='while'){$_SyntaxError(C,'elif after '+previous.type)}\nreturn new $AbstractExprCtx(\nnew $ConditionCtx(C,token),false)\ncase 'ellipsis':\nvar expr=new $AbstractExprCtx(C,true)\nreturn $transition(expr,token,value)\ncase 'else':\nvar previous=$previous(C)\nif(['condition','except','for'].\nindexOf(previous.type)==-1){$_SyntaxError(C,'else after '+previous.type)}\nreturn new $SingleKwCtx(C,token)\ncase 'except':\nvar previous=$previous(C)\nif(['try','except'].indexOf(previous.type)==-1){$_SyntaxError(C,'except after '+previous.type)}\nreturn new $ExceptCtx(C)\ncase 'finally':\nvar previous=$previous(C)\nif(['try','except'].indexOf(previous.type)==-1 &&\n(previous.type !='single_kw' ||\nprevious.token !='else')){$_SyntaxError(C,'finally after '+previous.type)}\nreturn new $SingleKwCtx(C,token)\ncase 'for':\nreturn new $TargetListCtx(new $ForExpr(C))\ncase 'from':\nreturn new $FromCtx(C)\ncase 'global':\nreturn new $GlobalCtx(C)\ncase 'if':\ncase 'while':\nreturn new $AbstractExprCtx(\nnew $ConditionCtx(C,token),false)\ncase 'import':\nreturn new $ImportCtx(C)\ncase 'lambda':\nreturn new $LambdaCtx(C)\ncase 'nonlocal':\nreturn new $NonlocalCtx(C)\ncase 'op':\nswitch(value){case '*':\nvar expr=new $AbstractExprCtx(C,true)\nreturn $transition(expr,token,value)\ncase '+':\ncase '-':\ncase '~':\nreturn new $AbstractExprCtx(\nnew $UnaryCtx(\nnew $ExprCtx(C,'unary',true),value),false)\ncase '@':\nreturn new $DecoratorCtx(C)}\nbreak\ncase 'pass':\nreturn new $PassCtx(C)\ncase 'raise':\nreturn new $AbstractExprCtx(new $RaiseCtx(C),true)\ncase 'return':\nreturn new $AbstractExprCtx(new $ReturnCtx(C),true)\ncase 'try':\nreturn new $TryCtx(C)\ncase 'with':\nreturn new $AbstractExprCtx(new $WithCtx(C),false)\ncase 'yield':\nreturn new $AbstractExprCtx(new $YieldCtx(C),true)\ncase 'eol':\nif(C.tree.length==0){\nC.node.parent.children.pop()\nreturn C.node.parent.C}\nreturn C}\nconsole.log('token',token,value)\n$_SyntaxError(C,'token '+token+' after '+C)}\n$NodeCtx.prototype.to_js=function(){if(this.js !==undefined){return this.js}\nthis.js_processed=true\nthis.js=\"\"\nif(this.tree[0]){var is_not_def=[\"def\",\"generator\"].indexOf(this.scope.ntype)==-1\nif(this.tree[0].annotation){\nif(is_not_def){if(this.tree[0].type==\"expr\" &&\n! this.tree[0].$in_parens &&\nthis.tree[0].tree[0].type==\"id\"){var js=\"\"\nif(this.create_annotations){js+=\"$locals.__annotations__ = $B.empty_dict();\"}\nreturn js+\"_b_.dict.$setitem($locals.__annotations__, '\"+\nthis.tree[0].tree[0].value+\"', \"+\nthis.tree[0].annotation.to_js()+\");\"}else if(this.tree[0].type==\"def\" ||\nthis.tree[0].type==\"generator\"){\nthis.js=this.tree[0].annotation.to_js()+\";\"}else{\nthis.js=\"\"}}else if([\"def\",\"generator\"].indexOf(this.tree[0].type)==-1){\nthis.tree=[]}}else if(this.tree[0].type==\"assign\" &&\n! this.tree[0].tree[0].$in_parens &&\nthis.tree[0].tree[0].annotation){\nvar left=this.tree[0].tree[0],right=this.tree[0].tree[1]\nif(this.create_annotations){this.js+=\"$locals.__annotations__ = $B.empty_dict();\"}\nthis.js+=\"var $value = \"+right.to_js()+\";\"\nthis.tree[0].tree.splice(1,1)\nnew $RawJSCtx(this.tree[0],\"$value\")\nif(left.tree[0]&& left.tree[0].type==\"id\" && is_not_def){this.js+=\"_b_.dict.$setitem($locals.__annotations__, '\"+\nleft.tree[0].value+\"', \"+\nleft.annotation.to_js()+\");\"}else{\nthis.js+=$to_js(this.tree)+\";\"\nif(is_not_def){this.js+=left.annotation.to_js()}\nreturn this.js}}}\nif(this.node.children.length==0){this.js+=$to_js(this.tree)+';'}else{this.js+=$to_js(this.tree)}\nreturn this.js}\nvar $NodeJS=$B.parser.$NodeJS=function(js){var node=new $Node()\nnew $NodeJSCtx(node,js)\nreturn node}\nvar $NodeJSCtx=$B.parser.$NodeJSCtx=function(node,js){\nthis.node=node\nnode.C=this\nthis.type='node_js'\nthis.tree=[js]}\n$NodeJSCtx.prototype.toString=function(){return 'js '+js}\n$NodeJSCtx.prototype.to_js=function(){this.js_processed=true\nreturn this.tree[0]}\nvar $NonlocalCtx=$B.parser.$NonlocalCtx=function(C){\nthis.type='nonlocal'\nthis.parent=C\nthis.tree=[]\nthis.names={}\nC.tree[C.tree.length]=this\nthis.expect='id'\nthis.scope=$get_scope(this)\nthis.scope.nonlocals=this.scope.nonlocals ||new Set()\nif(this.scope.C===undefined){$_SyntaxError(C,[\"nonlocal declaration not allowed at module level\"])}}\n$NonlocalCtx.prototype.toString=function(){return 'nonlocal '+this.tree}\n$NonlocalCtx.prototype.ast=function(){\nreturn new ast.Nonlocal(this.tree.map(item=> item.value))}\n$NonlocalCtx.prototype.add=function(name){if(this.scope.binding[name]==\"arg\"){$_SyntaxError(C,[\"name '\"+name+\"' is parameter and nonlocal\"])}\nthis.names[name]=[false,$pos]\nthis.scope.nonlocals.add(name)}\n$NonlocalCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\nif(C.expect=='id'){check_global_nonlocal(C,value,'nonlocal')\nnew $IdCtx(C,value)\nC.add(value)\nC.expect=','\nreturn C}\nbreak\ncase ',':\nif(C.expect==','){C.expect='id'\nreturn C}\nbreak\ncase 'eol':\nif(C.expect==','){return $transition(C.parent,token)}\nbreak}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$NonlocalCtx.prototype.transform=function(node,rank){var C=this.parent,pscope=this.scope.parent_block\nif(pscope.C===undefined){$_SyntaxError(C,[\"no binding for nonlocal '\"+\n$B.last(Object.keys(this.names))+\"' found\"])}else{while(pscope !==undefined && pscope.C !==undefined){for(var name in this.names){if(pscope.binding[name]!==undefined){this.names[name]=[true]}}\npscope=pscope.parent_block}\nfor(var name in this.names){if(!this.names[name][0]){console.log('nonlocal error, C '+C)\n$pos=this.names[name][1]\n$_SyntaxError(C,[\"no binding for nonlocal '\"+\nname+\"' found\"])}}}}\n$NonlocalCtx.prototype.to_js=function(){this.js_processed=true\nreturn ''}\nvar $NotCtx=$B.parser.$NotCtx=function(C){\nthis.type='not'\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this}\n$NotCtx.prototype.ast=function(){return new ast.UnaryOp(new ast.Not(),ast_or_obj(this.tree[0]))}\n$NotCtx.prototype.toString=function(){return 'not ('+this.tree+')'}\n$NotCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'in':\nC.parent.parent.tree.pop()\nreturn new $ExprCtx(new $OpCtx(C.parent,'not_in'),'op',false)\ncase 'id':\ncase 'imaginary':\ncase 'int':\ncase 'float':\ncase 'str':\ncase 'JoinedStr':\ncase 'bytes':\ncase '[':\ncase '(':\ncase '{':\ncase '.':\ncase 'not':\ncase 'lambda':\nvar expr=new $AbstractExprCtx(C,false)\nreturn $transition(expr,token,value)\ncase 'op':\nvar a=value\nif('+'==a ||'-'==a ||'~'==a){var expr=new $AbstractExprCtx(C,false)\nreturn $transition(expr,token,value)}}\nreturn $transition(C.parent,token)}\n$NotCtx.prototype.to_js=function(){this.js_processed=true\nreturn '!$B.$bool('+$to_js(this.tree)+')'}\nvar $NumberCtx=$B.parser.$NumberCtx=function(type,C,value){\nthis.type=type\nthis.value=value\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this}\n$NumberCtx.prototype.ast=function(){return new ast.Constant({type:this.type,value:this.value})}\n$NumberCtx.prototype.toString=function(){return this.type+' '+this.value}\n$NumberCtx.prototype.transition=function(token,value){var C=this\nreturn $transition(C.parent,token,value)}\n$NumberCtx.prototype.to_js=function(){this.js_processed=true\nvar type=this.type,value=this.value\nif(type=='int'){var v=parseInt(value[1],value[0])\nif(v > $B.min_int && v < $B.max_int){return v}else{var v=$B.long_int.$factory(value[1],value[0])\nreturn '$B.fast_long_int(\"'+v.value+'\", '+v.pos+')'}}else if(type==\"float\"){\nif(/^\\d+$/.exec(value)||/^\\d+\\.\\d*$/.exec(value)){return '(new Number('+this.value+'))'}\nreturn '_b_.float.$factory('+value+')'}else if(type==\"imaginary\"){return '$B.make_complex(0,'+value+')'}}\nvar $OpCtx=$B.parser.$OpCtx=function(C,op){\nthis.type='op'\nthis.op=op\nthis.parent=C.parent\nthis.tree=[C]\nthis.scope=$get_scope(this)\nif(C.type==\"expr\"){if(['int','float','str'].indexOf(C.tree[0].type)>-1){this.left_type=C.tree[0].type}else if(C.tree[0].type==\"id\"){var binding=this.scope.binding[C.tree[0].value]\nif(binding){this.left_type=binding.type}}}\nC.parent.tree.pop()\nC.parent.tree.push(this)}\n$OpCtx.prototype.ast=function(){\nvar ast_type_class=op2ast_class[this.op],op_type=ast_type_class[0],ast_class=ast_type_class[1]\nif(op_type===ast.Compare){var left=ast_or_obj(this.tree[0]),ops=[new ast_class()]\nif(this.ops){for(var op of this.ops.slice(1)){ops.push(new op2ast_class[op][1]())}\nreturn new ast.Compare(left,ops,this.tree.slice(1).map(ast_or_obj))}else{return new ast.Compare(left,ops,[ast_or_obj(this.tree[1])])}}\nif(op_type===ast.UnaryOp){return new op_type(new ast_class(),ast_or_obj(this.tree[1]))}\nif(op_type===ast.BoolOp){\nvar values=[this.tree[1]],main_op=this.op,ctx=this\nwhile(ctx.tree[0].type=='op' && ctx.tree[0].op==main_op){values.splice(0,0,ctx.tree[0].tree[1])\nctx=ctx.tree[0]}\nvalues.splice(0,0,ctx.tree[0])\nreturn new op_type(new ast_class(),values.map(ast_or_obj))}\nreturn new op_type(\nast_or_obj(this.tree[0]),new ast_class(),ast_or_obj(this.tree[1]))}\n$OpCtx.prototype.toString=function(){return '(op '+this.op+') ['+this.tree+']'}\n$OpCtx.prototype.transition=function(token,value){var C=this\nif(C.op===undefined){$_SyntaxError(C,['C op undefined '+C])}\nswitch(token){case 'id':\ncase 'imaginary':\ncase 'int':\ncase 'float':\ncase 'str':\ncase 'JoinedStr':\ncase 'bytes':\ncase '[':\ncase '(':\ncase '{':\ncase '.':\ncase 'not':\ncase 'lambda':\nreturn $transition(new $AbstractExprCtx(C,false),token,value)\ncase 'op':\nswitch(value){case '+':\ncase '-':\ncase '~':\nreturn new $UnaryCtx(C,value)}\ndefault:\nif(C.tree[C.tree.length-1].type==\n'abstract_expr'){$_SyntaxError(C,'token '+token+' after '+\nC)}}\nreturn $transition(C.parent,token)}\n$OpCtx.prototype.to_js=function(){this.js_processed=true\nvar comps={'==':'eq','!=':'ne','>=':'ge','<=':'le','<':'lt','>':'gt'}\nif(comps[this.op]!==undefined){if(this.ops){var i=0,tests=[]\nfor(var op of this.ops){var method=comps[op]\ntests.push(`$B.rich_comp('__${method}__', `+\n`${i == 0 ? this.tree[i].to_js(): '$locals.$op'}, `+\n`$locals.$op = ${this.tree[i + 1].to_js()})`)\ni++}\nreturn tests.join(' && ')}\nvar method=comps[this.op]\nif(this.tree[0].type=='expr' && this.tree[1].type=='expr'){var t0=this.tree[0].tree[0],t1=this.tree[1].tree[0],js0=t0.to_js(),js1=t1.to_js()\nswitch(t1.type){case 'int':\nswitch(t0.type){case 'int':\nif(Number.isSafeInteger(t0.value)&&\nNumber.isSafeInteger(t1.value)){return js0+this.op+js1}else{return '$B.$getattr('+\nthis.tree[0].to_js()+',\"__'+\nmethod+'__\")('+\nthis.tree[1].to_js()+')'}\ncase 'str':\nswitch(this.op){case \"==\":\nreturn \"false\"\ncase \"!=\":\nreturn \"true\"\ndefault:\nreturn '$B.$TypeError(\"unorderable types: '+\n\" int() \"+this.op+' str()\")'}\ncase 'id':\nreturn '(typeof '+js0+' == \"number\" ? '+\njs0+this.op+js1+' : $B.rich_comp(\"__'+\nmethod+'__\",'+this.tree[0].to_js()+\n','+this.tree[1].to_js()+'))'}\nbreak;\ncase 'str':\nswitch(t0.type){case 'str':\nreturn js0+'.valueOf() '+this.op+js1+'.valueOf()'\ncase 'int':\nswitch(this.op){case \"==\":\nreturn \"false\"\ncase \"!=\":\nreturn \"true\"\ndefault:\nreturn '$B.$TypeError(\"unorderable types: '+\n' str() '+this.op+' int()\")'}\ncase 'id':\nreturn '(typeof '+js0+' == \"string\" ? '+\njs0+this.op+js1+' : $B.rich_comp(\"__'+\nmethod+'__\",'+this.tree[0].to_js()+\n','+this.tree[1].to_js()+'))'}\nbreak;\ncase 'id':\nif(t0.type=='id'){return 'typeof '+js0+'!=\"object\" && typeof '+\njs0+'!=\"function\" && typeof '+js0+\n' == typeof '+js1+' ? '+js0+this.op+js1+\n' : $B.rich_comp(\"__'+method+'__\",'+\nthis.tree[0].to_js()+','+this.tree[1].to_js()+\n')'}\nbreak}}}\nswitch(this.op){case 'and':\nvar op0=this.tree[0].to_js(),op1=this.tree[1].to_js()\nif(this.wrap !==undefined){\nreturn '(function(){var '+this.wrap.name+' = '+\nthis.wrap.js+';return $B.$test_expr($B.$test_item('+\nop0+') && $B.$test_item('+op1+'))})()'}else{return '$B.$test_expr($B.$test_item('+op0+')&&'+\n'$B.$test_item('+op1+'))'}\ncase 'or':\nvar res='$B.$test_expr($B.$test_item('+\nthis.tree[0].to_js()+')||'\nreturn res+'$B.$test_item('+this.tree[1].to_js()+'))'\ncase 'in':\nreturn '$B.$is_member('+$to_js(this.tree)+')'\ncase 'not_in':\nreturn '!$B.$is_member('+$to_js(this.tree)+')'\ncase 'unary_neg':\ncase 'unary_pos':\ncase 'unary_inv':\nvar op,method\nif(this.op=='unary_neg'){op='-';method='__neg__'}\nelse if(this.op=='unary_pos'){op='+';method='__pos__'}\nelse{op='~';method='__invert__'}\nif(this.tree[1].type==\"expr\"){var x=this.tree[1].tree[0]\nswitch(x.type){case 'int':\nvar v=parseInt(x.value[1],x.value[0])\nif(Number.isSafeInteger(v)){return op+v}\nreturn '$B.$getattr('+x.to_js()+', \"'+\nmethod+'\")()'\ncase 'float':\nreturn '_b_.float.$factory('+op+x.value+')'\ncase 'imaginary':\nreturn '$B.make_complex(0,'+op+x.value+')'}}\nreturn '$B.$getattr('+this.tree[1].to_js()+',\"'+\nmethod+'\")()'\ncase 'is':\nreturn '$B.$is('+this.tree[0].to_js()+', '+\nthis.tree[1].to_js()+')'\ncase 'is_not':\nreturn '! $B.$is('+this.tree[0].to_js()+', '+\nthis.tree[1].to_js()+')'\ncase '+':\nreturn '$B.add('+this.tree[0].to_js()+', '+\nthis.tree[1].to_js()+')'\ncase '*':\ncase '-':\nvar op=this.op,vars=[],has_float_lit=false,scope=$get_scope(this)\nfunction is_simple(elt){if(elt.type=='expr' && elt.tree[0].type=='int'){return true}else if(elt.type=='expr' &&\nelt.tree[0].type=='float'){has_float_lit=true\nreturn true}else if(elt.type=='expr' &&\nelt.tree[0].type=='list_or_tuple' &&\nelt.tree[0].real=='tuple' &&\nelt.tree[0].tree.length==1 &&\nelt.tree[0].tree[0].type=='expr'){return is_simple(elt.tree[0].tree[0].tree[0])}else if(elt.type=='expr' && elt.tree[0].type=='id'){var _var=elt.tree[0].to_js()\nif(vars.indexOf(_var)==-1){vars.push(_var)}\nreturn true}else if(elt.type=='op' &&\n['*','+','-'].indexOf(elt.op)>-1){for(var i=0;i < elt.tree.length;i++){if(!is_simple(elt.tree[i])){return false}}\nreturn true}\nreturn false}\nfunction get_type(ns,v){var t\nif(['int','float','str'].indexOf(v.type)>-1){t=v.type}else if(v.type=='id' && ns[v.value]){t=ns[v.value].type}\nreturn t}\nvar e0=this.tree[0],e1=this.tree[1]\nif(is_simple(this)){var v0=this.tree[0].tree[0],v1=this.tree[1].tree[0]\nif(vars.length==0 && !has_float_lit){\nreturn this.simple_js()}else if(vars.length==0){\nreturn 'new Number('+this.simple_js()+')'}else{\nvar ns=scope.binding,t0=get_type(ns,v0),t1=get_type(ns,v1)\nif((t0=='float' && t1=='float')||\n(this.op=='+' && t0=='str' && t1=='str')){this.result_type=t0\nreturn v0.to_js()+this.op+v1.to_js()}else if(['int','float'].indexOf(t0)>-1 &&\n['int','float'].indexOf(t1)>-1){if(t0=='int' && t1=='int'){this.result_type='int'}else{this.result_type='float'}\nswitch(this.op){case '-':\nreturn '$B.sub('+v0.to_js()+','+\nv1.to_js()+')'\ncase '*':\nreturn '$B.mul('+v0.to_js()+','+\nv1.to_js()+')'}}\nvar tests=[],tests1=[],pos=0\nfor(var _var of vars){\ntests.push(_var+'.valueOf && typeof '+_var+\n'.valueOf() == \"number\"')\ntests1.push('typeof '+_var+' == \"number\"')}\nvar res=[tests.join(' && ')+' ? ']\nres.push('('+tests1.join(' && ')+' ? ')\nres.push(this.simple_js())\nres.push(' : new Number('+this.simple_js()+')')\nres.push(')')\nvar t0=this.tree[0].to_js(),t1=this.tree[1].to_js()\nif(this.op=='+'){res.push(' : (typeof '+t0+\n' == \"string\" && typeof '+t1+\n' == \"string\") ? '+t0+'+'+t1)}\nres.push(': $B.rich_op(\"'+$operators[this.op]+'\",'+\nt0+','+t1+')')\nreturn '('+res.join('')+')'}}\nif(comps[this.op]!==undefined){return '$B.rich_comp(\"__'+$operators[this.op]+'__\",'+\ne0.to_js()+','+e1.to_js()+')'}else{return '$B.rich_op(\"'+$operators[this.op]+'\", '+\ne0.to_js()+', '+e1.to_js()+')'}\ndefault:\nif(comps[this.op]!==undefined){return '$B.rich_comp(\"__'+$operators[this.op]+'__\",'+\nthis.tree[0].to_js()+','+this.tree[1].to_js()+')'}else{return '$B.rich_op(\"'+$operators[this.op]+'\", '+\nthis.tree[0].to_js()+', '+this.tree[1].to_js()+\n')'}}}\n$OpCtx.prototype.simple_js=function(){var op=this.op\nfunction sjs(elt){if(elt.type=='op'){return elt.simple_js()}else if(elt.type=='expr' && elt.tree[0].type=='list_or_tuple'\n&& elt.tree[0].real=='tuple'\n&& elt.tree[0].tree.length==1\n&& elt.tree[0].tree[0].type=='expr'){return '('+elt.tree[0].tree[0].tree[0].simple_js()+')'}else{return elt.tree[0].to_js()}}\nif(op=='+'){return '$B.add('+sjs(this.tree[0])+','+\nsjs(this.tree[1])+')'}else if(op=='-'){return '$B.sub('+sjs(this.tree[0])+','+\nsjs(this.tree[1])+')'}else if(op=='*'){return '$B.mul('+sjs(this.tree[0])+','+\nsjs(this.tree[1])+')'}else if(op=='/'){return '$B.div('+sjs(this.tree[0])+','+\nsjs(this.tree[1])+')'}else{return sjs(this.tree[0])+op+sjs(this.tree[1])}}\nvar $PackedCtx=$B.parser.$PackedCtx=function(C){\nthis.type='packed'\nif(C.parent.type=='list_or_tuple' &&\nC.parent.parent.type==\"node\"){\nfor(var i=0;i < C.parent.tree.length;i++){var child=C.parent.tree[i]\nif(child.type=='expr' && child.tree.length > 0\n&& child.tree[0].type=='packed'){$_SyntaxError(C,[\"two starred expressions in assignment\"])}}}\nthis.parent=C\nthis.tree=[]\nthis.pos=$pos-1 \nC.tree[C.tree.length]=this}\n$PackedCtx.prototype.ast=function(){return new ast.Starred(ast_or_obj(this.tree[0]),new ast.Load())}\n$PackedCtx.prototype.toString=function(){return '(packed) '+this.tree}\n$PackedCtx.prototype.transition=function(token,value){var C=this\nif(C.tree.length > 0 && token==\"[\"){\nreturn $transition(C.tree[0],token,value)}\nswitch(token){case 'id':\nvar expr=new $AbstractExprCtx(C,false)\nexpr.packed=true\nC.parent.expect=','\nvar id=$transition(expr,token,value)\nreturn id\ncase \"[\":\nC.parent.expect=','\nreturn new $ListOrTupleCtx(C,\"list\")\ncase \"(\":\nC.parent.expect=','\nreturn new $ListOrTupleCtx(C,\"tuple\")\ncase 'str':\nC.parent.expect=\",\"\nreturn new $StringCtx(C,value)\ncase 'JoinedStr':\nC.parent.expect=\",\"\nreturn new JoinedStrCtx(C,value)\ncase \"]\":\nreturn $transition(C.parent,token,value)\ncase \"{\":\nC.parent.expect=','\nreturn new $DictOrSetCtx(C)\ncase 'op':\nswitch(value){case '+':\ncase '-':\ncase '~':\nC.parent.expect=','\nreturn new $UnaryCtx(C,value)\ndefault:\n$_SyntaxError(C,[\"can't use starred expression here\"])}}\nreturn C.parent.transition(token,C)}\n$PackedCtx.prototype.to_js=function(){this.js_processed=true\nreturn $to_js(this.tree)}\nvar $PassCtx=$B.parser.$PassCtx=function(C){\nthis.type='pass'\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this}\n$PassCtx.prototype.ast=function(){return new ast.Pass()}\n$PassCtx.prototype.toString=function(){return '(pass)'}\n$PassCtx.prototype.transition=function(token,value){var C=this\nif(token=='eol'){return C.parent}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$PassCtx.prototype.to_js=function(){this.js_processed=true\nreturn 'void(0)'}\nvar $PatternCtx=$B.parser.$PatternCtx=function(C){\nthis.type=\"pattern\"\nthis.parent=C\nthis.tree=[]\nC.tree.push(this)\nthis.expect='id'}\n$PatternCtx.prototype.transition=function(token,value){var C=this\nswitch(C.expect){case 'id':\nswitch(token){case 'str':\ncase 'int':\ncase 'float':\ncase 'imaginary':\nC.expect=','\nreturn new $PatternLiteralCtx(C,token,value)\ncase 'op':\nswitch(value){case '-':\ncase '+':\nC.expect=','\nreturn new $PatternLiteralCtx(C,{sign:value})\ncase '*':\nC.expect='starred_id'\nreturn C\ndefault:\n$_SyntaxError(C)}\ncase 'id':\nC.expect=','\nif(['None','True','False'].indexOf(value)>-1){return new $PatternLiteralCtx(C,token,value)}else{return new $PatternCaptureCtx(C,value)}\nbreak\ncase '[':\nreturn new $PatternCtx(\nnew $PatternSequenceCtx(C.parent,token))\ncase '(':\nreturn new $PatternCtx(\nnew $PatternGroupCtx(C.parent,token))\ncase '{':\nreturn new $PatternMappingCtx(C.parent,token)\ncase 'JoinedStr':\n$_SyntaxError(C,[\"patterns may only match \"+\n\"literals and attribute lookups\"])}\nbreak\ncase 'starred_id':\nif(token=='id'){var capture=new $PatternCaptureCtx(C,value)\ncapture.starred=true\nreturn capture}\n$_SyntaxError(C,'expected id after *')\ncase 'number':\nswitch(token){case 'int':\ncase 'float':\ncase 'imaginary':\nC.expect=','\nreturn new $PatternLiteralCtx(C,token,value,C.sign)\ndefault:\n$_SyntaxError(C)}\ncase ',':\nswitch(token){case ',':\nif(C.parent instanceof $PatternSequenceCtx){return new $PatternCtx(C.parent)}\nreturn new $PatternCtx(\nnew $PatternSequenceCtx(C.parent))\ncase ':':\nreturn $BodyCtx(C)}}\nreturn C.parent.transition(token,value)}\nfunction as_pattern(C,token,value){\nif(C.expect=='as'){if(token=='as'){C.expect='alias'\nreturn C}else{return $transition(C.parent,token,value)}}else if(C.expect=='alias'){if(token=='id'){if(value=='_'){$_SyntaxError(C,[\"alias cannot be _\"])}\nif(C.bindings().indexOf(value)>-1){$_SyntaxError(C,[`multiple assignments to name '${value}' in pattern`])}\nC.alias=value\nreturn C.parent}else{$_SyntaxError(C,'bad alias')}}}\nvar $PatternCaptureCtx=function(C,value){\nthis.type=\"capture_pattern\"\nthis.parent=C.parent\nC.parent.tree.pop()\nC.parent.tree.push(this)\nthis.tree=[value]\nthis.expect='.'\nthis.$pos=$pos}\n$PatternCaptureCtx.prototype.ast=function(){try{if(this.tree.length > 1){var pattern=new ast.Name(this.tree[0].value,new ast.Load())\nfor(var i=1;i < this.tree.length;i+=2){pattern=new ast.Attribute(pattern,this.tree[i],new ast.Load())}\nreturn new ast.MatchValue(pattern)}else{var pattern=this.tree[0]\nif(typeof pattern=='string'){pattern=pattern.value}else if(pattern.type=='group_pattern'){pattern=pattern.ast()}else{console.log('bizarre',pattern)\npattern=$NumberCtx.prototype.ast.bind(this)()}\nif(pattern=='_'){pattern=undefined}}\nif(this.alias){return new ast.MatchAs(\nnew ast.MatchAs(undefined,pattern),this.alias)}\nreturn new ast.MatchAs(undefined,pattern)}catch(err){console.log('error capture ast')\nshow_line(this)\nthrow err}}\n$PatternCaptureCtx.prototype.bindings=function(){var bindings=this.tree[0]=='_' ?[]:this.tree.slice()\nif(this.alias){bindings.push(this.alias)}\nreturn bindings}\n$PatternCaptureCtx.prototype.transition=function(token,value){var C=this\nswitch(C.expect){case '.':\nif(token=='.'){C.type=\"value_pattern\"\nC.expect='id'\nif(C.tree.length==1){\nnew $IdCtx(C,C.tree.pop())}else{C.tree.push('.')}\nreturn C}else if(token=='('){\nreturn new $PatternCtx(new $PatternClassCtx(C))}else if(C.parent instanceof $PatternMappingCtx){return C.parent.transition(token,value)}else{C.expect='as'\nreturn C.transition(token,value)}\ncase 'as':\ncase 'alias':\nvar res=as_pattern(C,token,value)\nreturn res\ncase 'id':\nif(token=='id'){C.tree.push(value)\nC.expect='.'\nreturn C}}\nreturn $transition(C.parent,token,value)}\n$PatternCaptureCtx.prototype.to_js=function(){var js\nif(this.tree.length==1){js='{capture'\nif(this.starred==true){js+='_starred'}\njs+=`: '${this.tree[0]}'`}else{js=this.tree[0].to_js()\nfor(var i=1,len=this.tree.length;i < len;i+=2){js='$B.$getattr('+js+', \"'+this.tree[i]+'\")'}\njs=`{value: ${js}`}\nif(this.alias){js+=`, alias: '${this.alias}'`}\nreturn js+'}'}\n$PatternClassCtx=function(C){this.type=\"class_pattern\"\nthis.tree=[]\nthis.parent=C.parent\nthis.class_id=new $IdCtx(C,C.tree[0])\nC.tree.pop()\nthis.attrs=C.tree.slice(2)\nC.parent.tree.pop()\nC.parent.tree.push(this)\nthis.expect=','\nthis.keywords=[]\nthis.positionals=[]\nthis.bound_names=[]}\n$PatternClassCtx.prototype.ast=function(){\nvar cls=new ast.Name(this.class_id.value),patterns=[],kwd_attrs=[],kwd_patterns=[]\nfor(var item of this.tree){if(item.is_keyword){kwd_attrs.push(item.tree[0])\nkwd_patterns.push(ast_or_obj(item.tree[1]))}else{try{patterns.push(ast_or_obj(item))}catch(err){console.log('error in class pattern item')\nshow_line(this)\nthrow err}}}\nreturn new ast.MatchClass(cls,patterns,kwd_attrs,kwd_patterns)}\n$PatternClassCtx.prototype.bindings=function(){var bindings=this.bound_names\nif(this.alias){bindings.push(this.alias)}\nreturn bindings}\n$PatternClassCtx.prototype.transition=function(token,value){var C=this\nfunction check_last_arg(){var last=$B.last(C.tree),bound\nif(last instanceof $PatternCaptureCtx){if(! last.is_keyword &&\nC.keywords.length > 0){$_SyntaxError(C,'positional argument after keyword')}\nif(last.is_keyword){if(C.keywords.indexOf(last.tree[0])>-1){$_SyntaxError(C,[`keyword argument repeated: ${last.tree[0]}`])}\nC.keywords.push(last.tree[0])\nbound=last.tree[1].bindings()}else{bound=last.bindings()}\nfor(var b of bound){if(C.bound_names.indexOf(b)>-1){$_SyntaxError(C,['multiple assignments '+\n`to name '${b}' in pattern`])}}\nC.bound_names=C.bound_names.concat(bound)}}\nswitch(this.expect){case ',':\nswitch(token){case '=':\nvar current=$B.last(this.tree)\nif(current instanceof $PatternCaptureCtx){\nif(this.keywords.indexOf(current.tree[0])>-1){$_SyntaxError(C,['attribute name repeated in class pattern: '+\ncurrent.tree[0]])}\ncurrent.is_keyword=true\nreturn new $PatternCtx(current)}\n$_SyntaxError(this,'= after non-capture')\ncase ',':\ncheck_last_arg()\nreturn new $PatternCtx(this)\ncase ')':\ncheck_last_arg()\nif($B.last(this.tree).tree.length==0){this.tree.pop()}\nC.expect='as'\nreturn C\ndefault:\n$_SyntaxError(this)}\ncase 'as':\ncase 'alias':\nreturn as_pattern(C,token,value)}\nreturn $transition(C.parent,token,value)}\n$PatternClassCtx.prototype.to_js=function(){var i=0,args=[],kwargs=[]\nvar klass=this.class_id.to_js()\nfor(var i=0,len=this.attrs.length;i < len;i+=2){klass='$B.$getattr('+klass+', \"'+this.attrs[i]+'\")'}\ni=0\nfor(var item of this.tree){if(item instanceof $PatternCaptureCtx && item.tree.length > 1){kwargs.push(item.tree[0]+': '+item.tree[1].to_js())}else{args.push(item.to_js())}}\nvar js='{class: '+klass+', args: ['+args.join(', ')+'], '+\n'keywords: {'+kwargs.join(', ')+'}'\nif(this.alias){js+=`, alias: \"${this.alias}\"`}\nreturn js+'}'}\nvar $PatternGroupCtx=function(C){\nthis.type=\"group_pattern\"\nthis.parent=C\nthis.tree=[]\nvar first_pattern=C.tree.pop()\nthis.expect=',|'\nC.tree.push(this)}\nfunction remove_empty_pattern(C){var last=$B.last(C.tree)\nif(last && last instanceof $PatternCtx &&\nlast.tree.length==0){C.tree.pop()}}\n$PatternGroupCtx.prototype.ast=function(){if(this.tree.length==1){return ast_or_obj(this.tree[0])}else{return $PatternSequenceCtx.prototype.ast.bind(this)()}}\n$PatternGroupCtx.prototype.bindings=function(){var bindings=[]\nfor(var item of this.tree){bindings=bindings.concat(item.bindings())}\nif(this.alias){bindings.push(this.alias)}\nreturn bindings}\n$PatternGroupCtx.prototype.transition=function(token,value){var C=this\nswitch(C.expect){case ',|':\nif(token==\")\"){\nremove_empty_pattern(C)\nC.expect='as'\nreturn C}else if(token==','){C.expect='id'\nC.is_tuple=true\nreturn C}else if(token=='op' && value=='|'){var opctx=new $PatternOrCtx(C.parent)\nopctx.parenthese=true\nreturn new $PatternCtx(opctx)}else if(this.token===undefined){return $transition(C.parent,token,value)}\n$_SyntaxError(C)\ncase 'as':\ncase 'alias':\nreturn as_pattern(C,token,value)\ncase 'id':\nif(token==')'){\nremove_empty_pattern(C)\nC.expect='as'\nreturn C}\nC.expect=',|'\nreturn $transition(new $PatternCtx(C),token,value)}\nconsole.log('error',this,token,value)\n$_SyntaxError(C,'token '+token+' after '+C)}\n$PatternGroupCtx.prototype.to_js=function(){if(this.is_tuple){var js='{sequence: ['+$to_js(this.tree)+']'}else{var js='{group: ['+$to_js(this.tree)+']'}\nif(this.alias){js+=`, alias: \"${this.alias}\"`}\nreturn js+'}'}\nvar $PatternLiteralCtx=function(C,token,value,sign){\nthis.type=\"literal_pattern\"\nthis.parent=C.parent\nC.parent.tree.pop()\nC.parent.tree.push(this)\nif(token.sign){this.tree=[{sign:token.sign}]\nthis.expect='number'}else{if(token=='str'){this.tree=[]\nnew $StringCtx(this,value)}else if(token=='JoinedStr'){$_SyntaxError(this,[\"patterns cannot include f-strings\"])}else{this.tree=[{type:token,value,sign}]}\nthis.expect='op'}}\n$PatternLiteralCtx.prototype.ast=function(){try{var first=this.tree[0],result\nif(first.type=='str'){result=new ast.MatchValue(new ast.Constant(first.value))}else if(first.type=='id'){result=new ast.MatchSingleton(first.value)}else{var num=$NumberCtx.prototype.ast.bind(first)(),res=new ast.MatchValue(num)\nif(this.tree.length==1){result=res}else{var num2=$NumberCtx.prototype.ast.bind(this.tree[2])()\nresult=new ast.BinOp(res,this.tree[1]=='+' ? ast.Add :ast.Sub,num2)}}\nif(this.tree.length==2){\nresult=new ast.MatchValue(new ast.BinOp(\nast_or_obj(this.tree[0]),C.num_sign=='+' ? ast.Add :ast.Sub,ast_or_obj(this.tree[1])))}\nif(this.alias){return new ast.MatchAs(result,this.alias)}\nreturn result}catch(err){console.log('error pattern literal ast',this)\nshow_line(this)\nthrow err}}\n$PatternLiteralCtx.prototype.bindings=function(){if(this.alias){return[this.alias]}\nreturn[]}\n$PatternLiteralCtx.prototype.transition=function(token,value){var C=this\nswitch(C.expect){case 'op':\nif(token==\"op\"){switch(value){case '+':\ncase '-':\nif(['int','float'].indexOf(C.tree[0].type)>-1){C.expect='imaginary'\nthis.tree.push(value)\nC.num_sign=value\nreturn C}\n$_SyntaxError(C,['patterns cannot include operators'])\ndefault:\nreturn $transition(C.parent,token,value)}}\nbreak\ncase 'number':\nswitch(token){case 'int':\ncase 'float':\ncase 'imaginary':\nvar last=$B.last(C.tree)\nif(this.tree.token===undefined){\nlast.type=token\nlast.value=value\nC.expect='op'\nreturn C}\ndefault:\n$_SyntaxError(C)}\ncase 'imaginary':\nswitch(token){case 'imaginary':\nC.tree.push({type:token,value,sign:C.num_sign})\nreturn C.parent\ndefault:\n$_SyntaxError(C,'expected imaginary')}\ncase 'as':\ncase 'alias':\nreturn as_pattern(C,token,value)}\nif(token=='as' && C.tree.length==1){C.expect='as'\nreturn C.transition(token,value)}\nreturn $transition(C.parent,token,value)}\n$PatternLiteralCtx.prototype.to_js=function(){function int_to_num(item){var v=parseInt(item.value[1],item.value[0])\nreturn item.sign=='-' ?-v :v}\nvar res='',first=this.tree[0],num_value\nif(first instanceof $StringCtx){res=first.to_js()}else{switch(first.type){case 'id':\nres='_b_.'+first.value\nnum_value=first.value=='True' ? 1 :0\nbreak\ncase 'str':\nres=first.value\nbreak\ncase 'int':\nres=int_to_num(first)\nbreak\ncase 'float':\nres=(first.sign=='-' ? '-' :'')+first.value\nbreak\ncase 'imaginary':\nres+='$B.make_complex(0, '+\n(first.sign=='-' ? '-' :'')+first.value+')'\nif(first.value==0){num_value=0}\nbreak}}\nif(this.tree.length > 1){res='$B.make_complex('+res+','+\n(this.tree[1]=='-' ? '-' :'')+\nthis.tree[2].value+')'}\nthis.js_value=res\nthis.num_value=num_value===undefined ? res :num_value\nvar js='{literal: '+res\nif(this.alias){js+=`, alias: '${this.alias}'`}\nreturn js+'}'}\nvar $PatternMappingCtx=function(C){\nthis.type=\"mapping_pattern\"\nthis.parent=C\nC.tree.pop()\nthis.tree=[]\nC.tree.push(this)\nthis.expect='key_value_pattern'\nthis.duplicate_keys=[]\nthis.bound_names=[]}\n$PatternMappingCtx.prototype.ast=function(){\nvar keys=[],patterns=[]\nfor(var item of this.tree){keys.push(ast_or_obj(item.tree[0]))\npatterns.push(ast_or_obj(item.tree[1]))}\nvar res=new ast.MatchMapping(keys,patterns)\nif(this.double_star){res.rest=this.double_star.tree[0]}\nreturn res}\n$PatternMappingCtx.prototype.bindings=function(){var bindings=[]\nfor(var item of this.tree){bindings=bindings.concat(item.bindings())}\nif(this.rest){bindings=bindings.concat(this.rest.bindings())}\nif(this.alias){bindings.push(this.alias)}\nreturn bindings}\n$PatternMappingCtx.prototype.transition=function(token,value){var C=this\nfunction check_duplicate_names(){var last=$B.last(C.tree),bindings\nif(last instanceof $PatternKeyValueCtx){if(C.double_star){\nC.$pos=C.double_star.$pos\n$_SyntaxError(C,[\"can't use starred name here (consider moving to end)\"])}\nif(last.tree[0].type=='value_pattern'){bindings=last.tree[2].bindings()}else{bindings=last.tree[1].bindings()}\nfor(var binding of bindings){if(C.bound_names.indexOf(binding)>-1){$_SyntaxError(C,[`multiple assignments to name '${binding}'`+\n' in pattern'])}}\nC.bound_names=C.bound_names.concat(bindings)}}\nswitch(C.expect){case 'key_value_pattern':\nif(token=='}' ||token==','){\ncheck_duplicate_names()\nif(C.double_star){var ix=C.tree.indexOf(C.double_star)\nif(ix !=C.tree.length-1){C.$pos=C.double_star.$pos\n$_SyntaxError(C,[\"can't use starred name here (consider moving to end)\"])}\nC.rest=C.tree.pop()}\nreturn token==',' ? C :C.parent}\nif(token=='op' && value=='**'){C.expect='capture_pattern'\nreturn C}\nvar p=new $PatternCtx(C)\ntry{var lit_or_val=p.transition(token,value)}catch(err){$_SyntaxError(C,[\"mapping pattern keys may only \"+\n\"match literals and attribute lookups\"])}\nif(lit_or_val instanceof $PatternLiteralCtx){C.tree.pop()\nfor(var kv of C.tree){if(kv instanceof $PatternKeyValueCtx){var key=kv.tree[0]\nif(key instanceof $PatternLiteralCtx){var old_lit=key.tree[0],new_lit=lit_or_val.tree[0]\nkey.to_js()\nlit_or_val.to_js()\nkey_value=key.num_value\nlit_or_val_value=lit_or_val.num_value\nif(key_value==lit_or_val_value){$_SyntaxError(C,[\"duplicate literal key \"+\nlit_or_val_value])}}}}\nnew $PatternKeyValueCtx(C,lit_or_val)\nreturn lit_or_val}else if(lit_or_val instanceof $PatternCaptureCtx){C.has_value_pattern_keys=true\nC.tree.pop()\nnew $PatternKeyValueCtx(C,lit_or_val)\nC.expect='.'\nreturn this}else{console.log('lit_or_val',lit_or_val)\n$_SyntaxError(C,'expected key or **')}\ncase 'capture_pattern':\nvar p=new $PatternCtx(C)\nvar capture=$transition(p,token,value)\nif(capture instanceof $PatternCaptureCtx){if(C.double_star){C.$pos=capture.$pos\n$_SyntaxError(C,[\"only one double star pattern is accepted\"])}\nif(value=='_'){$_SyntaxError(C,'**_ is not valid')}\nif(C.bound_names.indexOf(value)>-1){$_SyntaxError(C,['duplicate binding: '+value])}\nC.bound_names.push(value)\ncapture.double_star=true\nC.double_star=capture\nC.expect=','\nreturn C}else{$_SyntaxError(this,'expected identifier')}\ncase ',':\nif(token==','){C.expect='key_value_pattern'\nreturn C}else if(token=='}'){C.expect='key_value_pattern'\nreturn C.transition(token,value)}\n$_SyntaxError(C,'token '+token+'after C '+C)\ncase '.':\nif(C.tree.length > 0){var last=$B.last(C.tree)\nif(last instanceof $PatternKeyValueCtx){\nnew $IdCtx(last,last.tree[0].tree[0])\nC.expect='key_value_pattern'\nreturn $transition(last.tree[0],token,value)}}\n$_SyntaxError(C,'token '+token+'after '+C)}\nreturn $transition(C.parent,token,value)}\n$PatternMappingCtx.prototype.to_js=function(){var js='{mapping: ['+$to_js(this.tree)+']'\nif(this.rest){js+=\", rest: '\"+this.rest.tree[0]+\"'\"}\nreturn js+'}'}\nvar $PatternKeyValueCtx=function(C,literal_or_value){this.type=\"pattern_key_value\"\nthis.parent=C\nthis.tree=[literal_or_value]\nliteral_or_value.parent=this\nthis.expect=':'\nC.tree.push(this)}\n$PatternKeyValueCtx.prototype.bindings=$PatternMappingCtx.prototype.bindings\n$PatternKeyValueCtx.prototype.transition=function(token,value){var C=this\nswitch(C.expect){case ':':\nswitch(token){case ':':\nthis.expect=','\nreturn new $PatternCtx(this)\ndefault:\nconsole.log('keyvalue',C,'expected :, got',token,value)\n$_SyntaxError(C,'expected :')}\ncase ',':\nswitch(token){case '}':\nreturn $transition(C.parent,token,value)\ncase ',':\nC.parent.expect='key_value_pattern'\nreturn $transition(C.parent,token,value)\ncase 'op':\nif(value=='|'){\nreturn new $PatternCtx(new $PatternOrCtx(C))}}\n$_SyntaxError(C,'expected , or }')}\nreturn $transition(C.parent,token,value)}\n$PatternKeyValueCtx.prototype.to_js=function(){var key,value\nif(this.tree[0].type=='value_pattern'){\nkey=this.tree[1].to_js()\nfor(var i=2,len=this.tree[0].tree.length;i < len;i+=2){key='$B.$getattr('+key+', \"'+this.tree[0].tree[i]+'\")'}\nkey='{value: '+key+'}'\nvalue=this.tree[2].to_js()}else{key=this.tree[0].to_js()\nvalue=this.tree[1].to_js()}\nreturn '['+key+','+value+']'}\nvar $PatternOrCtx=function(C){\nthis.type=\"or_pattern\"\nthis.parent=C\nvar first_pattern=C.tree.pop()\nif(first_pattern instanceof $PatternGroupCtx &&\nfirst_pattern.expect !='as'){\nfirst_pattern=first_pattern.tree[0]}\nthis.tree=[first_pattern]\nfirst_pattern.parent=this\nthis.expect='|'\nC.tree.push(this)\nthis.check_reachable()}\n$PatternOrCtx.prototype.ast=function(){\nreturn new ast.MatchOr(this.tree.map(ast_or_obj))}\n$PatternOrCtx.prototype.bindings=function(){var names\nfor(var subpattern of this.tree){if(subpattern.bindings===undefined){console.log('no binding',subpattern)}\nvar subbindings=subpattern.bindings()\nif(names===undefined){names=subbindings}else{for(var item of names){if(subbindings.indexOf(item)==-1){$_SyntaxError(this,[\"alternative patterns bind different names\"])}}\nfor(var item of subbindings){if(names.indexOf(item)==-1){$_SyntaxError(this,[\"alternative patterns bind different names\"])}}}}\nif(this.alias){return names.concat(this.alias)}\nreturn names}\n$PatternOrCtx.prototype.check_reachable=function(){\nvar item=$B.last(this.tree)\nvar capture\nif(item.type=='capture_pattern'){capture=item.tree[0]}else if(item.type=='group_pattern' && item.tree.length==1 &&\nitem.tree[0].type=='capture_pattern'){capture=item.tree[0].tree[0]}else if(item instanceof $PatternOrCtx){item.check_reachable()}\nif(capture){var msg=capture=='_' ? 'wildcard' :\n`name capture '${capture}'`\n$_SyntaxError(this,[`${msg} makes remaining patterns unreachable`])}}\n$PatternOrCtx.prototype.transition=function(token,value){function set_alias(){\nvar last=$B.last(C.tree)\nif(last.alias){C.alias=last.alias\ndelete last.alias}}\nvar C=this\nif(['as','alias'].indexOf(C.expect)>-1){return as_pattern(C,token,value)}\nif(token=='op' && value==\"|\"){\nfor(var item of C.tree){if(item.alias){$_SyntaxError(C,'no as pattern inside or pattern')}}\nC.check_reachable()\nreturn new $PatternCtx(C)}else if(token==')' && C.parenthese){set_alias()\nC.bindings()\ndelete C.parenthese\nC.expect='as'\nreturn C}\nset_alias()\nC.bindings()\nreturn $transition(C.parent,token,value)}\n$PatternOrCtx.prototype.to_js=function(){var res='{or : ['+$to_js(this.tree)+']'\nif(this.alias){res+=`, alias: '${this.alias}'`}\nreturn res+'}'}\nvar $PatternSequenceCtx=function(C,token){\nthis.type=\"sequence_pattern\"\nthis.parent=C\nthis.tree=[]\nthis.bound_names=[]\nvar first_pattern=C.tree.pop()\nif(token===undefined){\nthis.bound_names=first_pattern.bindings()\nthis.tree=[first_pattern]\nif(first_pattern.starred){this.has_star=true}\nfirst_pattern.parent=this}else{\nthis.token=token}\nthis.expect=','\nC.tree.push(this)}\n$PatternSequenceCtx.prototype.ast=function(){return new ast.MatchSequence(this.tree.map(ast_or_obj))}\n$PatternSequenceCtx.prototype.bindings=$PatternMappingCtx.prototype.bindings\n$PatternSequenceCtx.prototype.transition=function(token,value){function check_duplicate_names(){var last=$B.last(C.tree)\nif(!(last instanceof $PatternCtx)){\nvar last_bindings=last.bindings()\nfor(var b of last_bindings){if(C.bound_names.indexOf(b)>-1){$_SyntaxError(C,[\"multiple assignments to name '\"+\nb+\"' in pattern\"])}}\nif(last.starred){if(C.has_star){$_SyntaxError(C,['multiple starred names in sequence pattern'])}\nC.has_star=true}\nC.bound_names=C.bound_names.concat(last_bindings)}}\nvar C=this\nif(C.expect==','){if((C.token=='[' && token==']')||\n(C.token=='(' && token==\")\")){\nvar nb_starred=0\nfor(var item of C.tree){if(item instanceof $PatternCaptureCtx && item.starred){nb_starred++\nif(nb_starred > 1){$_SyntaxError(C,['multiple starred names in sequence pattern'])}}}\nC.expect='as'\ncheck_duplicate_names()\nremove_empty_pattern(C)\nreturn C}else if(token==','){check_duplicate_names()\nC.expect='id'\nreturn C}else if(token=='op' && value=='|'){\nremove_empty_pattern(C)\nreturn new $PatternCtx(new $PatternOrCtx(C))}else if(this.token===undefined){\ncheck_duplicate_names()\nreturn $transition(C.parent,token,value)}\n$_SyntaxError(C)}else if(C.expect=='as'){if(token=='as'){this.expect='alias'\nreturn C}\nreturn $transition(C.parent,token,value)}else if(C.expect=='alias'){if(token='id'){C.alias=value\nreturn C.parent}\n$_SyntaxError(C,'expected alias')}else if(C.expect=='id'){C.expect=','\nreturn $transition(new $PatternCtx(C),token,value)}}\n$PatternSequenceCtx.prototype.to_js=function(){var js='{sequence: ['+$to_js(this.tree)+']'\nif(this.alias){js+=`, alias: '${this.alias}'`}\nreturn js+'}'}\nvar $RaiseCtx=$B.parser.$RaiseCtx=function(C){\nthis.type='raise'\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this\nthis.scope_type=$get_scope(this).ntype}\n$RaiseCtx.prototype.ast=function(){\nreturn new ast.Raise(...this.tree.map(ast_or_obj))}\n$RaiseCtx.prototype.toString=function(){return ' (raise) '+this.tree}\n$RaiseCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\nif(C.tree.length==0){return new $IdCtx(new $ExprCtx(C,'exc',false),value)}\nbreak\ncase 'from':\nif(C.tree.length > 0){return new $AbstractExprCtx(C,false)}\nbreak\ncase 'eol':\nremove_abstract_expr(this.tree)\nreturn $transition(C.parent,token)}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$RaiseCtx.prototype.to_js=function(){this.js_processed=true\nvar exc=this.tree.length==0 ? '' :this.tree[0].to_js()\nreturn '$B.$raise('+exc+')'}\nvar $RawJSCtx=$B.parser.$RawJSCtx=function(C,js){this.type=\"raw_js\"\nC.tree[C.tree.length]=this\nthis.parent=C\nthis.js=js}\n$RawJSCtx.prototype.toString=function(){return '(js) '+this.js}\n$RawJSCtx.prototype.transition=function(token,value){var C=this}\n$RawJSCtx.prototype.to_js=function(){this.js_processed=true\nreturn this.js}\nvar $ReturnCtx=$B.parser.$ReturnCtx=function(C){\nthis.type='return'\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this\nthis.scope=$get_scope(this)\nif([\"def\",\"generator\"].indexOf(this.scope.ntype)==-1){$_SyntaxError(C,[\"'return' outside function\"])}\nvar node=this.node=$get_node(this)\nwhile(node.parent){if(node.parent.C){var elt=node.parent.C.tree[0]\nif(elt.type=='for'){elt.has_return=true\nbreak}else if(elt.type=='try'){elt.has_return=true}else if(elt.type=='single_kw' && elt.token=='finally'){elt.has_return=true}}\nnode=node.parent}}\n$ReturnCtx.prototype.ast=function(){var res=new ast.Return()\nif(this.tree.length > 0){res.value=ast_or_obj(this.tree[0])}\nreturn res}\n$ReturnCtx.prototype.toString=function(){return 'return '+this.tree}\n$ReturnCtx.prototype.transition=function(token,value){var C=this\nif(token=='eol' && this.tree.length==1 &&\nthis.tree[0].type=='abstract_expr'){\nthis.tree.pop()}\nreturn $transition(C.parent,token)}\n$ReturnCtx.prototype.to_js=function(){this.js_processed=true\nvar expr=this.tree.length==0 ? '_b_.None' :$to_js(this.tree)\nvar scope=this.scope\nif(scope.ntype=='generator'){return 'var $res = '+expr+'; $B.leave_frame({$locals});'+\n'return $B.generator_return($res)'}\nvar indent='    '.repeat(this.node.indent-1)\nvar js='var $res = '+expr+';\\n'+indent+\n'if($locals.$f_trace !== _b_.None){\\n$B.trace_return($res)}\\n'+indent+\n'$B.leave_frame'\nif(scope.id.substr(0,6)=='$exec_'){js+='_exec'}\njs+='({$locals});\\n'\nif(this.is_await){js+=indent+'$B.restore_stack(save_stack, $locals)\\n'}\njs+=indent+'return $res'\nreturn js}\nvar SetCompCtx=function(C){\nthis.type='setcomp'\nthis.tree=[C.tree[0]]\nthis.tree[0].parent=this\nComprehension.make_comp(this,C)}\nSetCompCtx.prototype.ast=function(){\nreturn new ast.SetComp(\nast_or_obj(this.tree[0]),Comprehension.generators(this.tree.slice(1))\n)}\nSetCompCtx.prototype.transition=function(token,value){var C=this\nif(token=='}'){this.has_await=Comprehension.has_await(this)\nreturn this.parent}\n$_SyntaxError(C,'token '+token+'after list comp')}\nSetCompCtx.prototype.to_js=function(){var node=$get_node(this),indent=node.get_indent()\nvar id=this.id,expr=this.tree[0],first_for=this.tree[1],outmost_expr=first_for.tree[1].to_js()\nfirst_for.comp_body=true\nfirst_for.iterable_is_outermost=true\nvar module_id=this.module.replace(/\\./g,'_')\nvar js=`(${this.has_await ? 'async ' : ''}function(expr){`+\nComprehension.admin_infos(this)+\n`\\nvar $result_${id} = _b_.set.$factory()\\n`\njs+=first_for.to_js(indent)\nvar nb=-1\nfor(var i=2;i < this.tree.length;i++){nb++\nvar stmt=this.tree[i]\nif(stmt.type=='for'){stmt.comp_body=true\njs+='\\n'+stmt.to_js(indent+nb)}else if(stmt.type=='condition' && stmt.token=='if'){js+='\\n'+' '.repeat(12+4*nb)+stmt.to_js()+'{'}}\nvar expr_has_await=Comprehension.has_await(expr)\njs+='\\n'+' '.repeat(16+4*nb)+\n(expr_has_await ? 'var save_stack = $B.save_stack();\\n' :'')+\n`try{\\n_b_.set.add($result_${id}, ${expr.to_js()})\\n`+\n`}catch(err){\\n`+\n(expr_has_await ? '$B.restore_stack(save_stack, $locals);' :'')+\n`$B.leave_frame($locals); throw err\\n`+\n'\\n}'+(expr_has_await ? '$B.restore_stack(save_stack, $locals);' :'')\nfor(var i=1;i < this.tree.length;i++){js+='\\n'+' '.repeat(12+4*nb--)+'}'}\njs+=`\\n$B.leave_frame({$locals, value: _b_.None})`\njs+=`\\nreturn $result_${id}`\njs+=`\\n}\\n)(${outmost_expr})`\nreturn js}\nvar $SingleKwCtx=$B.parser.$SingleKwCtx=function(C,token){\nthis.type='single_kw'\nthis.token=token\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this\nif(token==\"else\"){var node=C.node,rank=node.parent.children.indexOf(node),pctx=node.parent.children[rank-1].C\npctx.tree[0].orelse=this\nif(pctx.tree.length > 0){var elt=pctx.tree[0]\nif(elt.type=='for' ||\nelt.type=='asyncfor' ||\n(elt.type=='condition' && elt.token=='while')){elt.has_break=true\nelt.else_node=$get_node(this)\nthis.loop_num=elt.loop_num}}}}\n$SingleKwCtx.prototype.ast=function(){return ast_body(this.parent)}\n$SingleKwCtx.prototype.toString=function(){return this.token}\n$SingleKwCtx.prototype.transition=function(token,value){var C=this\nif(token==':'){return $BodyCtx(C)}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$SingleKwCtx.prototype.transform=function(node,rank){\nif(this.token=='finally'){var scope=$get_scope(this)\nnode.insert(0,$NodeJS('var $exit;'+\n'if($B.frames_stack.length < $stack_length){\\n'+\n'$exit = true;'+\n'$B.frames_stack.push($top_frame)'+\n'}')\n)\nvar scope_id=scope.id.replace(/\\./g,'_')\nvar last_child=node.children[node.children.length-1]\nif(last_child.C.tree[0].type !=\"return\"){node.add($NodeJS('if($exit){\\n$B.leave_frame({$locals})}'))}}}\n$SingleKwCtx.prototype.to_js=function(){this.js_processed=true\nif(this.token=='finally'){return this.token}\nif(this.loop_num !==undefined){return 'if($no_break'+this.loop_num+')'}\nreturn this.token}\nvar $SliceCtx=$B.parser.$SliceCtx=function(C){\nthis.type='slice'\nthis.parent=C\nthis.tree=C.tree.length > 0 ?[C.tree.pop()]:[]\nC.tree.push(this)}\n$SliceCtx.prototype.ast=function(){var slice=new ast.Slice()\nvar attrs=['lower','upper','step']\nfor(var i=0;i < this.tree.length;i++){var item=this.tree[i]\nif(item.type !=='abstract_expr'){slice[attrs[i]]=ast_or_obj(item)}}\nreturn slice}\n$SliceCtx.prototype.transition=function(token,value){var C=this\nif(token==\":\"){return new $AbstractExprCtx(C,false)}\nreturn $transition(C.parent,token,value)}\n$SliceCtx.prototype.to_js=function(){for(var i=0;i < this.tree.length;i++){if(this.tree[i].type==\"abstract_expr\"){this.tree[i].to_js=function(){return \"_b_.None\"}}}\nreturn \"_b_.slice.$factory(\"+$to_js(this.tree)+\")\"}\nvar $StarArgCtx=$B.parser.$StarArgCtx=function(C){\nthis.type='star_arg'\nthis.parent=C\nthis.tree=[]\nC.tree[C.tree.length]=this}\n$StarArgCtx.prototype.toString=function(){return '(star arg) '+this.tree}\n$StarArgCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\nif(C.parent.type==\"target_list\"){C.tree.push(value)\nC.parent.expect=','\nreturn C.parent}\nreturn $transition(new $AbstractExprCtx(C,false),token,value)\ncase 'imaginary':\ncase 'int':\ncase 'float':\ncase 'str':\ncase 'JoinedStr':\ncase 'bytes':\ncase '[':\ncase '(':\ncase '{':\ncase 'not':\ncase 'lambda':\nreturn $transition(new $AbstractExprCtx(C,false),token,value)\ncase ',':\ncase ')':\nif(C.tree.length==0){$_SyntaxError(C,\"unnamed star argument\")}\nreturn $transition(C.parent,token)\ncase ':':\nif(C.parent.parent.type=='lambda'){return $transition(C.parent.parent,token)}}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$StarArgCtx.prototype.to_js=function(){this.js_processed=true\nreturn '{$nat:\"ptuple\",arg:'+$to_js(this.tree)+'}'}\nvar $StringCtx=$B.parser.$StringCtx=function(C,value){\nthis.type='str'\nthis.parent=C\nfunction prepare(value){value=value.replace(/\\n/g,'\\\\n\\\\\\n')\nvalue=value.replace(/\\r/g,'\\\\r\\\\\\r')\nreturn value}\nthis.is_bytes=value.charAt(0)=='b'\nif(! this.is_bytes){this.value=prepare(value)}else{this.value=prepare(value.substr(1))}\nC.tree.push(this)\nthis.tree=[this.value]\nthis.raw=false\nthis.$pos=$pos}\n$StringCtx.prototype.ast=function(){var value\nif(! this.is_bytes){try{value=eval(this.value)}catch(err){console.log('error str ast',this.value)\nthrow err}}else{value=_b_.bytes.$new(_b_.bytes,eval(this.value),'ISO-8859-1')}\nreturn new ast.Constant(value)}\n$StringCtx.prototype.toString=function(){return 'string '+(this.value ||'')}\n$StringCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case '[':\nreturn new $AbstractExprCtx(new $SubCtx(C.parent),false)\ncase '(':\nC.parent.tree[0]=C\nreturn new $CallCtx(C.parent)\ncase 'str':\nif((this.is_bytes && ! value.startsWith('b'))||\n(! this.is_bytes && value.startsWith('b'))){C.$pos=$pos\n$_SyntaxError(C,[\"cannot mix bytes and nonbytes literals\"])}\nC.value+=' + '+(this.is_bytes ? value.substr(1):value)\nreturn C\ncase 'JoinedStr':\nC.parent.tree.pop()\nvar joined_str=new JoinedStrCtx(C.parent,value)\nif(typeof joined_str.tree[0]==\"string\"){joined_str.tree[0]=eval(this.value)+joined_str.tree[0]}else{joined_str.tree.splice(0,0,this)}\nreturn joined_str}\nreturn $transition(C.parent,token,value)}\n$StringCtx.prototype.to_js=function(){this.js_processed=true\nif(! this.is_bytes){return \"$B.String(\"+this.value+\")\"}else{return '_b_.bytes.$new(_b_.bytes, '+this.value+\", 'ISO-8859-1')\"}}\nvar $SubCtx=$B.parser.$SubCtx=function(C){\nthis.type='sub'\nthis.func='getitem' \nthis.value=C.tree[0]\nC.tree.pop()\nC.tree[C.tree.length]=this\nthis.parent=C\nthis.tree=[]}\n$SubCtx.prototype.ast=function(){var slice=ast_or_obj(this.tree[0])\nreturn new ast.Subscript(ast_or_obj(this.value),slice,new ast.Load())}\n$SubCtx.prototype.toString=function(){return '(sub) (value) '+this.value+' (tree) '+this.tree}\n$SubCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\ncase 'imaginary':\ncase 'int':\ncase 'float':\ncase 'str':\ncase 'JoinedStr':\ncase 'bytes':\ncase '[':\ncase '(':\ncase '{':\ncase '.':\ncase 'not':\ncase 'lambda':\nvar expr=new $AbstractExprCtx(C,false)\nreturn $transition(expr,token,value)\ncase ']':\nif(C.parent.packed){return C.parent }\nif(C.tree[0].tree.length > 0){return C.parent}\nbreak\ncase ':':\nreturn new $AbstractExprCtx(new $SliceCtx(C),false)\ncase ',':\nreturn new $AbstractExprCtx(C,false)}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$SubCtx.prototype.to_js=function(){this.js_processed=true\nif(this.func=='getitem' && this.value.type=='id'){var type=$get_node(this).locals[this.value.value],val=this.value.to_js()\nif(type=='list' ||type=='tuple'){if(this.tree.length==1){return '$B.list_key('+val+\n', '+this.tree[0].to_js()+')'}else if(this.tree.length==2){return '$B.list_slice('+val+\n', '+(this.tree[0].to_js()||\"null\")+','+\n(this.tree[1].to_js()||\"null\")+')'}else if(this.tree.length==3){return '$B.list_slice_step('+val+\n', '+(this.tree[0].to_js()||\"null\")+','+\n(this.tree[1].to_js()||\"null\")+','+\n(this.tree[2].to_js()||\"null\")+')'}}}\nif(this.func=='getitem' && this.tree.length==1){if(this.tree[0].type==\"slice\"){return `$B.getitem_slice(${this.value.to_js()}, `+\n`${this.tree[0].to_js()})`}\nreturn '$B.$getitem('+this.value.to_js()+','+\nthis.tree[0].to_js()+')'}\nif(this.func=='delitem' && this.tree.length==1){if(this.tree[0].type==\"slice\"){return `$B.delitem_slice(${this.value.to_js()}, `+\n`${this.tree[0].to_js()})`}\nreturn '$B.$delitem('+this.value.to_js()+','+\nthis.tree[0].to_js()+')'}\nvar res='',shortcut=false\nif(this.func !=='delitem' &&\nthis.tree.length==1 && !this.in_sub){var expr='',x=this\nshortcut=true\nwhile(x.value.type=='sub'){expr+='['+x.tree[0].to_js()+']'\nx.value.in_sub=true\nx=x.value}\nvar subs=x.value.to_js()+'['+x.tree[0].to_js()+']'+\n'((Array.isArray('+x.value.to_js()+') || typeof '+\nx.value.to_js()+' == \"string\") && '+subs+\n' !== undefined ?'+subs+expr+' : '}\nvar val=this.value.to_js()\nres+='$B.$getattr('+val+',\"__'+this.func+'__\")('\nif(this.tree.length==1){res+=this.tree[0].to_js()+')'}else{var res1=[]\nfor(var elt of this.tree){if(elt.type=='abstract_expr'){res1.push('_b_.None')}\nelse{res1.push(elt.to_js())}}\nres+='_b_.tuple.$factory(['+res1.join(',')+']))'}\nreturn shortcut ? res+')' :res}\nvar $TargetListCtx=$B.parser.$TargetListCtx=function(C){\nthis.type='target_list'\nthis.parent=C\nthis.tree=[]\nthis.expect='id'\nthis.nb_packed=0\nC.tree[C.tree.length]=this}\n$TargetListCtx.prototype.ast=function(){if(this.tree.length==1){var item=ast_or_obj(this.tree[0])\nitem.ctx=new ast.Store()\nif(item instanceof ast.Tuple){for(var target of item.elts){target.ctx=new ast.Store()}}\nreturn item}else{var items=[]\nfor(var item of this.tree){item=ast_or_obj(item)\nif(item.hasOwnProperty('ctx')){item.ctx=new ast.Store()}\nitems.push(item)}\nreturn new ast.Tuple(items,new ast.Store())}}\n$TargetListCtx.prototype.toString=function(){return '(target list) '+this.tree}\n$TargetListCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\nif(C.expect=='id'){C.expect=','\nreturn new $IdCtx(\nnew $ExprCtx(C,'target',false),value)}\ncase 'op':\nif(C.expect=='id' && value=='*'){\nthis.nb_packed++\nreturn new $PackedCtx(C)}\ncase '(':\ncase '[':\nif(C.expect=='id'){C.expect=','\nreturn new $ListOrTupleCtx(C,token=='(' ? 'tuple' :'list')}\ncase ')':\ncase ']':\nif(C.expect==','){return C.parent}\ncase ',':\nif(C.expect==','){C.expect='id'\nC.implicit_tuple=true\nreturn C}}\nif(C.expect==','){return $transition(C.parent,token,value)}else if(token=='in'){\nreturn $transition(C.parent,token,value)}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$TargetListCtx.prototype.to_js=function(){this.js_processed=true\nreturn $to_js(this.tree)}\nvar $TernaryCtx=$B.parser.$TernaryCtx=function(C){\nthis.type='ternary'\nC.parent.tree.pop()\nvar expr=new $ExprCtx(C.parent,'ternary',false)\nexpr.tree.push(this)\nthis.parent=expr\nthis.tree=[C]\nC.parent=this}\n$TernaryCtx.prototype.ast=function(){\nreturn new ast.IfExp(ast_or_obj(this.tree[1]),ast_or_obj(this.tree[0]),ast_or_obj(this.tree[2]))}\n$TernaryCtx.prototype.toString=function(){return '(ternary) '+this.tree}\n$TernaryCtx.prototype.transition=function(token,value){var C=this\nif(token=='else'){C.in_else=true\nreturn new $AbstractExprCtx(C,false)}else if(! C.in_else){$_SyntaxError(C,'token '+token+' after '+C)}else if(token==\",\"){\nif([\"assign\",\"augm_assign\",\"node\",\"return\"].\nindexOf(C.parent.type)>-1){C.parent.tree.pop()\nvar t=new $ListOrTupleCtx(C.parent,'tuple')\nt.implicit=true\nt.tree[0]=C\nC.parent=t\nt.expect=\"id\"\nreturn t}}\nreturn $transition(C.parent,token,value)}\n$TernaryCtx.prototype.to_js=function(){this.js_processed=true\nvar res='$B.$bool('+this.tree[1].to_js()+') ? ' \nres+=this.tree[0].to_js()+' : ' \nreturn res+this.tree[2].to_js()}\nvar $TryCtx=$B.parser.$TryCtx=function(C){\nthis.type='try'\nthis.parent=C\nC.tree[C.tree.length]=this}\n$TryCtx.prototype.ast=function(){\nvar node=this.parent.node,res={body:ast_body(this.parent),handlers:[],orelse:[],finalbody:[]}\nvar rank=node.parent.children.indexOf(node)\nfor(var child of node.parent.children.slice(rank+1)){var t=child.C.tree[0],type=t.type\nif(type=='single_kw'){type=t.token}\nif(type=='except'){res.handlers.push(ast_or_obj(t))}else if(type=='else'){res.orelse=ast_body(child.C)}else if(type=='finally'){res.finalbody=ast_body(child.C)}else{break}}\nreturn new ast.Try(res.body,res.handlers,res.orelse,res.finalbody)}\n$TryCtx.prototype.toString=function(){return '(try) '}\n$TryCtx.prototype.transition=function(token,value){var C=this\nif(token==':'){return $BodyCtx(C)}\n$_SyntaxError(C,'token '+token+' after '+C)}\n$TryCtx.prototype.transform=function(node,rank){if(node.parent.children.length==rank+1){$_SyntaxError(node.C,[\"unexpected EOF while parsing\"])}\nvar scope=$get_scope(this)\nvar error_name=create_temp_name('$err')\nvar failed_name=\"$locals.\"+create_temp_name('$failed')\nvar js=failed_name+' = false;\\n'+\n' '.repeat(node.indent+4)+'try'\nnew $NodeJSCtx(node,js)\nnode.has_return=this.has_return\nvar catch_node=$NodeJS('catch('+error_name+')')\nnode.parent.insert(rank+1,catch_node)\ncatch_node.add($NodeJS(\"$B.set_exc(\"+error_name+\")\"))\ncatch_node.add($NodeJS(\"if($locals.$f_trace !== _b_.None)\"+\n\"{\\n$locals.$f_trace = $B.trace_exception()}\"))\ncatch_node.add(\n$NodeJS(failed_name+' = true;'+\n'$B.pmframe = $B.last($B.frames_stack);'+\n'if(false){\\n}')\n)\nvar pos=rank+2,has_default=false,\nhas_else=false,\nhas_finally=false\nwhile(1){if(pos==node.parent.children.length){break}\nvar ctx=node.parent.children[pos].C.tree[0]\nif(ctx===undefined){\nbreak}\nif(ctx.type=='except'){\nif(has_else){$_SyntaxError(C,\"'except' or 'finally' after 'else'\")}\nif(has_finally){$_SyntaxError(C,\"'except' after 'finally'\")}\nctx.error_name=error_name\nif(ctx.tree.length > 0 && ctx.tree[0].alias !==null\n&& ctx.tree[0].alias !==undefined){\nvar alias=ctx.tree[0].alias\nnode.parent.children[pos].insert(0,$NodeJS('$locals[\"'+alias+'\"] = $B.exception('+\nerror_name+')')\n)}\ncatch_node.insert(catch_node.children.length,node.parent.children[pos])\nif(ctx.tree.length==0){if(has_default){$_SyntaxError(C,'more than one except: line')}\nhas_default=true}\nnode.parent.children.splice(pos,1)}else if(ctx.type=='single_kw' && ctx.token=='finally'){has_finally=true\nvar finally_node=node.parent.children[pos]\npos++}else if(ctx.type=='single_kw' && ctx.token=='else'){if(has_else){$_SyntaxError(C,\"more than one 'else'\")}\nif(has_finally){$_SyntaxError(C,\"'else' after 'finally'\")}\nhas_else=true\nvar else_body=node.parent.children[pos]\nnode.parent.children.splice(pos,1)}else{break}}\nif(!has_default){\nvar new_node=new $Node(),ctx=new $NodeCtx(new_node)\ncatch_node.insert(catch_node.children.length,new_node)\nnew $SingleKwCtx(ctx,'else')\nnew_node.add($NodeJS('throw '+error_name))}\nif(has_else){var else_node=new $Node()\nelse_node.module=scope.module\nnew $NodeJSCtx(else_node,'if(!'+failed_name+')')\nfor(var elt of else_body.children){else_node.add(elt)}\nif(has_finally){finally_node.insert(0,else_node)}else{node.parent.insert(pos,else_node)}\npos++}\n$loop_num++}\n$TryCtx.prototype.to_js=function(){this.js_processed=true\nreturn 'try'}\nvar $UnaryCtx=$B.parser.$UnaryCtx=function(C,op){\nthis.type='unary'\nthis.op=op\nthis.parent=C\nthis.tree=[]\nC.tree.push(this)}\n$UnaryCtx.prototype.ast=function(){var op={'+':ast.UAdd,'-':ast.USub,'~':ast.Invert}[this.op]\nreturn new ast.UnaryOp(new op(),ast_or_obj(this.tree[0]))}\n$UnaryCtx.prototype.toString=function(){return '(unary) '+this.op}\n$UnaryCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'op':\nif('+'==value ||'-'==value){if(C.op===value){C.op='+'}else{C.op='-'}\nreturn C}\ncase 'int':\ncase 'float':\ncase 'imaginary':\nif(C.parent.type==\"packed\"){$_SyntaxError(C,[\"can't use starred expression here\"])}\nvar res=new $NumberCtx(token,C,value)\nconsole.log('new number after unary',res)\nalert()\nreturn res\ncase 'id':\nreturn $transition(new $AbstractExprCtx(C,false),token,value)}\nif(this.tree.length==0 ||this.tree[0].type=='abstract_expr'){$_SyntaxError(C,'token '+token+'after C'+C)}\nreturn $transition(C.parent,token,value)}\n$UnaryCtx.prototype.to_js=function(){this.js_processed=true\nvar operand=this.tree[0].tree[0]\nswitch(operand.type){case 'float':\nreturn '_b_.float.$factory('+this.op+operand.value+')'\ncase 'int':\nvar value=eval(operand.to_js())\nif(value.__class__ !=$B.long_int){return eval(this.op+value)}}\nvar method={'-':'__neg__','+':'__pos__','~':'__invert__'}[this.op]\nreturn '$B.$call($B.$getattr('+operand.to_js()+', \"'+\nmethod+'\"))()'}\nvar $WithCtx=$B.parser.$WithCtx=function(C){\nthis.type='with'\nthis.parent=C\nC.tree[C.tree.length]=this\nthis.tree=[]\nthis.expect='as'\nthis.scope=$get_scope(this)}\n$WithCtx.prototype.ast=function(){\nvar withitems=[],withitem\nfor(var item of this.tree){withitem=new ast.withitem(ast_or_obj(item.tree[0]))\nif(item.alias){withitem.optional_vars=ast_or_obj(item.alias.tree[0])\nwithitem.optional_vars.ctx=new ast.Store()}\nwithitems.push(withitem)}\nvar klass=this.async ? ast.AsyncWith :ast.With\nreturn new klass(withitems,ast_body(this.parent))}\n$WithCtx.prototype.toString=function(){return '(with) '+this.tree}\n$WithCtx.prototype.transition=function(token,value){var C=this\nswitch(token){case 'id':\nif(C.expect=='id'){C.expect='as'\nreturn $transition(\nnew $AbstractExprCtx(C,false),token,value)}\n$_SyntaxError(C,'token '+token+' after '+C)\ncase 'as':\nreturn new $AbstractExprCtx(new $AliasCtx(C))\ncase ':':\nswitch(C.expect){case 'id':\ncase 'as':\ncase ':':\nreturn $BodyCtx(C)}\nbreak\ncase '(':\nif(C.expect=='id' && C.tree.length==0){C.parenth=true\nreturn C}else if(C.expect=='alias'){C.expect=':'\nreturn new $TargetListCtx(C,false)}\nbreak\ncase ')':\nif(C.expect==',' ||C.expect=='as'){C.expect=':'\nreturn C}\nbreak\ncase ',':\nif(C.parenth !==undefined &&\nC.has_alias===undefined &&\n(C.expect==',' ||C.expect=='as')){C.expect='id'\nreturn C}else if(C.expect=='as'){C.expect='id'\nreturn C}else if(C.expect==':'){C.expect='id'\nreturn C}\nbreak}\n$_SyntaxError(C,'token '+token+' after '+\nC.expect)}\n$WithCtx.prototype.set_alias=function(ctx){var ids=[]\nif(ctx.type==\"id\"){ids=[ctx]}else if(ctx.type==\"list_or_tuple\"){\nfor(var expr of ctx.tree){if(expr.type==\"expr\" && expr.tree[0].type==\"id\"){ids.push(expr.tree[0])}}}\nfor(var i=0,len=ids.length;i < len;i++){var id_ctx=ids[i]\n$bind(id_ctx.value,this.scope,this)\nid_ctx.bound=true\nif(this.scope.ntype !=='module'){\nthis.scope.C.tree[0].locals.push(id_ctx.value)}}}\n$WithCtx.prototype.transform=function(node,rank){while(this.tree.length > 1){\nvar suite=node.children,item=this.tree.pop(),new_node=new $Node(),ctx=new $NodeCtx(new_node),with_ctx=new $WithCtx(ctx)\nitem.parent=with_ctx\nwith_ctx.tree=[item]\nwith_ctx.async=this.async\nfor(var elt of suite){new_node.add(elt)}\nnode.children=[new_node]}\nif(this.transformed){return}\nthis.prefix=\"\"\nif(this.tree.length > 1){var nw=new $Node(),ctx=new $NodeCtx(nw)\nnw.parent=node\nnw.module=node.module\nnw.indent=node.indent+4\nvar wc=new $WithCtx(ctx)\nwc.async=this.async\nwc.tree=this.tree.slice(1)\nfor(var elt of node.children){nw.add(elt)}\nnode.children=[nw]\nthis.transformed=true\nreturn}\nif(this.async){return this.transform_async(node,rank)}\nvar top_try_node=$NodeJS(\"try\")\nnode.parent.insert(rank+1,top_try_node)\nvar num=this.num=$loop_num++\ntop_try_node.ctx_manager_num=num\nthis.cm_name=this.prefix+'$ctx_manager'+num\nthis.cmexit_name=this.prefix+'$ctx_manager_exit'+num\nthis.exc_name=this.prefix+'$exc'+num\nthis.err_name='$err'+num\nthis.val_name='$value'+num\nthis.yield_name=this.prefix+'$yield'+num\nif(this.tree[0].alias===null){this.tree[0].alias='$temp'}\nif(this.tree[0].type=='expr' &&\nthis.tree[0].tree[0].type=='list_or_tuple'){if(this.tree[1].type !='expr' ||\nthis.tree[1].tree[0].type !='list_or_tuple'){$_SyntaxError(C)}\nif(this.tree[0].tree[0].tree.length !=\nthis.tree[1].tree[0].tree.length){$_SyntaxError(C,['wrong number of alias'])}\nvar ids=this.tree[0].tree[0].tree,alias=this.tree[1].tree[0].tree\nthis.tree.shift()\nthis.tree.shift()\nfor(var i=ids.length-1;i >=0;i--){ids[i].alias=alias[i].value\nthis.tree.splice(0,0,ids[i])}}\nvar block=node.children \nnode.children=[]\nvar try_node=new $Node()\nnew $NodeJSCtx(try_node,'try')\ntop_try_node.add(try_node)\nif(this.tree[0].alias){var new_node=new $Node(),ctx=new $NodeCtx(new_node)\ntry_node.add(new_node)\nthis.tree[0].alias.tree[0].parent=ctx\nvar assign=new $AssignCtx(this.tree[0].alias.tree[0])\nassign.tree.push(new $RawJSCtx(ctx,this.val_name))}\nfor(var elt of block){try_node.add(elt)}\nvar catch_node=new $Node()\nnew $NodeJSCtx(catch_node,'catch('+this.err_name+')')\nvar js=this.exc_name+' = false;'+this.err_name+\n' = $B.exception('+this.err_name+', true)\\n'+\n' '.repeat(node.indent+4)+\n'var $b = '+this.cmexit_name+'('+\nthis.err_name+'.__class__,'+\nthis.err_name+','+\n'$B.$getattr('+this.err_name+', \"__traceback__\"));'\njs+='\\nif(!$B.$bool($b)){\\nthrow '+this.err_name+'}'\ncatch_node.add($NodeJS(js))\ntop_try_node.add(catch_node)\nvar finally_node=new $Node()\nnew $NodeJSCtx(finally_node,'finally')\nfinally_node.C.type='single_kw'\nfinally_node.C.token='finally'\nfinally_node.C.in_ctx_manager=true\nfinally_node.is_except=true\nfinally_node.in_ctx_manager=true\nvar js='if('+this.exc_name\njs+='){\\n'+this.cmexit_name+'(_b_.None, _b_.None, _b_.None);'\nif(this.scope.ntype==\"generator\"){js+='delete '+this.cmexit_name}\njs+='};'\nfinally_node.add($NodeJS(js))\nnode.parent.insert(rank+2,finally_node)\nthis.transformed=true}\n$WithCtx.prototype.transform_async=function(node,rank){\nvar scope=$get_scope(this),expr=this.tree[0],alias=this.tree[0].alias\nvar new_nodes=[]\nvar num=this.num=$loop_num++\nthis.cm_name='$ctx_manager'+num,this.cmexit_name='$ctx_manager_exit'+num\nthis.exc_name='$exc'+num\nvar cmtype_name='$ctx_mgr_type'+num,cmenter_name='$ctx_manager_enter'+num,err_name='$err'+num\nvar js='var '+this.cm_name+' = $locals.'+this.cm_name+' = '+\nexpr.to_js()+','\nnew_nodes.push($NodeJS(js))\nnew_nodes.push($NodeJS('    '+cmtype_name+\n' = _b_.type.$factory('+this.cm_name+'),'))\nnew_nodes.push($NodeJS('    '+this.cmexit_name+\n' = $B.$call($B.$getattr('+cmtype_name+', \"__aexit__\")),'))\nnew_nodes.push($NodeJS('    '+cmenter_name+\n' = $B.$call($B.$getattr('+cmtype_name+', \"__aenter__\"))'+\n'('+this.cm_name+'),'))\nnew_nodes.push($NodeJS(\"    \"+this.exc_name+\" = false\"))\njs=\"\"\nif(alias){if(alias.tree[0].tree[0].type !=\"list_or_tuple\"){var js=alias.tree[0].to_js()+' = '+\n'await ($B.promise('+cmenter_name+'))'\nnew_nodes.push($NodeJS(js))}else{\nvar new_node=new $Node(),ctx=new $NodeCtx(new_node),expr=new $ExprCtx(ctx,\"left\",false)\nexpr.tree.push(alias.tree[0].tree[0])\nalias.tree[0].tree[0].parent=expr\nvar assign=new $AssignCtx(expr)\nnew $RawJSCtx(assign,'await ($B.promise('+\ncmenter_name+'))')\nnew_nodes.push(new_node)}}else{new_nodes.push($NodeJS('await ($B.promise('+cmenter_name+'))'))}\nvar try_node=new $NodeJS('try')\nfor(var child of node.children){try_node.add(child)}\nnew_nodes.push(try_node)\nvar catch_node=new $NodeJS('catch(err)')\nnew_nodes.push(catch_node)\ncatch_node.add($NodeJS(this.exc_name+' = true'))\ncatch_node.add($NodeJS('var '+err_name+\n' = $B.imported[\"_sys\"].exc_info()'))\nvar if_node=$NodeJS('if(! await ($B.promise('+\nthis.cmexit_name+'('+this.cm_name+', '+err_name+'[0], '+\nerr_name+'[1], '+err_name+'[2]))))')\ncatch_node.add(if_node)\nif_node.add($NodeJS('$B.$raise()'))\nvar else_node=$NodeJS('if(! '+this.exc_name+')')\nnew_nodes.push(else_node)\nelse_node.add($NodeJS('await ($B.promise('+this.cmexit_name+'('+\nthis.cm_name+', _b_.None, _b_.None, _b_.None)))'))\nnode.parent.children.splice(rank,1)\nfor(var i=new_nodes.length-1;i >=0;i--){node.parent.insert(rank,new_nodes[i])}\nnode.children=[]\nreturn 0}\n$WithCtx.prototype.to_js=function(){this.js_processed=true\nvar indent=$get_node(this).indent,h=' '.repeat(indent),num=this.num\nvar head=this.prefix==\"\" ? \"var \" :this.prefix,cm_name='$ctx_manager'+num,cme_name=head+'$ctx_manager_exit'+num,exc_name=head+'$exc'+num,val_name='$value'+num\nreturn 'var '+cm_name+' = $locals.'+cm_name+' = '+\nthis.tree[0].to_js()+'\\n'+\nh+cme_name+' = $B.$getattr('+cm_name+',\"__exit__\")\\n'+\nh+'var '+val_name+' = $B.$getattr('+cm_name+',\"__enter__\")()\\n'+\nh+exc_name+' = true\\n'}\nvar $YieldCtx=$B.parser.$YieldCtx=function(C,is_await){\nthis.type='yield'\nthis.parent=C\nthis.tree=[]\nthis.is_await=is_await\nC.tree[C.tree.length]=this\nif(C.type==\"list_or_tuple\" && C.tree.length > 1){$_SyntaxError(C,\"non-parenthesized yield\")}\nif($parent_match(C,{type:\"annotation\"})){$_SyntaxError(C,[\"'yield' outside function\"])}\nvar parent=this\nwhile(true){var list_or_tuple=$parent_match(parent,{type:\"list_or_tuple\"})\nif(list_or_tuple){list_or_tuple.yields=list_or_tuple.yields ||[]\nlist_or_tuple.yields.push([this,$pos])\nparent=list_or_tuple}else{break}}\nvar parent=this\nwhile(true){var set_or_dict=$parent_match(parent,{type:\"dict_or_set\"})\nif(set_or_dict){set_or_dict.yields=set_or_dict.yields ||[]\nset_or_dict.yields.push([this,$pos])\nparent=set_or_dict}else{break}}\nvar root=$get_module(this)\nroot.yields_func_check=root.yields_func_check ||[]\nroot.yields_func_check.push([this,$pos])\nvar scope=this.scope=$get_scope(this,true),node=$get_node(this)\nnode.has_yield=this\nvar in_comp=$parent_match(this,{type:\"comprehension\"})\nif($get_scope(this).id.startsWith(\"lc\"+$B.lambda_magic)){delete node.has_yield}\nif(in_comp){var outermost_expr=in_comp.tree[0].tree[1]\nvar parent=C\nwhile(parent){if(parent===outermost_expr){break}\nparent=parent.parent}\nif(! parent){$_SyntaxError(C,[\"'yield' inside list comprehension\"])}}\nvar in_lambda=false,parent=C\nwhile(parent){if(parent.type==\"lambda\"){in_lambda=true\nthis.in_lambda=true\nbreak}\nparent=parent.parent}\nvar parent=node.parent\nwhile(parent){if(parent.C && parent.C.tree.length > 0 &&\nparent.C.tree[0].type==\"with\"){scope.C.tree[0].$has_yield_in_cm=true\nbreak}\nparent=parent.parent}\nif(! in_lambda){switch(C.type){case 'node':\nbreak;\ncase 'assign':\ncase 'list_or_tuple':\nbreak\ndefault:\n$_SyntaxError(C,'yield atom must be inside ()')}}}\n$YieldCtx.prototype.ast=function(){\nif(this.from){return new ast.YieldFrom(ast_or_obj(this.tree[0]))}\nif(this.tree.length==1){return new ast.Yield(ast_or_obj(this.tree[0]))}else{return new ast.Yield()}}\n$YieldCtx.prototype.toString=function(){return '(yield) '+(this.from ? '(from) ' :'')+this.tree}\n$YieldCtx.prototype.transition=function(token,value){var C=this\nif(token=='from'){\nif(C.tree[0].type !='abstract_expr'){\n$_SyntaxError(C,\"'from' must follow 'yield'\")}\nC.from=true\nC.from_num=$B.UUID()\nreturn C.tree[0]}else{remove_abstract_expr(C.tree)}\nreturn $transition(C.parent,token)}\n$YieldCtx.prototype.transform=function(node,rank){\nvar parent=node.parent\nwhile(parent){if(parent.ctx_manager_num !==undefined){node.parent.insert(rank+1,$NodeJS(\"$top_frame[1].$has_yield_in_cm = true\"))\nbreak}\nparent=parent.parent}}\n$YieldCtx.prototype.to_js=function(){if(this.from){return `_r${this.from_num}`}else{return \"yield \"+$to_js(this.tree)}}\n$YieldCtx.prototype.check_in_function=function(){if(this.in_lambda){return}\nvar scope=$get_scope(this),in_func=scope.is_function,func_scope=scope\nif(! in_func && scope.comprehension){var parent=scope.parent_block\nwhile(parent.comprehension){parent=parent_block}\nin_func=parent.is_function\nfunc_scope=parent}\nif(! in_func){$_SyntaxError(this.parent,[\"'yield' outside function\"])}else{var def=func_scope.C.tree[0]\nif(! this.is_await){def.type='generator'}}}\nvar $add_line_num=$B.parser.$add_line_num=function(node,rank,line_info){if(node.type=='module'){var i=0\nwhile(i < node.children.length){i+=$add_line_num(node.children[i],i,line_info)}}else if(node.type !=='marker'){var elt=node.C.tree[0],offset=1,flag=true,pnode=node,_line_info\nwhile(pnode.parent !==undefined){pnode=pnode.parent}\nvar mod_id=node.module ||pnode.id\nvar line_num=node.line_num\nif(line_num===undefined){flag=false}\nif((elt.type=='condition' && elt.token=='elif')||\nelt.type=='except' ||\nelt.type=='single_kw' ||\nelt.type=='case'){flag=false}\nif(flag){_line_info=line_info===undefined ? line_num+','+mod_id :\nline_info\nvar js=';$locals.$line_info = \"'+_line_info+\n'\";if($locals.$f_trace !== _b_.None){$B.trace_line()};'+\n'_b_.None;'\nvar new_node=new $Node()\nnew_node.is_line_num=true \nnew $NodeJSCtx(new_node,js)\nnode.parent.insert(rank,new_node)\noffset=2}\nvar i=0\nwhile(i < node.children.length){i+=$add_line_num(node.children[i],i,line_info)}\nreturn offset}else{return 1}}\nfunction find_scope(name,scope){\nif(scope.binding[name]){return scope}else if(scope.globals && scope.globals.has(name)){return $get_module(scope.C)}else if(scope.nonlocals && scope.nonlocals.has(name)){\nvar parent_block=scope.parent_block\nwhile(parent_block){if(parent_block.binding[name]){return parent_block}\nparent_block=parent_block.parent_block}}}\nvar $bind=$B.parser.$bind=function(name,scope,C){\nname=$mangle(name,C)\nif(scope.nonlocals && scope.nonlocals.has(name)){\nvar parent_block=scope.parent_block\nwhile(parent_block){if(parent_block.binding[name]){return parent_block}\nparent_block=parent_block.parent_block}\nreturn}\nif(scope.globals && scope.globals.has(name)){var module=$get_module(C)\nmodule.binding[name]=true\nreturn module}\nif(! C.no_bindings){var node=$get_node(C)\nnode.bindings=node.bindings ||{}\nnode.bindings[name]=true}\nscope.binding=scope.binding ||{}\nif(! scope.binding.hasOwnProperty(name)){scope.binding[name]=true}\nscope.varnames=scope.varnames ||{}\nif(scope.varnames[name]===undefined){scope.varnames[name]=true}\nreturn scope}\nfunction $parent_match(ctx,obj){\nvar flag\nwhile(ctx.parent){flag=true\nfor(var attr in obj){if(ctx.parent[attr]!=obj[attr]){flag=false\nbreak}}\nif(flag){return ctx.parent}\nctx=ctx.parent}\nreturn false}\nvar $previous=$B.parser.$previous=function(C){var previous=C.node.parent.children[C.node.parent.children.length-2]\nif(!previous ||!previous.C){$_SyntaxError(C,'keyword not following correct keyword')}\nreturn previous.C.tree[0]}\nvar $get_docstring=$B.parser.$get_docstring=function(node){var doc_string=''\nif(node.children.length > 0){var firstchild=node.children[0]\nif(firstchild.C.tree && firstchild.C.tree.length > 0 &&\nfirstchild.C.tree[0].type=='expr'){var expr=firstchild.C.tree[0].tree[0]\nif(expr.type=='str' && !Array.isArray(expr.tree[0])){doc_string=firstchild.C.tree[0].tree[0].to_js()}}}\nreturn doc_string}\nvar $get_scope=$B.parser.$get_scope=function(C,flag){\nvar ctx_node=C.parent\nwhile(true){if(ctx_node.type==='node'){break}else if(ctx_node.comprehension){return ctx_node}\nctx_node=ctx_node.parent}\nvar tree_node=ctx_node.node,scope=null\nwhile(tree_node.parent && tree_node.parent.type !=='module'){var ntype=tree_node.parent.C.tree[0].type\nswitch(ntype){case 'def':\ncase 'class':\ncase 'generator':\nvar scope=tree_node.parent\nscope.ntype=ntype\nscope.is_function=ntype !='class'\nreturn scope}\ntree_node=tree_node.parent}\nvar scope=tree_node.parent ||tree_node \nscope.ntype=\"module\"\nreturn scope}\nvar $get_line_num=$B.parser.$get_line_num=function(C){var ctx_node=$get_node(C),line_num=ctx_node.line_num\nif(ctx_node.line_num===undefined){ctx_node=ctx_node.parent\nwhile(ctx_node && ctx_node.line_num===undefined){ctx_node=ctx_node.parent}\nif(ctx_node && ctx_node.line_num){line_num=ctx_node.line_num}}\nreturn line_num}\nvar $get_module=$B.parser.$get_module=function(C){\nvar ctx_node=C instanceof $NodeCtx ? C :C.parent\nwhile(ctx_node.type !=='node'){ctx_node=ctx_node.parent}\nvar tree_node=ctx_node.node\nif(tree_node.ntype==\"module\"){return tree_node}\nvar scope=null\nwhile(tree_node.parent.type !='module'){tree_node=tree_node.parent}\nscope=tree_node.parent \nscope.ntype=\"module\"\nreturn scope}\nvar $get_src=$B.parser.$get_src=function(C){\nvar node=$get_node(C)\nwhile(node.parent !==undefined){node=node.parent}\nreturn node.src}\nvar $get_node=$B.parser.$get_node=function(C){var ctx=C\nwhile(ctx.parent){ctx=ctx.parent}\nreturn ctx.node}\nvar $to_js_map=$B.parser.$to_js_map=function(tree_element){if(tree_element.to_js !==undefined){return tree_element.to_js()}\nconsole.log('no to_js',tree_element)\nthrow Error('no to_js() for '+tree_element)}\nvar $to_js=$B.parser.$to_js=function(tree,sep){if(sep===undefined){sep=','}\ntry{return tree.map($to_js_map).join(sep)}catch(err){console.log('error',err,'\\ntree',tree)\nthrow err}}\nvar $mangle=$B.parser.$mangle=function(name,C){\nif(name.substr(0,2)==\"__\" && name.substr(name.length-2)!==\"__\"){var klass=null,scope=$get_scope(C)\nwhile(true){if(scope.ntype==\"module\"){return name}else if(scope.ntype==\"class\"){var class_name=scope.C.tree[0].name\nwhile(class_name.charAt(0)=='_'){class_name=class_name.substr(1)}\nreturn '_'+class_name+name}else{if(scope.parent && scope.parent.C){scope=$get_scope(scope.C.tree[0])}else{return name}}}}else{return name}}\n$B.nb_debug_lines=0\nvar $transition=$B.parser.$transition=function(C,token,value){if($B.nb_debug_lines > 100){alert('too many debug lines')\n$B.nb_debug_lines=0}\nif($B.track_transitions){console.log(\"C\",C,\"token\",token,value,'$pos',$pos)\n$B.nb_debug_lines++}\nreturn C.transition(token,value)}\n$B.forbidden=[]\n$B.aliased_names=Object.create(null)\nvar s_escaped='abfnrtvxuU\"0123456789'+\"'\"+'\\\\',is_escaped={}\nfor(var i=0;i < s_escaped.length;i++){is_escaped[s_escaped.charAt(i)]=true}\nfunction SurrogatePair(value){\nvalue=value-0x10000\nreturn String.fromCharCode(0xD800 |(value >> 10))+\nString.fromCharCode(0xDC00 |(value & 0x3FF))}\nfunction test_num(num_lit){var len=num_lit.length,pos=0,char,elt=null,subtypes={b:'binary',o:'octal',x:'hexadecimal'},digits_re=/[_\\d]/\nfunction error(message){throw SyntaxError(message)}\nfunction check(elt){if(elt.value.length==0){var t=subtypes[elt.subtype]||'decimal'\nerror(\"invalid \"+t+\" literal\")}else if(elt.value[elt.value.length-1].match(/[\\-+_]/)){var t=subtypes[elt.subtype]||'decimal'\nerror(\"invalid \"+t+\" literal\")}else{\nelt.value=elt.value.replace(/_/g,\"\")\nelt.length=pos\nreturn elt}}\nwhile(pos < len){var char=num_lit[pos]\nif(char.match(digits_re)){if(elt===null){elt={value:char}}else{if(char=='_' && elt.value.match(/[._+\\-]$/)){\nerror('consecutive _ at '+pos)}else if(char=='_' && elt.subtype=='float' &&\nelt.value.match(/e$/i)){\nerror('syntax error')}else if(elt.subtype=='b' && !(char.match(/[01_]/))){error(`invalid digit '${char}' in binary literal`)}else if(elt.subtype=='o' && !(char.match(/[0-7_]/))){error(`invalid digit '${char}' in octal literal`)}else if(elt.subtype===undefined && elt.value.startsWith(\"0\")&&\n!char.match(/[0_]/)){error(\"leading zeros in decimal integer literals are not\"+\n\" permitted; use an 0o prefix for octal integers\")}\nelt.value+=char}\npos++}else if(char.match(/[oxb]/i)){if(elt.value==\"0\"){elt.subtype=char.toLowerCase()\nif(elt.subtype==\"x\"){digits_re=/[_\\da-fA-F]/}\nelt.value=''\npos++}else{error(\"invalid char \"+char)}}else if(char=='.'){if(elt===null){error(\"invalid char in \"+num_lit+\" pos \"+pos+\": \"+char)}else if(elt.subtype===undefined){elt.subtype=\"float\"\nif(elt.value.endsWith('_')){error(\"invalid decimal literal\")}\nelt.value=elt.value.replace(/_/g,\"\")+char\npos++}else{return check(elt)}}else if(char.match(/e/i)){if(num_lit[pos+1]===undefined){error(\"nothing after e\")}else if(elt && subtypes[elt.subtype]!==undefined){\nerror(\"syntax error\")}else if(elt && elt.value.endsWith('_')){\nerror(\"syntax error\")}else if(num_lit[pos+1].match(/[+\\-0-9_]/)){if(elt && elt.value){if(elt.exp){elt.length=pos\nreturn elt}\nelt.subtype='float'\nelt.value+=char\nelt.exp=true\npos++}else{error(\"unexpected e\")}}else{return check(elt)}}else if(char.match(/[\\+\\-]/i)){if(elt===null){elt={value:char}\npos++}else if(elt.value.search(/e$/i)>-1){elt.value+=char\npos++}else{return check(elt)}}else if(char.match(/j/i)){if(elt &&(! elt.subtype ||elt.subtype==\"float\")){elt.imaginary=true\ncheck(elt)\nelt.length++\nreturn elt}else{error(\"invalid syntax\")}}else{break}}\nreturn check(elt)}\nvar opening={')':'(','}':'{',']':'['}\nfunction line_ends_with_comma(src){\nvar expect=':',braces=[]\nfor(token of $B.tokenizer(src)){if(expect==':'){if(token.type=='OP' && token.string==':' && braces.length==0){expect='eol'}else if(token.type=='OP'){if('([{'.indexOf(token.string)>-1){braces.push(token)}else if(')]}'.indexOf(token.string)>-1){if(braces.length==0){var err=SyntaxError(\n`unmatched '${token.string}'`)\nerr.offset=token.start[1]\nthrow err}else if($B.last(braces).string !=opening[token.string]){var err=SyntaxError(\"closing parenthesis \"+\n`'${token.string}' does not match opening `+\n`parenthesis '${$B.last(braces).string}'`)\nerr.offset=token.start[1]\nthrow err}else{braces.pop()}}}else if(token.type=='NEWLINE'){return false}}else{return token.type=='NEWLINE'}}\nreturn false}\nfunction prepare_number(n){\nn=n.replace(/_/g,\"\")\nif(n.startsWith('.')){if(n.endsWith(\"j\")){return{type:'imaginary',value:n.substr(0,n.length-1)}}else{return{type:'float',value:n}}\npos=j}else if(n.startsWith('0')&& n !='0'){\nvar num=test_num(n),base\nif(num.imaginary){return{type:'imaginary',value:num.value}}\nif(num.subtype=='float'){return{type:num.subtype,value:num.value}}\nif(num.subtype===undefined){base=10}else{base={'b':2,'o':8,'x':16}[num.subtype]}\nif(base !==undefined){return{type:'int',value:[base,num.value]}}}else{var num=test_num(n)\nif(num.subtype==\"float\"){return{\ntype:num.imaginary ? 'imaginary' :'float',value:num.value}}else{return{\ntype:num.imaginary ? 'imaginary' :'int',value:num.imaginary ? num.value :[10,num.value]}}}}\nfunction test_escape(C,text,string_start,antislash_pos){\nvar seq_end,mo\nmo=/^[0-7]{1,3}/.exec(text.substr(antislash_pos+1))\nif(mo){return[String.fromCharCode(parseInt(mo[0],8)),1+mo[0].length]}\nswitch(text[antislash_pos+1]){case \"x\":\nvar mo=/^[0-9A-F]{0,2}/i.exec(text.substr(antislash_pos+2))\nif(mo[0].length !=2){seq_end=antislash_pos+mo[0].length+1\n$pos=string_start+seq_end+2\n$_SyntaxError(C,[\"(unicode error) 'unicodeescape' codec can't decode \"+\n`bytes in position ${antislash_pos}-${seq_end}: truncated `+\n\"\\\\xXX escape\"])}else{return[String.fromCharCode(parseInt(mo[0],16)),2+mo[0].length]}\ncase \"u\":\nvar mo=/^[0-9A-F]{0,4}/i.exec(text.substr(antislash_pos+2))\nif(mo[0].length !=4){seq_end=antislash_pos+mo[0].length+1\n$pos=string_start+seq_end+2\n$_SyntaxError(C,[\"(unicode error) 'unicodeescape' codec can't decode \"+\n`bytes in position ${antislash_pos}-${seq_end}: truncated `+\n\"\\\\uXXXX escape\"])}else{return[String.fromCharCode(parseInt(mo[0],16)),2+mo[0].length]}\ncase \"U\":\nvar mo=/^[0-9A-F]{0,8}/i.exec(text.substr(antislash_pos+2))\nif(mo[0].length !=8){seq_end=antislash_pos+mo[0].length+1\n$pos=string_start+seq_end+2\n$_SyntaxError(C,[\"(unicode error) 'unicodeescape' codec can't decode \"+\n`bytes in position ${antislash_pos}-${seq_end}: truncated `+\n\"\\\\uXXXX escape\"])}else{var value=parseInt(mo[0],16)\nif(value > 0x10FFFF){$_SyntaxError('invalid unicode escape '+mo[0])}else if(value >=0x10000){return[SurrogatePair(value),2+mo[0].length]}else{return[String.fromCharCode(value),2+mo[0].length]}}}}\nfunction prepare_string(C,s,position){var len=s.length,pos=0,string_modifier,_type=\"string\"\nwhile(pos < len){if(s[pos]=='\"' ||s[pos]==\"'\"){quote=s[pos]\nstring_modifier=s.substr(0,pos)\nif(s.substr(pos,3)==quote.repeat(3)){_type=\"triple_string\"\ninner=s.substring(pos+3,s.length-3)}else{inner=s.substring(pos+quote.length,len-quote.length)}\nbreak}\npos++}\nvar result={quote}\nvar mods={r:'raw',f:'fstring',b:'bytes'}\nfor(var mod of string_modifier){result[mods[mod]]=true}\nvar raw=C.type=='str' && C.raw,string_start=$pos+pos+1,bytes=false,fstring=false,sm_length,\nend=null;\nif(string_modifier){switch(string_modifier){case 'r':\nraw=true\nbreak\ncase 'u':\nbreak\ncase 'b':\nbytes=true\nbreak\ncase 'rb':\ncase 'br':\nbytes=true\nraw=true\nbreak\ncase 'f':\nfstring=true\nsm_length=1\nbreak\ncase 'fr':\ncase 'rf':\nfstring=true\nsm_length=2\nraw=true\nbreak}\nstring_modifier=false}\nvar escaped=false,zone='',end=0,src=inner\nwhile(end < src.length){if(escaped){if(src.charAt(end)==\"a\" && ! raw){zone=zone.substr(0,zone.length-1)+\"\\u0007\"}else{zone+=src.charAt(end)\nif(raw && src.charAt(end)=='\\\\'){zone+='\\\\'}}\nescaped=false\nend++}else if(src.charAt(end)==\"\\\\\"){if(raw){if(end < src.length-1 &&\nsrc.charAt(end+1)==quote){zone+='\\\\\\\\'+quote\nend+=2}else{zone+='\\\\\\\\'\nend++}\nescaped=true}else{if(src.charAt(end+1)=='\\n'){\nend+=2}else if(src.substr(end+1,2)=='N{'){\nvar end_lit=end+3,re=new RegExp(\"[-a-zA-Z0-9 ]+\"),search=re.exec(src.substr(end_lit))\nif(search===null){$_SyntaxError(C,\"(unicode error) \"+\n\"malformed \\\\N character escape\",pos)}\nvar end_lit=end_lit+search[0].length\nif(src.charAt(end_lit)!=\"}\"){$_SyntaxError(C,\"(unicode error) \"+\n\"malformed \\\\N character escape\")}\nvar description=search[0].toUpperCase()\nif($B.unicodedb===undefined){var xhr=new XMLHttpRequest\nxhr.open(\"GET\",$B.brython_path+\"unicode.txt\",false)\nxhr.onreadystatechange=function(){if(this.readyState==4){if(this.status==200){$B.unicodedb=this.responseText}else{console.log(\"Warning - could not \"+\n\"load unicode.txt\")}}}\nxhr.send()}\nif($B.unicodedb !==undefined){var re=new RegExp(\"^([0-9A-F]+);\"+\ndescription+\";.*$\",\"m\")\nsearch=re.exec($B.unicodedb)\nif(search===null){$_SyntaxError(C,\"(unicode error) \"+\n\"unknown Unicode character name\")}\nvar cp=\"0x\"+search[1]\nzone+=String.fromCodePoint(eval(cp))\nend=end_lit+1}else{end++}}else{var esc=test_escape(C,src,string_start,end)\nif(esc){if(esc[0]=='\\\\'){zone+='\\\\\\\\'}else{zone+=esc[0]}\nend+=esc[1]}else{if(end < src.length-1 &&\nis_escaped[src.charAt(end+1)]===undefined){zone+='\\\\'}\nzone+='\\\\'\nescaped=true\nend++}}}}else if(src.charAt(end)=='\\n' && _type !='triple_string'){\nconsole.log(pos,end,src.substring(pos,end))\n$_SyntaxError(C,[\"EOL while scanning string literal\"])}else{zone+=src.charAt(end)\nend++}}\nvar $string=zone,string=''\nfor(var i=0;i < $string.length;i++){var $car=$string.charAt(i)\nif($car==quote){if(raw ||(i==0 ||\n$string.charAt(i-1)!='\\\\')){string+='\\\\'}else if(_type==\"triple_string\"){\nvar j=i-1\nwhile($string.charAt(j)=='\\\\'){j--}\nif((i-j-1)% 2==0){string+='\\\\'}}}\nstring+=$car}\nif(fstring){try{var re=new RegExp(\"\\\\\\\\\"+quote,\"g\"),string_no_bs=string.replace(re,quote)\nvar elts=$B.parse_fstring(string_no_bs)}catch(err){if(err.position){$pos+=err.position}\n$_SyntaxError(C,[err.message])}}\nif(bytes){result.value='b'+quote+string+quote}else if(fstring){result.value=elts}else{result.value=quote+string+quote}\nC.raw=raw;\nreturn result}\nfunction unindent(src){\nvar lines=src.split('\\n'),line,global_indent,indent,unindented_lines=[]\nfor(var line_num=0,len=lines.length;line_num < len;line_num++){line=lines[line_num]\nindent=line.match(/^\\s*/)[0]\nif(indent !=line){\nif(global_indent===undefined){\nif(indent.length==0){\nreturn src}\nglobal_indent=indent\nvar start=global_indent.length\nunindented_lines.push(line.substr(start))}else if(line.startsWith(global_indent)){unindented_lines.push(line.substr(start))}else{throw SyntaxError(\"first line starts at \"+\n`column ${start}, line ${line_num} at column `+\nline.match(/\\s*/).length+'\\n    '+line)}}else{unindented_lines.push('')}}\nreturn unindented_lines.join('\\n')}\nfunction handle_errortoken(C,token){if(token.string==\"'\" ||token.string=='\"'){$_SyntaxError(C,['unterminated string literal '+\n`(detected at line ${token.start[0]})`])}\n$_SyntaxError(C,'invalid token '+token[1]+_b_.ord(token[1]))}\nvar python_keywords=[\"class\",\"return\",\"break\",\"for\",\"lambda\",\"try\",\"finally\",\"raise\",\"def\",\"from\",\"nonlocal\",\"while\",\"del\",\"global\",\"with\",\"as\",\"elif\",\"else\",\"if\",\"yield\",\"assert\",\"import\",\"except\",\"raise\",\"in\",\"pass\",\"with\",\"continue\",\"__debugger__\",\"async\",\"await\"\n]\nvar dispatch_tokens=$B.parser.dispatch_tokens=function(root,src){var tokenizer=$B.tokenizer(src)\nvar braces_close={\")\":\"(\",\"]\":\"[\",\"}\":\"{\"},braces_open=\"([{\",braces_stack=[]\nvar unsupported=[]\nvar $indented=[\"class\",\"def\",\"for\",\"condition\",\"single_kw\",\"try\",\"except\",\"with\",\"match\",\"case\" \n]\nvar module=root.module\nvar lnum=root.line_num===undefined ? 1 :root.line_num\nvar node=new $Node()\nnode.line_num=lnum\nroot.add(node)\nvar C=null,expect_indent=false,indent=0\nvar line2pos={0:0,1:0},line_num=1\nfor(var pos=0,len=src.length;pos < len;pos++){if(src[pos]=='\\n'){line_num++\nline2pos[line_num]=pos+1}}\nwhile(true){try{var token=tokenizer.next()}catch(err){C=C ||new $NodeCtx(node)\nif(err.type=='IndentationError'){$pos=line2pos[err.line_num]\n$_SyntaxError(C,err.message,1)}else if(err instanceof SyntaxError){if(braces_stack.length > 0){var last_brace=$B.last(braces_stack),start=last_brace.start\nC.$pos=line2pos[start[0]]+start[1]\n$_SyntaxError(C,[`'${last_brace.string}' was `+\n'never closed'])}\n$_SyntaxError(C,err.message)}\nthrow err}\nif(token.done){throw Error('token done without ENDMARKER.')}\ntoken=token.value\nif(token[2]===undefined){console.log('token incomplet',token,'module',module,root)\nconsole.log('src',src)}\nif(token.start===undefined){console.log('no start',token)}\nlnum=token.start[0]\n$pos=line2pos[lnum]+token.start[1]\nif(expect_indent &&\n['INDENT','COMMENT','NL'].indexOf(token.type)==-1){C=C ||new $NodeCtx(node)\n$_SyntaxError(C,\"expected an indented block\",expect_indent)}\nswitch(token.type){case 'ENDMARKER':\nif(root.yields_func_check){var save_pos=$pos\nfor(const _yield of root.yields_func_check){$pos=_yield[1]\n_yield[0].check_in_function()}\n$pos=save_pos}\nif(indent !=0){$_SyntaxError(node.C,'expected an indented block',1)}\nif(node.C===undefined ||node.C.tree.length==0){node.parent.children.pop()}\nreturn\ncase 'ENCODING':\ncase 'TYPE_COMMENT':\ncontinue\ncase 'NL':\nif((! node.C)||node.C.tree.length==0){node.line_num++}\ncontinue\ncase 'COMMENT':\nvar end=line2pos[token.end[0]]+token.end[1]\nroot.comments.push([$pos,end-$pos])\ncontinue\ncase 'ERRORTOKEN':\nC=C ||new $NodeCtx(node)\nif(token.string !=' '){handle_errortoken(C,token)}\ncontinue}\nswitch(token[0]){case 'NAME':\ncase 'NUMBER':\ncase 'OP':\ncase 'STRING':\nC=C ||new $NodeCtx(node)}\nswitch(token[0]){case 'NAME':\nvar name=token[1]\nif(python_keywords.indexOf(name)>-1){if(unsupported.indexOf(name)>-1){$_SyntaxError(C,\"Unsupported Python keyword '\"+name+\"'\")}\nC=$transition(C,name)}else if(name=='not'){C=$transition(C,'not')}else if(typeof $operators[name]=='string'){\nC=$transition(C,'op',name)}else{C=$transition(C,'id',name)}\ncontinue\ncase 'OP':\nvar op=token[1]\nif((op.length==1 && '()[]{}.,='.indexOf(op)>-1)||\n[':='].indexOf(op)>-1){if(braces_open.indexOf(op)>-1){braces_stack.push(token)}else if(braces_close[op]){if(braces_stack.length==0){$_SyntaxError(C,\"unmatched '\"+op+\"'\")}else{var last_brace=$B.last(braces_stack)\nif(last_brace.string==braces_close[op]){braces_stack.pop()}else{$_SyntaxError(C,[`closing parenthesis '${op}' does not `+\n`match opening parenthesis '`+\n`${last_brace.string}'`])}}}\nC=$transition(C,token[1])}else if(op==':'){C=$transition(C,':')\nif(C.node && C.node.is_body_node){node=C.node}}else if(op=='...'){C=$transition(C,'ellipsis')}else if(op=='->'){C=$transition(C,'annotation')}else if(op==';'){if(C.type=='node' && C.tree.length==0){$_SyntaxError(C,'statement cannot start with ;')}\n$transition(C,'eol')\nvar new_node=new $Node()\nnew_node.line_num=token[2][0]+1\nC=new $NodeCtx(new_node)\nnode.parent.add(new_node)\nnode=new_node}else if($augmented_assigns[op]){C=$transition(C,'augm_assign',op)}else{C=$transition(C,'op',op)}\ncontinue\ncase 'STRING':\nvar prepared=prepare_string(C,token[1],token[2])\nif(prepared.value instanceof Array){C=$transition(C,'JoinedStr',prepared.value)}else{C=$transition(C,'str',prepared.value)}\ncontinue\ncase 'NUMBER':\ntry{var prepared=prepare_number(token[1])}catch(err){$_SyntaxError(C,[err.message])}\nC=$transition(C,prepared.type,prepared.value)\ncontinue\ncase 'NEWLINE':\nif(C && C.node && C.node.is_body_node){expect_indent=C.node.parent}\nC=C ||new $NodeCtx(node)\n$transition(C,'eol')\nvar new_node=new $Node()\nnew_node.line_num=token[2][0]+1\nif(node.parent.children.length > 0 &&\nnode.parent.children[0].is_body_node){node.parent.parent.add(new_node)}else{node.parent.add(new_node)}\nC=new $NodeCtx(new_node)\nnode=new_node\ncontinue\ncase 'DEDENT':\nindent--\nnode.parent.children.pop()\nnode.parent.parent.add(node)\ncontinue\ncase 'INDENT':\nindent++\nif(! expect_indent){C=C ||new $NodeCtx(node)\n$_SyntaxError(C,'unexpected indent',$pos)}\nexpect_indent=false\ncontinue}}}\nvar $create_root_node=$B.parser.$create_root_node=function(src,module,locals_id,parent_block,line_num){var root=new $Node('module')\nroot.module=module\nroot.id=locals_id\nroot.binding={__doc__:true,__name__:true,__file__:true,__package__:true}\nroot.parent_block=parent_block\nroot.line_num=line_num\nroot.indent=-1\nroot.comments=[]\nroot.imports={}\nif(typeof src==\"object\"){root.is_comp=src.is_comp\nroot.filename=src.filename\nif(src.has_annotations){root.binding.__annotations__=true}\nsrc=src.src}\nroot.src=src\nreturn root}\n$B.py2js=function(src,module,locals_id,parent_scope,line_num){\n$pos=0\nif(typeof module==\"object\"){var __package__=module.__package__\nmodule=module.__name__}else{var __package__=\"\"}\nparent_scope=parent_scope ||$B.builtins_scope\nvar t0=new Date().getTime(),has_annotations=true,\nline_info,\nix,\nfilename\nif(typeof src=='object'){var has_annotations=src.has_annotations,line_info=src.line_info,ix=src.ix,filename=src.filename\nif(line_info !==undefined){line_num=parseInt(line_info.split(\",\")[0])}\nsrc=src.src}else if(line_num !==undefined){line_info=`${line_num},${module}`}else{line_num=1}\nsrc=src.replace(/\\r\\n/gm,\"\\n\")\nif(src.endsWith(\"\\\\\")&& !src.endsWith(\"\\\\\\\\\")){src=src.substr(0,src.length-1)}\nif(src.charAt(src.length-1)!=\"\\n\"){src+=\"\\n\"}\nvar locals_is_module=Array.isArray(locals_id)\nif(locals_is_module){locals_id=locals_id[0]}\nvar local_ns='$locals_'+locals_id.replace(/\\./g,'_'),global_ns='$locals_'+module.replace(/\\./g,'_'),root=$create_root_node(\n{src:src,has_annotations:has_annotations,filename:filename},module,locals_id,parent_scope,line_num)\ndispatch_tokens(root,src)\nif($B.produce_ast){var ast=ast_dump(root.ast())\nif($B.produce_ast==2){console.log(ast)}}\nif(ix !=undefined){root.ix=ix}\nroot.transform()\nvar js='var $B = __BRYTHON__,\\n'+\n'    _b_ = __BRYTHON__.builtins,\\n'+\n'    $locals = '+local_ns+';\\n'\nvar offset=0\nroot.insert(0,$NodeJS(js))\noffset++\nroot.insert(offset++,$NodeJS(local_ns+'.__package__ = \"'+__package__+'\"'))\nif(root.binding.__annotations__){root.insert(offset++,$NodeJS('$locals.__annotations__ = $B.empty_dict()'))}\nvar enter_frame_pos=offset,js='var $top_frame = [\"'+locals_id.replace(/\\./g,'_')+'\", '+\nlocal_ns+', \"'+module.replace(/\\./g,'_')+'\", '+\nglobal_ns+']\\n$locals.$f_trace = $B.enter_frame($top_frame)\\n'+\n'var $stack_length = $B.frames_stack.length;'\nroot.insert(offset++,$NodeJS(js))\nvar try_node=new $NodeJS('try'),children=root.children.slice(enter_frame_pos+1,root.children.length)\nroot.insert(enter_frame_pos+1,try_node)\nif(children.length==0){children=[$NodeJS('')]}\nfor(var child of children){try_node.add(child)}\ntry_node.add($NodeJS('$B.leave_frame({$locals, value: _b_.None})'))\nroot.children.splice(enter_frame_pos+2,root.children.length)\nvar catch_node=$NodeJS('catch(err)')\ncatch_node.add($NodeJS('$B.leave_frame({$locals, value: _b_.None})'))\ncatch_node.add($NodeJS('throw err'))\nroot.add(catch_node)\n$add_line_num(root,null,line_info)\nvar t1=new Date().getTime()\nif($B.debug > 2){if(module==locals_id){console.log('module '+module+' translated in '+\n(t1-t0)+' ms')}}\n$B.compile_time+=t1-t0\nreturn root}\n$B.set_import_paths=function(){\nvar meta_path=[],path_hooks=[]\nif($B.use_VFS){meta_path.push($B.finders.VFS)}\nif($B.$options.static_stdlib_import !==false && $B.protocol !=\"file\"){\nmeta_path.push($B.finders.stdlib_static)\nif($B.path.length > 3){$B.path.shift()\n$B.path.shift()}}\nif($B.protocol !==\"file\"){meta_path.push($B.finders.path)\npath_hooks.push($B.url_hook)}\nif($B.$options.cpython_import){if($B.$options.cpython_import==\"replace\"){$B.path.pop()}\nmeta_path.push($B.finders.CPython)}\n$B.meta_path=meta_path\n$B.path_hooks=path_hooks}\n$B.parse_options=function(options){\nif(options===undefined){options={debug:1}}else if(typeof options=='number'){options={debug:options}}else if(typeof options !=='object'){console.warn('ignoring invalid argument passed to brython():',options)\noptions={debug:1}}\nif(options.debug===undefined){options.debug=1}\n$B.debug=options.debug\n_b_.__debug__=$B.debug > 0\n$B.compile_time=0\nif(options.profile===undefined){options.profile=0}\n$B.profile=options.profile\nif(options.indexedDB===undefined){options.indexedDB=true}\nif(options.static_stdlib_import===undefined){options.static_stdlib_import=true}\n$B.static_stdlib_import=options.static_stdlib_import\n$B.$options=options\n$B.set_import_paths()\nvar $href=$B.script_path=_window.location.href,$href_elts=$href.split('/')\n$href_elts.pop()\nif($B.isWebWorker ||$B.isNode){$href_elts.pop()}\n$B.curdir=$href_elts.join('/')\nif(options.pythonpath !==undefined){$B.path=options.pythonpath\n$B.$options.static_stdlib_import=false}\noptions.python_extension=options.python_extension ||'.py'\nif(options.python_paths){for(var path of options.python_paths){var lang,prefetch\nif(typeof path !==\"string\"){lang=path.lang\nprefetch=path.prefetch\npath=path.path}\n$B.path.push(path)\nif(path.slice(-7).toLowerCase()=='.vfs.js' &&\n(prefetch===undefined ||prefetch===true)){$B.path_importer_cache[path+'/']=\n$B.imported['_importlib'].VFSPathFinder(path)}\nif(lang){_importlib.optimize_import_for_path(path,lang)}}}\nif(!($B.isWebWorker ||$B.isNode)){\nvar path_links=document.querySelectorAll('head link[rel~=pythonpath]'),_importlib=$B.imported['_importlib']\nfor(var i=0,e;e=path_links[i];++i){var href=e.href;\nif((' '+e.rel+' ').indexOf(' prepend ')!=-1){$B.path.unshift(href);}else{$B.path.push(href);}\nvar filetype=e.hreflang\nif(filetype){if(filetype.slice(0,2)=='x-'){filetype=filetype.slice(2)}\n_importlib.optimize_import_for_path(e.href,filetype)}}}\nif($B.$options.args){$B.__ARGV=$B.$options.args}else{$B.__ARGV=_b_.list.$factory([])}}\nif(! $B.isWebWorker){var observer=new MutationObserver(function(mutations){for(var i=0;i < mutations.length;i++){for(var j=0;j < mutations[i].addedNodes.length;j++){checkPythonScripts(mutations[i].addedNodes[j]);}}});\nobserver.observe(document.documentElement,{childList:true,subtree:true});}\nfunction checkPythonScripts(addedNode){if(addedNode.tagName=='SCRIPT' && addedNode.type==\"text/python\"){var options={}\nfor(var attr of addedNode.attributes){if(attr.nodeName==\"type\"){continue}else if(attr.nodeName=='debug'){options[attr.nodeName]=parseInt(attr.nodeValue)}else{options[attr.nodeName]=attr.nodeValue}}}}\nvar brython=$B.parser.brython=function(options){$B.parse_options(options)\nif(!($B.isWebWorker ||$B.isNode)){observer.disconnect()\n_run_scripts(options)}}\n$B.run_script=function(src,name,url,run_loop){\ntry{var root=$B.py2js(src,name,name),js=root.to_js(),script={__doc__:root.__doc__,js:js,__name__:name,$src:src,__file__:url}\n$B.file_cache[script.__file__]=src\nif($B.debug > 1){console.log($B.format_indent(js,0))}}catch(err){$B.handle_error(err)}\nif($B.hasOwnProperty(\"VFS\")&& $B.has_indexedDB){\nvar imports1=Object.keys(root.imports).slice(),imports=imports1.filter(function(item){return $B.VFS.hasOwnProperty(item)})\nfor(var name of Object.keys(imports)){if($B.VFS.hasOwnProperty(name)){var submodule=$B.VFS[name],type=submodule[0]\nif(type==\".py\"){var src=submodule[1],subimports=submodule[2],is_package=submodule.length==4\nif(type==\".py\"){\nrequired_stdlib_imports(subimports)}\nfor(var mod of subimports){if(imports.indexOf(mod)==-1){imports.push(mod)}}}}}\nfor(var j=0;j < imports.length;j++){$B.tasks.push([$B.inImported,imports[j]])}\nroot=null}\n$B.tasks.push([\"execute\",script])\nif(run_loop){$B.loop()}}\nvar $log=$B.$log=function(js){js.split(\"\\n\").forEach(function(line,i){console.log(i+1,\":\",line)})}\n    \nvar _run_scripts=$B.parser._run_scripts=function(options){if(options===undefined){options={}}\nvar kk=Object.keys(_window)\nvar defined_ids={},$elts=[],webworkers=[]\nvar ids=options.ids ||options.ipy_id\nif(ids !==undefined){if(!Array.isArray(ids)){throw _b_.ValueError.$factory(\"ids is not a list\")}\nvar scripts=[]\nfor(var id of options.ids){var elt=document.getElementById(id)\nif(elt===null){throw _b_.KeyError.$factory(`no script with id '${id}'`)}\nif(elt.tagName !==\"SCRIPT\"){throw _b_.KeyError.$factory(`element ${id} is not a script`)}\nscripts.push(elt)}}else{var scripts=document.getElementsByTagName('script')}\nfor(var i=0;i < scripts.length;i++){var script=scripts[i]\nif(script.type==\"text/python\" ||script.type==\"text/python3\"){if(script.className==\"webworker\"){if(script.id===undefined){throw _b_.AttributeError.$factory(\n\"webworker script has no attribute 'id'\")}\nwebworkers.push(script)}else{$elts.push(script)}}}\nvar first_script=true,module_name\nif(options.ipy_id !==undefined){module_name='__main__'\nvar $src=\"\",js,root\nfor(var elt of $elts){$src+=(elt.innerHTML ||elt.textContent)}\ntry{\nroot=$B.py2js($src,module_name,module_name)\njs=root.to_js()\nif($B.debug > 1){$log(js)}\neval(js)\n$B.clear_ns(module_name)\nroot=null\njs=null}catch($err){root=null\njs=null\nconsole.log($err)\nif($B.debug > 1){console.log($err)\nfor(var attr in $err){console.log(attr+' : ',$err[attr])}}\nif($err.$py_error===undefined){console.log('Javascript error',$err)\n$err=_b_.RuntimeError.$factory($err+'')}\nvar $trace=$B.$getattr($err,'info')+'\\n'+$err.__name__+\n': '+$err.args\ntry{$B.$getattr($B.stderr,'write')($trace)}catch(print_exc_err){console.log($trace)}\nthrow $err}}else{if($elts.length > 0){if(options.indexedDB && $B.has_indexedDB &&\n$B.hasOwnProperty(\"VFS\")){$B.tasks.push([$B.idb_open])}}\nfor(var i=0;i < $elts.length;i++){var elt=$elts[i]\nif(elt.id){if(defined_ids[elt.id]){throw Error(\"Brython error : Found 2 scripts with the \"+\n\"same id '\"+elt.id+\"'\")}else{defined_ids[elt.id]=true}}}\nvar src\nfor(var i=0,len=webworkers.length;i < len;i++){var worker=webworkers[i]\nif(worker.src){\n$B.tasks.push([$B.ajax_load_script,{name:worker.id,url:worker.src,is_ww:true}])}else{\nsrc=(worker.innerHTML ||worker.textContent)\nsrc=unindent(src)\nsrc=src.replace(/^\\n/,'')\n$B.webworkers[worker.id]=src}}\nfor(var i=0;i < $elts.length;i++){var elt=$elts[i]\nif(elt.type==\"text/python\" ||elt.type==\"text/python3\"){\nif(elt.id){module_name=elt.id}else{\nif(first_script){module_name='__main__'\nfirst_script=false}else{module_name='__main__'+$B.UUID()}\nwhile(defined_ids[module_name]!==undefined){module_name='__main__'+$B.UUID()}}\nif(elt.src){\n$B.tasks.push([$B.ajax_load_script,{name:module_name,url:elt.src}])}else{\nsrc=(elt.innerHTML ||elt.textContent)\nsrc=unindent(src)\nsrc=src.replace(/^\\n/,'')\n$B.tasks.push([$B.run_script,src,module_name,$B.script_path+\"#\"+module_name,true])}}}}\nif(options.ipy_id===undefined){$B.loop()}}\n$B.$operators=$operators\n$B.$Node=$Node\n$B.$NodeJSCtx=$NodeJSCtx\n$B.brython=brython})(__BRYTHON__)\nvar brython=__BRYTHON__.brython\nif(__BRYTHON__.isNode){__webpack_require__.g.__BRYTHON__=__BRYTHON__\nmodule.exports={__BRYTHON__ }}\n;\n\n(function($B){var _b_=$B.builtins\nif($B.VFS_timestamp && $B.VFS_timestamp > $B.timestamp){\n$B.timestamp=$B.VFS_timestamp}\nfunction idb_load(evt,module){\nvar res=evt.target.result\nvar timestamp=$B.timestamp\nif(res===undefined ||res.timestamp !=$B.timestamp ||\n($B.VFS[module]&& res.source_ts !==$B.VFS[module].timestamp)){\nif($B.VFS[module]!==undefined){var elts=$B.VFS[module],ext=elts[0],source=elts[1]\nif(ext==\".py\"){var imports=elts[2],is_package=elts.length==4,source_ts=elts.timestamp,__package__\nif(is_package){__package__=module}\nelse{var parts=module.split(\".\")\nparts.pop()\n__package__=parts.join(\".\")}\n$B.imported[module]=$B.module.$factory(module,\"\",__package__)\ntry{var root=$B.py2js(source,module,module),js=root.to_js()}catch(err){$B.handle_error(err)}\ndelete $B.imported[module]\nif($B.debug > 1){console.log(\"precompile\",module)}}else{console.log('bizarre',module,ext)}}else{}}else{\nif(res.is_package){$B.precompiled[module]=[res.content]}else{$B.precompiled[module]=res.content}\nif(res.imports.length > 0){\nif($B.debug > 1){console.log(module,\"imports\",res.imports)}\nvar subimports=res.imports.split(\",\")\nfor(var i=0;i < subimports.length;i++){var subimport=subimports[i]\nif(subimport.startsWith(\".\")){\nvar url_elts=module.split(\".\"),nb_dots=0\nwhile(subimport.startsWith(\".\")){nb_dots++\nsubimport=subimport.substr(1)}\nvar elts=url_elts.slice(0,nb_dots)\nif(subimport){elts=elts.concat([subimport])}\nsubimport=elts.join(\".\")}\nif(!$B.imported.hasOwnProperty(subimport)&&\n!$B.precompiled.hasOwnProperty(subimport)){\nif($B.VFS.hasOwnProperty(subimport)){var submodule=$B.VFS[subimport],ext=submodule[0],source=submodule[1]\nif(submodule[0]==\".py\"){$B.tasks.splice(0,0,[idb_get,subimport])}else{add_jsmodule(subimport,source)}}}}}}\nloop()}\nfunction store_precompiled(module,js,source_ts,imports,is_package){\nvar db=$B.idb_cx.result,tx=db.transaction(\"modules\",\"readwrite\"),store=tx.objectStore(\"modules\"),cursor=store.openCursor(),data={\"name\":module,\"content\":js,\"imports\":imports,\"origin\":origin,\"timestamp\":__BRYTHON__.timestamp,\"source_ts\":source_ts,\"is_package\":is_package},request=store.put(data)\nif($B.debug > 1){console.log(\"store precompiled\",module,\"package\",is_package)}\ndocument.dispatchEvent(new CustomEvent('precompile',{detail:'cache module '+module}))\nvar ix=$B.outdated.indexOf(module)\nif(ix >-1){$B.outdated.splice(ix,1)}\nrequest.onsuccess=function(evt){\n$B.tasks.splice(0,0,[idb_get,module])\nloop()}}\nfunction idb_get(module){\nvar db=$B.idb_cx.result,tx=db.transaction(\"modules\",\"readonly\")\ntry{var store=tx.objectStore(\"modules\")\nreq=store.get(module)\nreq.onsuccess=function(evt){idb_load(evt,module)}}catch(err){console.info('error',err)}}\n$B.idb_open=function(obj){$B.idb_name=\"brython-cache\"\nvar idb_cx=$B.idb_cx=indexedDB.open($B.idb_name)\nidb_cx.onsuccess=function(){var db=idb_cx.result\nif(!db.objectStoreNames.contains(\"modules\")){var version=db.version\ndb.close()\nconsole.info('create object store',version)\nidb_cx=indexedDB.open($B.idb_name,version+1)\nidb_cx.onupgradeneeded=function(){console.info(\"upgrade needed\")\nvar db=$B.idb_cx.result,store=db.createObjectStore(\"modules\",{\"keyPath\":\"name\"})\nstore.onsuccess=loop}\nidb_cx.onversionchanged=function(){console.log(\"version changed\")}\nidb_cx.onsuccess=function(){console.info(\"db opened\",idb_cx)\nvar db=idb_cx.result,store=db.createObjectStore(\"modules\",{\"keyPath\":\"name\"})\nstore.onsuccess=loop}}else{if($B.debug > 1){console.info(\"using indexedDB for stdlib modules cache\")}\nvar tx=db.transaction(\"modules\",\"readwrite\"),store=tx.objectStore(\"modules\"),record,outdated=[]\nvar openCursor=store.openCursor()\nopenCursor.onerror=function(evt){console.log(\"open cursor error\",evt)}\nopenCursor.onsuccess=function(evt){cursor=evt.target.result\nif(cursor){record=cursor.value\nif(record.timestamp==$B.timestamp){if(!$B.VFS ||!$B.VFS[record.name]||\n$B.VFS[record.name].timestamp==record.source_ts){\nif(record.is_package){$B.precompiled[record.name]=[record.content]}else{$B.precompiled[record.name]=record.content}\nif($B.debug > 1){console.info(\"load from cache\",record.name)}}else{\noutdated.push(record.name)}}else{outdated.push(record.name)}\ncursor.continue()}else{if($B.debug > 1){console.log(\"done\")}\n$B.outdated=outdated\nloop()}}}}\nidb_cx.onupgradeneeded=function(){console.info(\"upgrade needed\")\nvar db=idb_cx.result,store=db.createObjectStore(\"modules\",{\"keyPath\":\"name\"})\nstore.onsuccess=loop}\nidb_cx.onerror=function(){console.info('could not open indexedDB database')\n$B.idb_cx=null\n$B.idb_name=null\n$B.$options.indexedDB=false\nloop()}}\n$B.ajax_load_script=function(script){var url=script.url,name=script.name,rel_path=url.substr($B.script_dir.length+1)\nif($B.files && $B.files.hasOwnProperty(rel_path)){\n$B.tasks.splice(0,0,[$B.run_script,atob($B.files[rel_path].content),name,url,true])\nloop()}else if($B.protocol !=\"file\"){var req=new XMLHttpRequest(),qs=$B.$options.cache ? '' :\n(url.search(/\\?/)>-1 ? '&' :'?')+Date.now()\nreq.open(\"GET\",url+qs,true)\nreq.onreadystatechange=function(){if(this.readyState==4){if(this.status==200){var src=this.responseText\nif(script.is_ww){$B.webworkers[name]=src}else{$B.tasks.splice(0,0,[$B.run_script,src,name,url,true])}\nloop()}else if(this.status==404){throw Error(url+\" not found\")}}}\nreq.send()}else{throw _b_.IOError.$factory(\"can't load external script at \"+\nscript.url+\" (Ajax calls not supported with protocol file:///)\")}}\nfunction add_jsmodule(module,source){\nsource+=\"\\nvar $locals_\"+\nmodule.replace(/\\./g,\"_\")+\" = $module\"\n$B.precompiled[module]=source}\nvar inImported=$B.inImported=function(module){if($B.imported.hasOwnProperty(module)){}else if(__BRYTHON__.VFS && __BRYTHON__.VFS.hasOwnProperty(module)){var elts=__BRYTHON__.VFS[module]\nif(elts===undefined){console.log('bizarre',module)}\nvar ext=elts[0],source=elts[1],is_package=elts.length==4\nif(ext==\".py\"){if($B.idb_cx && !$B.idb_cx.$closed){$B.tasks.splice(0,0,[idb_get,module])}}else{add_jsmodule(module,source)}}else{console.log(\"bizarre\",module)}\nloop()}\nvar loop=$B.loop=function(){if($B.tasks.length==0){\nif($B.idb_cx && ! $B.idb_cx.$closed){var db=$B.idb_cx.result,tx=db.transaction(\"modules\",\"readwrite\"),store=tx.objectStore(\"modules\")\nwhile($B.outdated.length > 0){var module=$B.outdated.pop(),req=store.delete(module)\nreq.onsuccess=(function(mod){return function(event){if($B.debug > 1){console.info(\"delete outdated\",mod)}\ndocument.dispatchEvent(new CustomEvent('precompile',{detail:'remove outdated '+mod+\n' from cache'}))}})(module)}\ndocument.dispatchEvent(new CustomEvent('precompile',{detail:\"close\"}))\n$B.idb_cx.result.close()\n$B.idb_cx.$closed=true}\ndocument.dispatchEvent(new CustomEvent(\"brython_done\",{detail:$B.obj_dict($B.$options)}))\nreturn}\nvar task=$B.tasks.shift(),func=task[0],args=task.slice(1)\nif(func==\"execute\"){try{var script=task[1],script_id=script.__name__.replace(/\\./g,\"_\"),module=$B.module.$factory(script.__name__)\nmodule.$src=script.$src\nmodule.__file__=script.__file__\n$B.imported[script_id]=module\nnew Function(\"$locals_\"+script_id,script.js)(module)}catch(err){\nif(err.__class__===undefined){console.log('Javascript error',err)\nvar lineNumber=err.lineNumber\nif(lineNumber !==undefined){console.log('around line',lineNumber)\nconsole.log(script.js.split('\\n').\nslice(lineNumber-4,lineNumber).join('\\n'))}\nif($B.is_recursion_error(err)){err=_b_.RecursionError.$factory(\"too much recursion\")}else{$B.print_stack()\nerr=_b_.RuntimeError.$factory(err+'')}}\n$B.handle_error(err)}\nloop()}else{\ntry{func.apply(null,args)}catch(err){$B.handle_error(err)}}}\n$B.tasks=[]\n$B.has_indexedDB=self.indexedDB !==undefined\nfunction required_stdlib_imports(imports,start){\nvar nb_added=0\nstart=start ||0\nfor(var i=start;i < imports.length;i++){var module=imports[i]\nif($B.imported.hasOwnProperty(module)){continue}\nvar mod_obj=$B.VFS[module]\nif(mod_obj===undefined){console.log(\"undef\",module)}\nif(mod_obj[0]==\".py\"){var subimports=mod_obj[2]\nsubimports.forEach(function(subimport){if(!$B.imported.hasOwnProperty(subimport)&&\nimports.indexOf(subimport)==-1){if($B.VFS.hasOwnProperty(subimport)){imports.push(subimport)\nnb_added++}}})}}\nif(nb_added){required_stdlib_imports(imports,imports.length-nb_added)}\nreturn imports}})(__BRYTHON__)\n;\n__BRYTHON__.builtins.object=(function($B){var _b_=$B.builtins\nvar object={\n$infos:{__name__:\"object\"},$is_class:true,$native:true}\nvar opnames=[\"add\",\"sub\",\"mul\",\"truediv\",\"floordiv\",\"mod\",\"pow\",\"lshift\",\"rshift\",\"and\",\"xor\",\"or\"]\nvar opsigns=[\"+\",\"-\",\"*\",\"/\",\"//\",\"%\",\"**\",\"<<\",\">>\",\"&\",\"^\",\"|\"]\nobject.__delattr__=function(self,attr){if(self.__dict__ && self.__dict__.$string_dict &&\nself.__dict__.$string_dict[attr]!==undefined){delete self.__dict__.$string_dict[attr]\nreturn _b_.None}else if(self.__dict__===undefined && self[attr]!==undefined){delete self[attr]\nreturn _b_.None}else{\nvar klass=self.__class__\nif(klass){var prop=$B.$getattr(klass,attr)\nif(prop.__class__===_b_.property){if(prop.__delete__ !==undefined){prop.__delete__(self)\nreturn _b_.None}}}}\nthrow $B.attr_error(attr,self)}\nobject.__dir__=function(self){var objects\nif(self.$is_class){objects=[self].concat(self.__mro__)}else{var klass=self.__class__ ||$B.get_class(self)\nobjects=[self,klass].concat(klass.__mro__)}\nvar res=[]\nfor(var i=0,len=objects.length;i < len;i++){for(var attr in objects[i]){if(attr.charAt(0)==\"$\"){if(attr.charAt(1)==\"$\"){\nres.push(attr.substr(2))}\ncontinue}\nif(! isNaN(parseInt(attr.charAt(0)))){\ncontinue}\nif(attr==\"__mro__\"){continue}\nres.push(attr)}}\nif(self.__dict__){for(var attr in self.__dict__.$string_dict){if(attr.charAt(0)!=\"$\"){res.push(attr)}}}\nres=_b_.list.$factory(_b_.set.$factory(res))\n_b_.list.sort(res)\nreturn res}\nobject.__eq__=function(self,other){\nif(self===other){return true}\nreturn _b_.NotImplemented}\nobject.__format__=function(){var $=$B.args(\"__format__\",2,{self:null,spec:null},[\"self\",\"spec\"],arguments,{},null,null)\nif($.spec !==\"\"){throw _b_.TypeError.$factory(\n\"non-empty format string passed to object.__format__\")}\nreturn _b_.getattr($.self,\"__str__\")()}\nobject.__ge__=function(){return _b_.NotImplemented}\nobject.__getattribute__=function(obj,attr){var klass=obj.__class__ ||$B.get_class(obj),is_own_class_instance_method=false\nvar $test=false \nif($test){console.log(\"attr\",attr,\"de\",obj,\"klass\",klass)}\nif(attr===\"__class__\"){return klass}\nvar res=obj[attr]\nif(Array.isArray(obj)&& Array.prototype[attr]!==undefined){\nres=undefined}\nif(res===undefined && obj.__dict__){var dict=obj.__dict__\nif(dict.$string_dict.hasOwnProperty(attr)){if($test){console.log(\"__dict__ hasOwnProperty\",attr,dict.$string_dict[attr])}\nreturn dict.$string_dict[attr][0]}}\nif(res===undefined){\nfunction check(obj,kl,attr){var v=kl[attr]\nif(v !==undefined){return v}}\nres=check(obj,klass,attr)\nif(res===undefined){var mro=klass.__mro__\nfor(var i=0,len=mro.length;i < len;i++){res=check(obj,mro[i],attr)\nif(res !==undefined){if($test){console.log(\"found in\",mro[i])}\nbreak}}}else{if(res.__class__ !==$B.method && res.__get__===undefined){\nis_own_class_instance_method=true}}}else{if(res.__set__===undefined){\nreturn res}}\nif(res !==undefined){if($test){console.log(res)}\nif(res.__class__ && _b_.issubclass(res.__class__,_b_.property)){return $B.$getattr(res,'__get__')(obj,klass)}\nif(res.__class__===$B.method){if($test){console.log(\"res is method\")}\nif(res.__get__===undefined){console.log(\"bizarre\",obj,attr,res)}\nreturn res.__get__(obj,klass)}\nvar get=res.__get__\nif(get===undefined && res.__class__){var get=res.__class__.__get__\nfor(var i=0;i < res.__class__.__mro__.length &&\nget===undefined;i++){get=res.__class__.__mro__[i].__get__}}\nif($test){console.log(\"get\",get)}\nvar __get__=get===undefined ? null :\n$B.$getattr(res,\"__get__\",null)\nif($test){console.log(\"__get__\",__get__)}\nif(__get__ !==null){try{return __get__.apply(null,[obj,klass])}\ncatch(err){\nthrow err}}\nif(typeof res==\"object\"){if(__get__ &&(typeof __get__==\"function\")){get_func=function(x,y){return __get__.apply(x,[y,klass.$factory])}}}\nif(__get__===null &&(typeof res==\"function\")){__get__=function(x){return x}}\nif(__get__ !==null){\nres.__name__=attr\nif(attr==\"__new__\" ||\nres.__class__===$B.builtin_function){res.$type=\"staticmethod\"}\nvar res1=__get__.apply(null,[res,obj,klass])\nif($test){console.log(\"res\",res,\"res1\",res1)}\nif(typeof res1==\"function\"){\nif(res1.__class__===$B.method){return res}\nif(res.$type==\"staticmethod\"){return res}\nelse{var self=res.__class__===$B.method ? klass :obj,method=function(){var args=[self]\nfor(var i=0,len=arguments.length;i < len;i++){args.push(arguments[i])}\nreturn res.apply(this,args)}\nmethod.__class__=$B.method\nmethod.__get__=function(obj,cls){var clmethod=res.bind(null,cls)\nclmethod.__class__=$B.method\nclmethod.$infos={__self__:cls,__func__:res,__name__:res.$infos.__name__,__qualname__:cls.$infos.__name__+\".\"+\nres.$infos.__name__}\nreturn clmethod}\nmethod.__get__.__class__=$B.method_wrapper\nmethod.__get__.$infos=res.$infos\nif(klass.$infos===undefined){console.log(\"no $infos\",klass)\nconsole.log($B.last($B.frames_stack))}\nmethod.$infos={__self__:self,__func__:res,__name__:attr,__qualname__:klass.$infos.__name__+\".\"+attr}\nif($test){console.log(\"return method\",method)}\nif(is_own_class_instance_method){obj.$method_cache=obj.$method_cache ||{}\nobj.$method_cache[attr]=[method,res]}\nreturn method}}else{\nreturn res1}}\nreturn res}else{\nvar _ga=obj[\"__getattr__\"]\nif(_ga===undefined){_ga=klass[\"__getattr__\"]\nif(_ga===undefined){var mro=klass.__mro__\nfor(var i=0,len=mro.length;i < len;i++){_ga=mro[i][\"__getattr__\"]\nif(_ga !==undefined){break}}}}\nif(_ga !==undefined){if(klass===$B.module){return _ga(attr)}\nreturn _ga(obj,attr)}else{throw $B.attr_error(attr,obj)}}}\nobject.__gt__=function(){return _b_.NotImplemented}\nobject.__hash__=function(self){var hash=self.__hashvalue__\nif(hash !==undefined){return hash}\nreturn self.__hashvalue__=$B.$py_next_hash--}\nobject.__init__=function(){if(arguments.length==0){throw _b_.TypeError.$factory(\"descriptor '__init__' of 'object' \"+\n\"object needs an argument\")}\nreturn _b_.None}\nobject.__init_subclass__=function(){\nvar $=$B.args(\"__init_subclass__\",0,{},[],arguments,{},null,null)\nreturn _b_.None}\nobject.__init_subclass__.$type=\"staticmethod\"\nobject.__le__=function(){return _b_.NotImplemented}\nobject.__lt__=function(){return _b_.NotImplemented}\nobject.__mro__=[]\nobject.__new__=function(cls,...args){if(cls===undefined){throw _b_.TypeError.$factory(\"object.__new__(): not enough arguments\")}\nvar init_func=$B.$getattr(cls,\"__init__\")\nif(init_func===object.__init__){if(args.length > 0){throw _b_.TypeError.$factory(\"object() takes no parameters\")}}\nvar res=Object.create(null)\n$B.update_obj(res,{__class__ :cls,__dict__:$B.empty_dict()})\nreturn res}\nobject.__ne__=function(self,other){\nif(self===other){return false}\nvar eq=$B.$getattr(self.__class__ ||$B.get_class(self),\"__eq__\",null)\nif(eq !==null){var res=$B.$call(eq)(self,other)\nif(res===_b_.NotImplemented){return res}\nreturn ! $B.$bool(res)}\nreturn _b_.NotImplemented}\nobject.__reduce__=function(self){function _reconstructor(cls){return $B.$call(cls)()}\n_reconstructor.$infos={__qualname__:\"_reconstructor\"}\nvar res=[_reconstructor]\nres.push(_b_.tuple.$factory([self.__class__].\nconcat(self.__class__.__mro__)))\nvar d=$B.empty_dict()\nfor(var attr in self.__dict__.$string_dict){_b_.dict.$setitem(d.$string_dict,attr,self.__dict__.$string_dict[attr][0])}\nconsole.log(\"object.__reduce__, d\",d)\nres.push(d)\nreturn _b_.tuple.$factory(res)}\nfunction __newobj__(cls){return $B.$getattr(cls,\"__new__\").apply(null,arguments)}\n__newobj__.$infos={__name__:\"__newobj__\",__qualname__:\"__newobj__\"}\n_b_.__newobj__=__newobj__\nobject.__reduce_ex__=function(self){var res=[__newobj__]\nvar arg2=_b_.tuple.$factory([self.__class__])\nif(Array.isArray(self)){self.forEach(function(item){arg2.push(item)})}\nres.push(arg2)\nvar d=$B.empty_dict(),nb=0\nif(self.__dict__===undefined){throw _b_.TypeError.$factory(\"cannot pickle '\"+\n$B.class_name(self)+\"' object\")}\nfor(var attr in self.__dict__.$string_dict){if(attr==\"__class__\" ||attr.startsWith(\"$\")){continue}\n_b_.dict.$setitem(d,attr,self.__dict__.$string_dict[attr][0])\nnb++}\nif(nb==0){d=_b_.None}\nres.push(d)\nres.push(_b_.None)\nreturn _b_.tuple.$factory(res)}\nobject.__repr__=function(self){if(self===object){return \"<class 'object'>\"}\nif(self.__class__===_b_.type){return \"<class '\"+self.__name__+\"'>\"}\nvar module=self.__class__.$infos.__module__\nif(module !==undefined && !module.startsWith(\"$\")&&\nmodule !==\"builtins\"){return \"<\"+self.__class__.$infos.__module__+\".\"+\n$B.class_name(self)+\" object>\"}else{return \"<\"+$B.class_name(self)+\" object>\"}}\nobject.__setattr__=function(self,attr,val){if(val===undefined){\nthrow _b_.TypeError.$factory(\n\"can't set attributes of built-in/extension type 'object'\")}else if(self.__class__===object){\nif(object[attr]===undefined){throw $B.attr_error(attr,self)}else{throw _b_.AttributeError.$factory(\n\"'object' object attribute '\"+attr+\"' is read-only\")}}\nif(self.__dict__){_b_.dict.$setitem(self.__dict__,attr,val)}else{\nself[attr]=val}\nreturn _b_.None}\nobject.__setattr__.__get__=function(obj){return function(attr,val){object.__setattr__(obj,attr,val)}}\nobject.__setattr__.__str__=function(){return \"method object.setattr\"}\nobject.__str__=function(self){\nvar len=arguments.length\nif(len==0){throw _b_.TypeError.$factory(\"descriptor '__str__' of 'object' \"+\n\"object needs an argument\")}else if(len > 1){throw _b_.TypeError.$factory(\"descriptor '__str__' of 'object' \"+\n\"expects 1 argument, got \"+len)}else if(self.$nat=='kw'){throw _b_.TypeError.$factory(\"descriptor '__str__' of 'object' \"+\n\"doesn't accept keyword arguments\")}\nif(self.$is_class ||self.$factory){var class_str=$B.$getattr(self.__class__ ||$B.get_class(self),'__str__',null)\nif(class_str !==null && class_str !==object.__str__){return class_str(self)}\nvar class_repr=$B.$getattr(self.__class__ ||$B.get_class(self),'__repr__',null)\nif(class_repr !==null && class_repr !==object.__repr__){return class_repr(self)}}else{\nvar repr_func=$B.$getattr(self,\"__repr__\")\nreturn $B.$call(repr_func)()}}\nobject.__subclasshook__=function(){return _b_.NotImplemented}\nobject.$factory=function(){var res={__class__:object},args=[res].concat(Array.prototype.slice.call(arguments))\nobject.__init__.apply(null,args)\nreturn res}\n$B.set_func_names(object,\"builtins\")\n$B.make_class=function(qualname,factory){\nvar A={__class__:_b_.type,__mro__:[object],$infos:{__qualname__:qualname,__name__:$B.last(qualname.split('.'))},$is_class:true}\nA.$factory=factory\nreturn A}\nreturn object})(__BRYTHON__)\n;\n;(function($B){var _b_=$B.builtins\n$B.$class_constructor=function(class_name,class_obj,bases,parents_names,kwargs){bases=bases ||[]\nvar metaclass\nvar module=class_obj.__module__\nif(module===undefined){\nmodule=class_obj.__module__=$B.last($B.frames_stack)[2]}\nfor(var i=0;i < bases.length;i++){if(bases[i]===undefined){\n$B.line_info=class_obj.$def_line\nthrow $B.name_error(parents_names[i])}}\nvar extra_kwargs={},prepare_kwargs={}\nif(kwargs){for(var i=0;i < kwargs.length;i++){var key=kwargs[i][0],val=kwargs[i][1]\nif(key==\"metaclass\"){\nmetaclass=val}else{\nextra_kwargs[key]=val}\nprepare_kwargs[key]=val}}\nvar mro0=class_obj\nif(class_obj.__eq__ !==undefined && class_obj.__hash__===undefined){class_obj.__hash__=_b_.None}\nvar orig_bases=bases.slice(),use_mro_entries=false\nfor(var i=0;i < bases.length;i++){if(bases[i]===undefined ||\n(bases[i].__mro__===undefined)){var mro_entries=$B.$getattr(bases[i],\"__mro_entries__\",_b_.None)\nif(mro_entries !==_b_.None){var entries=_b_.list.$factory(mro_entries(bases))\nbases.splice(i,1,...entries)\nuse_mro_entries=true\ni--\ncontinue}}}\nif(metaclass===undefined){metaclass=meta_from_bases(class_name,module,bases)}\nvar prepare=$B.$getattr(metaclass,\"__prepare__\",_b_.None),cl_dict=$B.$call(prepare)(class_name,bases)\nif(cl_dict.__class__ !==_b_.dict){var set_class_item=$B.$getattr(cl_dict,\"__setitem__\")}else{var set_class_item=function(attr,value){cl_dict.$string_dict[attr]=[value,cl_dict.$order++]}}\nfor(var attr in class_obj){if(attr==\"__annotations__\"){if(cl_dict.$string_dict[attr]===undefined){cl_dict.$string_dict[attr]=[$B.empty_dict(),cl_dict.$order++]}\nfor(var key in class_obj[attr].$string_dict){$B.$setitem(cl_dict.$string_dict[attr][0],key,class_obj[attr].$string_dict[key][0])}}else{if(attr.charAt(0)!=\"$\"){set_class_item(attr,class_obj[attr])}}}\nif(use_mro_entries){set_class_item(\"__orig_bases__\",_b_.tuple.$factory(orig_bases))}\nvar class_dict={__bases__:bases,__class__:metaclass,__dict__:cl_dict}\nif(cl_dict.__class__===_b_.dict){for(var key in cl_dict.$string_dict){class_dict[key]=cl_dict.$string_dict[key][0]}}else{var get_class_item=$B.$getattr(cl_dict,\"__getitem__\")\nvar it=_b_.iter(cl_dict)\nwhile(true){try{var key=_b_.next(it)\nclass_dict[key]=get_class_item(key)}catch(err){break}}}\nclass_dict.__mro__=_b_.type.mro(class_dict).slice(1)\nvar is_instanciable=true,non_abstract_methods={},abstract_methods={},mro=[class_dict].concat(class_dict.__mro__)\nfor(var i=0;i < mro.length;i++){var kdict=i==0 ? mro0 :mro[i]\nfor(var attr in kdict){if(non_abstract_methods[attr]){continue}\nvar v=kdict[attr]\nif(typeof v==\"function\"){if(v.__isabstractmethod__===true ||\n(v.$attrs && v.$attrs.__isabstractmethod__)){is_instanciable=false\nabstract_methods[attr]=true}else{non_abstract_methods[attr]=true}}else{non_abstract_methods[attr]=true}}}\nvar _slots=class_obj.__slots__\nif(_slots !==undefined){if(typeof _slots==\"string\"){_slots=[_slots]}else{_slots=_b_.list.$factory(_slots)}\ncl_dict.__slots__=_slots}\nfor(var i=0;i < mro.length-1;i++){for(var attr in mro[i]){if(attr==\"__setattr__\"){cl_dict.$has_setattr=true\nbreak}else if(mro[i][attr]){if(mro[i][attr].__get__ ||(mro[i][attr].__class__ &&\nmro[i][attr].__class__.__get__)){\ncl_dict.$has_setattr=true\nbreak}}}}\nvar meta_new=_b_.type.__getattribute__(metaclass,\"__new__\")\nvar kls=meta_new(metaclass,class_name,bases,cl_dict,{$nat:'kw',kw:extra_kwargs})\nkls.__module__=module\nkls.$infos={__module__:module,__name__:class_name,__qualname__:class_obj.$qualname}\nkls.$subclasses=[]\nif(kls.__bases__===undefined ||kls.__bases__.length==0){kls.__bases__=$B.fast_tuple([_b_.object])}\nfor(var attr in class_obj){if(attr.charAt(0)!=\"$\"){if(typeof class_obj[attr]==\"function\"){class_obj[attr].$infos.$class=kls}}}\nif(kls.__class__===metaclass){\nvar meta_init=_b_.type.__getattribute__(metaclass,\"__init__\")\nmeta_init(kls,class_name,bases,cl_dict)}\nfor(var i=0;i < bases.length;i++){bases[i].$subclasses=bases[i].$subclasses ||[]\nbases[i].$subclasses.push(kls)}\nif(!is_instanciable){function nofactory(){throw _b_.TypeError.$factory(\"Can't instantiate abstract class \"+\n\"interface with abstract methods \"+\nObject.keys(abstract_methods).join(\", \"))}\nkls.$factory=nofactory}\nkls.__qualname__=class_name\nreturn kls}\nfunction meta_from_bases(class_name,module,bases){var metaclass\nif(bases && bases.length > 0){metaclass=bases[0].__class__\nif(metaclass===undefined){\nif(typeof bases[0]==\"function\"){if(bases.length !=1){throw _b_.TypeError.$factory(\"A Brython class \"+\n\"can inherit at most 1 Javascript constructor\")}\nmetaclass=bases[0].__class__=$B.JSMeta\n$B.set_func_names(bases[0],module)}else{throw _b_.TypeError.$factory(\"Argument of \"+class_name+\n\"is not a class (type '\"+$B.class_name(bases[0])+\n\"')\")}}\nfor(var i=1;i < bases.length;i++){var mc=bases[i].__class__\nif(mc===metaclass ||_b_.issubclass(metaclass,mc)){}else if(_b_.issubclass(mc,metaclass)){metaclass=mc}else if(metaclass.__bases__ &&\nmetaclass.__bases__.indexOf(mc)==-1){throw _b_.TypeError.$factory(\"metaclass conflict: the \"+\n\"metaclass of a derived class must be a (non-\"+\n\"strict) subclass of the metaclasses of all its bases\")}}}else{metaclass=_b_.type}\nreturn metaclass}\nvar type=$B.make_class(\"type\",function(obj,bases,cl_dict){var len=arguments.length\nif(len==1){if(obj===undefined){return $B.UndefinedClass}\nreturn obj.__class__ ||$B.get_class(obj)}else if(len==3){var module=$B.last($B.frames_stack)[2],meta=meta_from_bases(obj,module,bases)\nreturn type.__new__(meta,obj,bases,cl_dict)}else{throw _b_.TypeError.$factory('type() takes 1 or 3 arguments')}}\n)\ntype.__call__=function(){var extra_args=[],klass=arguments[0]\nfor(var i=1,len=arguments.length;i < len;i++){extra_args.push(arguments[i])}\nvar new_func=_b_.type.__getattribute__(klass,\"__new__\")\nvar instance=new_func.apply(null,arguments),instance_class=instance.__class__ ||$B.get_class(instance)\nif(instance_class===klass){\nvar init_func=_b_.type.__getattribute__(klass,\"__init__\")\nif(init_func !==_b_.object.__init__){\nvar args=[instance].concat(extra_args)\ninit_func.apply(null,args)}}\nreturn instance}\ntype.__class__=type\ntype.__format__=function(klass,fmt_spec){\nreturn _b_.str.$factory(klass)}\ntype.__getattribute__=function(klass,attr){switch(attr){case \"__annotations__\":\nvar mro=[klass].concat(klass.__mro__),res\nfor(var i=0,len=mro.length;i < len;i++){if(mro[i].__dict__){var ann=mro[i].__dict__.$string_dict.__annotations__[0]\nif(ann){if(res===undefined){res=ann}else if(res.__class__===_b_.dict &&\nann.__class__===_b_.dict){\nfor(var key in ann.$string_dict){res.$string_dict[key]=ann.$string_dict[key]}}}}}\nif(res===undefined){res=$B.empty_dict()}\nreturn res\ncase \"__bases__\":\nvar res=klass.__bases__ \nres.__class__=_b_.tuple\nif(res.length==0){}\nreturn res\ncase \"__class__\":\nreturn klass.__class__\ncase \"__doc__\":\nreturn klass.__doc__ ||_b_.None\ncase \"__setattr__\":\nif(klass[\"__setattr__\"]!==undefined){var func=klass[\"__setattr__\"]}else{var func=function(obj,key,value){obj[key]=value}}\nreturn method_wrapper.$factory(attr,klass,func)\ncase \"__delattr__\":\nif(klass[\"__delattr__\"]!==undefined){return klass[\"__delattr__\"]}\nreturn method_wrapper.$factory(attr,klass,function(key){delete klass[key]})}\nvar res=klass[attr]\nvar $test=false \nif($test){console.log(\"attr\",attr,\"of\",klass,res,res+\"\")}\nif(res===undefined && klass.__slots__ &&\nklass.__slots__.indexOf(attr)>-1){return member_descriptor.$factory(attr,klass)}\nif(klass.__class__ &&\nklass.__class__[attr]&&\nklass.__class__[attr].__get__ &&\nklass.__class__[attr].__set__){\nif($test){console.log(\"data descriptor\")}\nreturn klass.__class__[attr].__get__(klass)}\nif(res===undefined){\nvar v=klass[attr]\nif(v===undefined){var mro=klass.__mro__\nif(mro===undefined){console.log(\"pas de mro pour\",klass)}\nfor(var i=0;i < mro.length;i++){var v=mro[i][attr]\nif(v !==undefined){res=v\nbreak}}}else{res=v}\nif(res===undefined){\nvar meta=klass.__class__ ||$B.get_class(klass),res=meta[attr]\nif($test){console.log(\"search in meta\",meta,res)}\nif(res===undefined){var meta_mro=meta.__mro__\nfor(var i=0;i < meta_mro.length;i++){var res=meta_mro[i][attr]\nif(res !==undefined){break}}}\nif(res !==undefined){if($test){console.log(\"found in meta\",res,typeof res)}\nif(res.__class__===_b_.property){return res.fget(klass)}\nif(typeof res==\"function\"){\nvar meta_method=res.bind(null,klass)\nmeta_method.__class__=$B.method\nmeta_method.$infos={__self__:klass,__func__:res,__name__:attr,__qualname__:klass.$infos.__name__+\".\"+attr,__module__:res.$infos ? res.$infos.__module__ :\"\"}\nreturn meta_method}}\nif(res===undefined){\nvar getattr=meta.__getattr__\nif(getattr===undefined){for(var i=0;i < meta_mro.length;i++){if(meta_mro[i].__getattr__ !==undefined){getattr=meta_mro[i].__getattr__\nbreak}}}\nif(getattr !==undefined){return getattr(klass,attr)}}}}\nif(res !==undefined){if($test){console.log(\"res\",res)}\nif(res.__class__===_b_.property){return res}\nif(res.__get__){if(res.__class__===method){var result=res.__get__(res.__func__,klass)\nresult.$infos={__func__:res,__name__:res.$infos.__name__,__qualname__:klass.$infos.__name__+\".\"+res.$infos.__name__,__self__:klass}}else{result=res.__get__(klass)}\nreturn result}else if(res.__class__ && res.__class__.__get__){\nif(!(attr.startsWith(\"__\")&& attr.endsWith(\"__\"))){return res.__class__.__get__(res,_b_.None,klass)}}\nif(typeof res==\"function\"){\nif(res.$infos===undefined && $B.debug > 1){console.log(\"warning: no attribute $infos for\",res,\"klass\",klass,\"attr\",attr)}\nif($test){console.log(\"res is function\",res)}\nif(attr==\"__new__\" ||\nres.__class__===$B.builtin_function){res.$type=\"staticmethod\"}\nif(attr==\"__class_getitem__\" && res.__class__ !==$B.method){res=_b_.classmethod.$factory(res)}\nif(attr==\"__init_subclass__\"){res=_b_.classmethod.$factory(res)}\nif(res.__class__===$B.method){return res.__get__(null,klass)}else{if($test){console.log(\"return res\",res)}\nreturn res}}else{return res}}}\ntype.__hash__=function(cls){return _b_.hash(cls)}\ntype.__init__=function(){if(arguments.length==0){throw _b_.TypeError.$factory(\"descriptor '__init__' of 'type' \"+\n\"object needs an argument\")}}\ntype.__init_subclass__=function(){\nvar $=$B.args(\"__init_subclass__\",1,{},[],arguments,{},\"args\",\"kwargs\")\nif($.kwargs !==undefined){if($.kwargs.__class__ !==_b_.dict ||\nObject.keys($.kwargs.$string_dict).length > 0){throw _b_.TypeError.$factory(\n\"__init_subclass__() takes no keyword arguments\")}}\nreturn _b_.None}\ntype.__instancecheck__=function(cls,instance){var kl=instance.__class__ ||$B.get_class(instance)\nif(kl===cls){return true}\nelse{for(var i=0;i < kl.__mro__.length;i++){if(kl.__mro__[i]===cls){return true}}}\nreturn false}\ntype.__instancecheck__.$type=\"staticmethod\"\ntype.__name__={__get__:function(self){return self.$infos.__name__},__set__:function(self,value){self.$infos.__name__=value},__str__:function(self){return \"type\"},__eq__:function(self,other){return self.$infos.__name__==other}}\ntype.__new__=function(meta,name,bases,cl_dict,extra_kwargs){\nextra_kwargs=extra_kwargs===undefined ?{$nat:'kw',kw:{}}:\nextra_kwargs\nvar module=cl_dict.$string_dict.__module__\nif(module){module=module[0]}else{module=$B.last($B.frames_stack)[2]}\nvar class_dict={__class__ :meta,__bases__ :bases,__dict__ :cl_dict,$infos:{__name__:name,__module__:module,__qualname__:name},$is_class:true,$has_setattr:cl_dict.$has_setattr}\nclass_dict.__mro__=type.mro(class_dict).slice(1)\nvar items=$B.dict_to_list(cl_dict)\nfor(var i=0;i < items.length;i++){var key=items[i][0],v=items[i][1]\nif(key===\"__module__\"){continue}\nif(v===undefined){continue}\nclass_dict[key]=v\nif(v.__class__){\nvar set_name=$B.$getattr(v.__class__,\"__set_name__\",_b_.None)\nif(set_name !==_b_.None){set_name(v,class_dict,key)}}\nif(typeof v==\"function\"){if(v.$infos===undefined){console.log(\"type new\",v,v+\"\")\nconsole.log($B.frames_stack.slice())}else{v.$infos.$class=class_dict\nv.$infos.__qualname__=name+'.'+v.$infos.__name__\nif(v.$infos.$defaults){\nvar $defaults=v.$infos.$defaults\n$B.Function.__setattr__(v,\"__defaults__\",$defaults)}}}}\nvar sup=_b_.super.$factory(class_dict,class_dict)\nvar init_subclass=_b_.super.__getattribute__(sup,\"__init_subclass__\")\ninit_subclass(extra_kwargs)\nreturn class_dict}\ntype.__or__=function(){var $=$B.args('__or__',2,{cls:null,other:null},['cls','other'],arguments,{},null,null),cls=$.cls,other=$.other\nif(! _b_.isinstance(other,type)){return _b_.NotImplemented}\nreturn $B.UnionType.$factory([cls,other])}\ntype.__prepare__=function(){return $B.empty_dict()}\ntype.__qualname__={__get__:function(self){return self.$infos.__qualname__ ||self.$infos.__name__},__set__:function(self,value){self.$infos.__qualname__=value},__str__:function(self){console.log(\"type.__qualname__\")},__eq__:function(self,other){return self.$infos.__qualname__==other}}\ntype.__repr__=function(kls){$B.builtins_repr_check(type,arguments)\nif(kls.$infos===undefined){console.log(\"no $infos\",kls)}\nvar qualname=kls.$infos.__qualname__\nif(kls.$infos.__module__ &&\nkls.$infos.__module__ !=\"builtins\" &&\n!kls.$infos.__module__.startsWith(\"$\")){qualname=kls.$infos.__module__+\".\"+qualname}\nreturn \"<class '\"+qualname+\"'>\"}\ntype.__ror__=function(){var len=arguments.length\nif(len !=1){throw _b_.TypeError.$factory(`expected 1 argument, got ${len}`)}\nreturn _b_.NotImplemented}\ntype.mro=function(cls){\nif(cls===undefined){throw _b_.TypeError.$factory(\n'unbound method type.mro() needs an argument')}\nvar bases=cls.__bases__,seqs=[],pos1=0\nfor(var i=0;i < bases.length;i++){\nif(bases[i]===_b_.str){bases[i]=$B.StringSubclass}\nvar bmro=[],pos=0\nif(bases[i]===undefined ||\nbases[i].__mro__===undefined){if(bases[i].__class__===undefined){\nreturn[_b_.object]}else{throw _b_.TypeError.$factory(\n\"Object passed as base class is not a class\")}}\nbmro[pos++]=bases[i]\nvar _tmp=bases[i].__mro__\nif(_tmp[0]===bases[i]){_tmp.splice(0,1)}\nfor(var k=0;k < _tmp.length;k++){bmro[pos++]=_tmp[k]}\nseqs[pos1++]=bmro}\nseqs[pos1++]=bases.slice()\nvar mro=[cls],mpos=1\nwhile(1){var non_empty=[],pos=0\nfor(var i=0;i < seqs.length;i++){if(seqs[i].length > 0){non_empty[pos++]=seqs[i]}}\nif(non_empty.length==0){break}\nfor(var i=0;i < non_empty.length;i++){var seq=non_empty[i],candidate=seq[0],not_head=[],pos=0\nfor(var j=0;j < non_empty.length;j++){var s=non_empty[j]\nif(s.slice(1).indexOf(candidate)>-1){not_head[pos++]=s}}\nif(not_head.length > 0){candidate=null}\nelse{break}}\nif(candidate===null){throw _b_.TypeError.$factory(\n\"inconsistent hierarchy, no C3 MRO is possible\")}\nmro[mpos++]=candidate\nfor(var i=0;i < seqs.length;i++){var seq=seqs[i]\nif(seq[0]===candidate){\nseqs[i].shift()}}}\nif(mro[mro.length-1]!==_b_.object){mro[mpos++]=_b_.object}\nreturn mro}\ntype.__subclasscheck__=function(self,subclass){\nvar klass=self\nif(klass===_b_.str){klass=$B.StringSubclass}else if(klass===_b_.float){klass=$B.FloatSubclass}\nif(subclass.__bases__===undefined){return self===_b_.object}\nreturn subclass.__bases__.indexOf(klass)>-1}\n$B.set_func_names(type,\"builtins\")\n_b_.type=type\nvar wrapper_descriptor=$B.make_class(\"wrapper_descriptor\")\n$B.set_func_names(wrapper_descriptor,\"builtins\")\ntype.__call__.__class__=wrapper_descriptor\nvar $instance_creator=$B.$instance_creator=function(klass){\nif(klass.prototype && klass.prototype.constructor==klass){\nreturn function(){return new klass(...arguments)}}\nif(klass.$instanciable !==undefined){return function(){throw _b_.TypeError.$factory(\n\"Can't instantiate abstract class interface \"+\n\"with abstract methods\")}}\nvar metaclass=klass.__class__ ||$B.get_class(klass),call_func,factory\nif(metaclass===_b_.type &&(!klass.__bases__ ||klass.__bases__.length==0)){if(klass.hasOwnProperty(\"__new__\")){if(klass.hasOwnProperty(\"__init__\")){factory=function(){\nvar obj=klass.__new__.bind(null,klass).\napply(null,arguments)\nklass.__init__.bind(null,obj).apply(null,arguments)\nreturn obj}}else{factory=function(){return klass.__new__.bind(null,klass).\napply(null,arguments)}}}else if(klass.hasOwnProperty(\"__init__\")){factory=function(){var obj={__class__:klass,__dict__:$B.empty_dict()}\nklass.__init__.bind(null,obj).apply(null,arguments)\nreturn obj}}else{factory=function(){if(arguments.length > 0){if(arguments.length==1 && arguments[0].$nat &&\nObject.keys(arguments[0].kw).length==0){}else{throw _b_.TypeError.$factory(\"object() takes no parameters\")}}\nvar res=Object.create(null)\n$B.update_obj(res,{__class__:klass,__dict__:$B.empty_dict()})\nreturn res}}}else{call_func=_b_.type.__getattribute__(metaclass,\"__call__\")\nvar factory=function(){return call_func.bind(null,klass).apply(null,arguments)}}\nfactory.__class__=$B.Function\nfactory.$infos={__name__:klass.$infos.__name__,__module__:klass.$infos.__module__}\nreturn factory}\nvar method_wrapper=$B.method_wrapper=$B.make_class(\"method_wrapper\",function(attr,klass,method){var f=function(){return method.apply(null,arguments)}\nf.$infos={__name__:attr,__module__:klass.__module__}\nreturn f}\n)\nmethod_wrapper.__str__=method_wrapper.__repr__=function(self){return \"<method '\"+self.$infos.__name__+\"' of function object>\"}\nvar member_descriptor=$B.make_class(\"member_descriptor\",function(attr,cls){return{__class__:member_descriptor,cls:cls,attr:attr}}\n)\nmember_descriptor.__str__=member_descriptor.__repr__=function(self){return \"<member '\"+self.attr+\"' of '\"+self.cls.$infos.__name__+\n\"' objects>\"}\n$B.set_func_names(member_descriptor,\"builtins\")\nvar method=$B.method=$B.make_class(\"method\",function(func,cls){var f=function(){return $B.$call(func).bind(null,cls).apply(null,arguments)}\nf.__class__=method\nf.$infos=func.$infos\nreturn f}\n)\nmethod.__eq__=function(self,other){return self.$infos !==undefined &&\nother.$infos !==undefined &&\nself.$infos.__func__===other.$infos.__func__ &&\nself.$infos.__self__===other.$infos.__self__}\nmethod.__ne__=function(self,other){return ! $B.method.__eq__(self,other)}\nmethod.__get__=function(self){var f=function(){return self(arguments)}\nf.__class__=$B.method_wrapper\nf.$infos=method.$infos\nreturn f}\nmethod.__getattribute__=function(self,attr){\nvar infos=self.$infos\nif(infos && infos[attr]){if(attr==\"__code__\"){var res={__class__:$B.Code}\nfor(var attr in infos.__code__){res[attr]=infos.__code__[attr]}\nreturn res}else{return infos[attr]}}else if(method.hasOwnProperty(attr)){return _b_.object.__getattribute__(self,attr)}else{\nreturn $B.Function.__getattribute__(self.$infos.__func__,attr)}}\nmethod.__repr__=method.__str__=function(self){return \"<bound method \"+self.$infos.__qualname__+\n\" of \"+_b_.str.$factory(self.$infos.__self__)+\">\"}\nmethod.__setattr__=function(self,key,value){\nif(key==\"__class__\"){throw _b_.TypeError.$factory(\"__class__ assignment only supported \"+\n\"for heap types or ModuleType subclasses\")}\nthrow $B.attr_error(attr,self)}\n$B.set_func_names(method,\"builtins\")\n$B.method_descriptor=$B.make_class(\"method_descriptor\")\n$B.classmethod_descriptor=$B.make_class(\"classmethod_descriptor\")\n$B.GenericAlias=$B.make_class(\"GenericAlias\",function(origin_class,items){return{\n__class__:$B.GenericAlias,origin_class,items}}\n)\n$B.GenericAlias.__args__={__get__:function(self){return $B.fast_tuple(self.items)}}\n$B.GenericAlias.__call__=function(self,...args){return self.origin_class.$factory.apply(null,args)}\n$B.GenericAlias.__eq__=function(self,other){return $B.rich_comp(\"__eq__\",self.origin_class,other.origin_class)&&\n$B.rich_comp(\"__eq__\",self.items,other.items)}\n$B.GenericAlias.__getitem__=function(self,item){throw _b_.TypeError.$factory(\"descriptor '__getitem__' for '\"+\nself.origin_class.$infos.__name__+\"' objects doesn't apply to a '\"+\n$B.class_name(item)+\"' object\")}\n$B.GenericAlias.__origin__={__get__:function(self){return self.origin_class}}\n$B.GenericAlias.__parameters__={__get__:function(self){\nreturn $B.fast_tuple([])}}\n$B.GenericAlias.__repr__=function(self){var items=[]\nfor(var i=0,len=self.items.length;i < len;i++){if(self.items[i]===_b_.Ellipsis){items.push('...')}else{if(self.items[i].$is_class){items.push(self.items[i].$infos.__name__)}else{items.push(_b_.repr(self.items[i]))}}}\nreturn self.origin_class.$infos.__qualname__+'['+\nitems.join(\", \")+']'}\n$B.set_func_names($B.GenericAlias,\"types\")\n$B.UnionType=$B.make_class(\"UnionType\",function(items){return{\n__class__:$B.UnionType,items}}\n)\n$B.UnionType.__repr__=function(self){var t=[]\nfor(var item of self.items){if(item.$is_class){t.push(item.$infos.__name__)}else{t.push(_b_.repr(item))}}\nreturn t.join(' | ')}\n$B.set_func_names($B.UnionType,\"types\")\n_b_.object.__class__=type})(__BRYTHON__)\n;\n;(function($B){var _b_=$B.builtins,_window=self,isWebWorker=('undefined' !==typeof WorkerGlobalScope)&&\n(\"function\"===typeof importScripts)&&\n(navigator instanceof WorkerNavigator)\n$B.args=function($fname,argcount,slots,var_names,args,$dobj,extra_pos_args,extra_kw_args){\nif($fname.startsWith(\"lambda_\"+$B.lambda_magic)){$fname=\"<lambda>\"}\nvar has_kw_args=false,nb_pos=args.length,filled=0,extra_kw,only_positional\nvar end_positional=var_names.indexOf(\"/\")\nif(end_positional !=-1){var_names.splice(end_positional,1)\nonly_positional=var_names.slice(0,end_positional)}\nif(nb_pos > 0 && args[nb_pos-1]&& args[nb_pos-1].$nat){nb_pos--\nif(Object.keys(args[nb_pos].kw).length > 0){has_kw_args=true\nvar kw_args=args[nb_pos].kw\nif(Array.isArray(kw_args)){var kwa=kw_args[0]\nfor(var i=1,len=kw_args.length;i < len;i++){var kw_arg=kw_args[i]\nif(kw_arg.__class__===_b_.dict){for(var k in kw_arg.$numeric_dict){throw _b_.TypeError.$factory($fname+\n\"() keywords must be strings\")}\nfor(var k in kw_arg.$object_dict){throw _b_.TypeError.$factory($fname+\n\"() keywords must be strings\")}\nfor(var k in kw_arg.$string_dict){if(kwa[k]!==undefined){throw _b_.TypeError.$factory($fname+\n\"() got multiple values for argument '\"+\nk+\"'\")}\nkwa[k]=kw_arg.$string_dict[k][0]}}else{var it=_b_.iter(kw_arg),getitem=$B.$getattr(kw_arg,'__getitem__')\nwhile(true){try{var k=_b_.next(it)\nif(typeof k !==\"string\"){throw _b_.TypeError.$factory($fname+\n\"() keywords must be strings\")}\nif(kwa[k]!==undefined){throw _b_.TypeError.$factory($fname+\n\"() got multiple values for argument '\"+\nk+\"'\")}\nkwa[k]=getitem(k)}catch(err){if($B.is_exc(err,[_b_.StopIteration])){break}\nthrow err}}}}\nkw_args=kwa}}}\nif(extra_pos_args){slots[extra_pos_args]=[]\nslots[extra_pos_args].__class__=_b_.tuple}\nif(extra_kw_args){\nextra_kw=$B.empty_dict()}\nif(nb_pos > argcount){\nif(extra_pos_args===null ||extra_pos_args==\"*\"){\nmsg=$fname+\"() takes \"+argcount+\" positional argument\"+\n(argcount > 1 ? \"s\" :\"\")+\" but more were given\"\nthrow _b_.TypeError.$factory(msg)}else{\nfor(var i=argcount;i < nb_pos;i++){slots[extra_pos_args].push(args[i])}\nnb_pos=argcount}}\nfor(var i=0;i < nb_pos;i++){slots[var_names[i]]=args[i]\nfilled++}\nif(filled==argcount && argcount===var_names.length &&\n! has_kw_args){if(extra_kw_args){slots[extra_kw_args]=extra_kw}\nreturn slots}\nif(has_kw_args){for(var key in kw_args){var value=kw_args[key]\nif(slots[key]===undefined){\nif(extra_kw_args){\nextra_kw.$string_dict[key]=[value,extra_kw.$order++]}else{throw _b_.TypeError.$factory($fname+\n\"() got an unexpected keyword argument '\"+key+\"'\")}}else if(slots[key]!==null){\nif(key==extra_pos_args){throw _b_.TypeError.$factory(\n`${$fname}() got an unexpected `+\n`keyword argument '${key}'`)}\nthrow _b_.TypeError.$factory($fname+\n\"() got multiple values for argument '\"+key+\"'\")}else if(only_positional && only_positional.indexOf(key)>-1){throw _b_.TypeError.$factory($fname+\"() got an \"+\n\"unexpected keyword argument '\"+key+\"'\")}else{\nslots[key]=value}}}\nvar missing=[]\nfor(var attr in slots){if(slots[attr]===null){if($dobj[attr]!==undefined){slots[attr]=$dobj[attr]}else{missing.push(\"'\"+attr+\"'\")}}}\nif(missing.length > 0){if(missing.length==1){throw _b_.TypeError.$factory($fname+\n\" missing 1 positional argument: \"+missing[0])}else{var msg=$fname+\" missing \"+missing.length+\n\" positional arguments: \"\nmsg+=missing.join(\" and \")\nthrow _b_.TypeError.$factory(msg)}}\nif(extra_kw_args){slots[extra_kw_args]=extra_kw}\nreturn slots}\n$B.wrong_nb_args=function(name,received,expected,positional){if(received < expected){var missing=expected-received\nthrow _b_.TypeError.$factory(name+\"() missing \"+missing+\n\" positional argument\"+(missing > 1 ? \"s\" :\"\")+\": \"+\npositional.slice(received))}else{throw _b_.TypeError.$factory(name+\"() takes \"+expected+\n\" positional argument\"+(expected > 1 ? \"s\" :\"\")+\n\" but more were given\")}}\n$B.get_class=function(obj){\nif(obj===null){return $B.$NoneDict}\nif(obj===undefined){return $B.UndefinedClass}\nvar klass=obj.__class__\nif(klass===undefined){switch(typeof obj){case \"number\":\nif(obj % 1===0){\nreturn _b_.int}\nreturn _b_.float\ncase \"string\":\nreturn _b_.str\ncase \"boolean\":\nreturn _b_.bool\ncase \"function\":\nif(obj.$is_js_func){\nreturn $B.JSObj}\nobj.__class__=$B.Function\nreturn $B.Function\ncase \"object\":\nif(Array.isArray(obj)){if(Object.getPrototypeOf(obj)===Array.prototype){obj.__class__=_b_.list\nreturn _b_.list}}else if(obj.constructor===Number){return _b_.float}else if(typeof Node !==\"undefined\" \n&& obj instanceof Node){if(obj.tagName){return $B.imported['browser.html'][obj.tagName]||\n$B.DOMNode}\nreturn $B.DOMNode}\nbreak}}\nif(klass===undefined){return $B.JSObj}\nreturn klass}\n$B.class_name=function(obj){var klass=$B.get_class(obj)\nif(klass===$B.JSObj){return 'Javascript '+obj.constructor.name}else{return klass.$infos.__name__}}\n$B.next_of=function(iterator){\nif(iterator.__class__===_b_.range){var obj={ix:iterator.start}\nif(iterator.step > 0){return function(){if(obj.ix >=iterator.stop){throw _b_.StopIteration.$factory('')}\nvar res=obj.ix\nobj.ix+=iterator.step\nreturn res}}else{return function(){if(obj.ix <=iterator.stop){throw _b_.StopIteration.$factory('')}\nvar res=obj.ix\nobj.ix+=iterator.step\nreturn res}}}\nreturn $B.$call($B.$getattr(_b_.iter(iterator),'__next__'))}\n$B.unpacker=function(obj,nb_targets,has_starred,target){\nvar t=_b_.list.$factory(obj),len=t.length,min_len=has_starred ? len-1 :len\nif(len < min_len){throw _b_.ValueError.$factory(\n`not enough values to unpack (expected ${min_length}, got ${len})`)}\nif((! has_starred)&& len > nb_targets){console.log('iterable',obj,'t',t,'nb_targets',nb_targets)\nthrow _b_.ValueError.$factory(\n`too many values to unpack (expected ${nb_targets})`)}\nt.index=-1\nt.read_one=function(){t.index++\nreturn t[t.index]}\nt.read_rest=function(){t.index++\nreturn t.slice(t.index)}\nreturn t}\n$B.rest_iter=function(next_func){\nvar res=[]\nwhile(true){try{res.push(next_func())}catch(err){if($B.is_exc(err,[_b_.StopIteration])){return $B.fast_tuple(res)}\nthrow err}}}\n$B.copy_namespace=function(){var ns={}\nfor(const frame of $B.frames_stack){for(const kv of[frame[1],frame[3]]){for(var key in kv){if(! key.startsWith('$')){ns[key]=kv[key]}}}}\nreturn ns}\n$B.clear_ns=function(name){\nif(name.startsWith(\"__ge\")){console.log(\"clear ns\",name)}\nvar len=name.length\n$B.$py_src[name]=null\ndelete $B.$py_src[name]\nvar alt_name=name.replace(/\\./g,\"_\")\nif(alt_name !=name){$B.clear_ns(alt_name)}}\n$B.$search=function(name,global_ns){\nvar frame=$B.last($B.frames_stack)\nif(frame[1][name]!==undefined){return frame[1][name]}\nelse if(frame[3][name]!==undefined){return frame[3][name]}\nelse if(_b_[name]!==undefined){return _b_[name]}\nelse{if(frame[0]==frame[2]||frame[1].$type==\"class\" ||\nframe[1].$exec_locals){throw $B.name_error(name)}else{throw _b_.UnboundLocalError.$factory(\"local variable '\"+\nname+\"' referenced before assignment\")}}}\n$B.$global_search=function(name,search_ids){\nvar ns={}\nfor(var i=0;i < $B.frames_stack.length;i++){var frame=$B.frames_stack[i]\nif(search_ids.indexOf(frame[0])>-1){if(frame[1].$is_not_dict){\ntry{return $B.$getitem(frame[1],name)}catch(err){if(! $B.is_exc(err,[_b_.KeyError])){throw err}}}else if(frame[1][name]!==undefined){return frame[1][name]}}\nif(search_ids.indexOf(frame[2])>-1){if(frame[3][name]!==undefined){return frame[3][name]}}}\nfor(var i=0;i < search_ids.length;i++){var search_id=search_ids[i]\nif($B.imported[search_id]&& $B.imported[search_id][name]){return $B.imported[search_id][name]}}\nthrow $B.name_error(name)}\n$B.$local_search=function(name){\nvar frame=$B.last($B.frames_stack)\nif(frame[1][name]!==undefined){return frame[1][name]}\nelse{throw _b_.UnboundLocalError.$factory(\"local variable '\"+\nname+\"' referenced before assignment\")}}\n$B.get_method_class=function(ns,qualname){\nvar refs=qualname.split('.'),klass=ns\nwhile(refs.length > 0){var ref=refs.shift()\nif(klass[ref]===undefined){var fake_class=$B.make_class(qualname)\nreturn fake_class}\nklass=klass[ref]}\nreturn klass}\n$B.$check_def=function(name,value){\nif(value !==undefined){return value}else if(_b_[name]!==undefined){\nreturn _b_[name]}else{var frame=$B.last($B.frames_stack)\nif(frame[1].$is_not_dict){\ntry{return $B.$getitem(frame[1],name)}catch(err){if(! $B.is_exc(err,[_b_.KeyError])){throw err}}}else if(frame[1][name]!==undefined){return frame[1][name]}\nif(frame[3][name]!==undefined){return frame[3][name]}}\nthrow $B.name_error(name)}\n$B.$check_def_global=function(name,ns){var res=ns[name]\nif(res===undefined){throw $B.name_error(name)}\nreturn res}\n$B.$check_def_local=function(name,value){\nif(value !==undefined){return value}\nthrow _b_.UnboundLocalError.$factory(\"local variable '\"+\nname+\"' referenced before assignment\")}\n$B.$check_def_free=function(name,value){\nif(value !==undefined){return value}\nvar res\nfor(var i=$B.frames_stack.length-1;i >=0;i--){res=$B.frames_stack[i][1][name]\nif(res !==undefined){return res}\nres=$B.frames_stack[i][3][name]\nif(res !==undefined){return res}}\nthrow _b_.NameError.$factory(\"free variable '\"+name+\n\"' referenced before assignment in enclosing scope\")}\n$B.$check_def_free1=function(name,scope_id){\nvar res\nfor(var i=$B.frames_stack.length-1;i >=0;i--){var frame=$B.frames_stack[i]\nres=frame[1][name]\nif(res !==undefined){return res}\nif(frame[1].$parent){res=frame[1].$parent[name]\nif(res !==undefined){return res}}\nif(frame[2]==scope_id){res=frame[3][name]\nif(res !==undefined){return res}}}\nthrow _b_.NameError.$factory(\"free variable '\"+name+\n\"' referenced before assignment in enclosing scope\")}\n$B.$JS2Py=function(src){if(typeof src===\"number\"){if(src % 1===0){return src}\nreturn _b_.float.$factory(src)}\nif(src===null ||src===undefined){return _b_.None}\nif(Array.isArray(src)&&\nObject.getPrototypeOf(src)===Array.prototype){src.$brython_class=\"js\" }\nreturn src}\n$B.list_key=function(obj,key){key=$B.$GetInt(key)\nif(key < 0){key+=obj.length}\nvar res=obj[key]\nif(res===undefined){throw _b_.IndexError.$factory(\"list index out of range\")}\nreturn res}\n$B.list_slice=function(obj,start,stop){if(start===null){start=0}\nelse{start=$B.$GetInt(start)\nif(start < 0){start=Math.max(0,start+obj.length)}}\nif(stop===null){return obj.slice(start)}\nstop=$B.$GetInt(stop)\nif(stop < 0){stop+=obj.length}\nreturn obj.slice(start,stop)}\n$B.list_slice_step=function(obj,start,stop,step){if(step===null ||step==1){return $B.list_slice(obj,start,stop)}\nif(step==0){throw _b_.ValueError.$factory(\"slice step cannot be zero\")}\nstep=$B.$GetInt(step)\nif(start===null){start=step >=0 ? 0 :obj.length-1}\nelse{start=$B.$GetInt(start)\nif(start < 0){start=Math.min(0,start+obj.length)}}\nif(stop===null){stop=step >=0 ? obj.length :-1}\nelse{stop=$B.$GetInt(stop)\nif(stop < 0){stop=Math.max(0,stop+obj.length)}}\nvar res=[]\nif(step > 0){for(var i=start;i < stop;i+=step){res.push(obj[i])}}else{for(var i=start;i > stop;i+=step){res.push(obj[i])}}\nreturn res}\nfunction index_error(obj){var type=typeof obj==\"string\" ? \"string\" :\"list\"\nthrow _b_.IndexError.$factory(type+\" index out of range\")}\n$B.$getitem=function(obj,item){var is_list=Array.isArray(obj)&& obj.__class__===_b_.list,is_dict=obj.__class__===_b_.dict && ! obj.$jsobj\nif(typeof item==\"number\"){if(is_list ||typeof obj==\"string\"){item=item >=0 ? item :obj.length+item\nif(obj[item]!==undefined){return obj[item]}else{index_error(obj)}}else if(is_dict){if(obj.$numeric_dict[item]!==undefined){return obj.$numeric_dict[item][0]}}}else if(item.valueOf && typeof item.valueOf()==\"string\" && is_dict){var res=obj.$string_dict[item]\nif(res !==undefined){return res[0]}\nthrow _b_.KeyError.$factory(item)}\nif(obj.$is_class){var class_gi=$B.$getattr(obj,\"__class_getitem__\",_b_.None)\nif(class_gi !==_b_.None){return class_gi(item)}else if(obj.__class__){class_gi=$B.$getattr(obj.__class__,\"__getitem__\",_b_.None)\nif(class_gi !==_b_.None){return class_gi(obj,item)}else{throw _b_.TypeError.$factory(\"'\"+\n$B.class_name(obj.__class__)+\n\"' object is not subscriptable\")}}}\nif(is_list){return _b_.list.$getitem(obj,item)}\nif(is_dict){return _b_.dict.$getitem(obj,item)}\nvar gi=$B.$getattr(obj.__class__ ||$B.get_class(obj),\"__getitem__\",_b_.None)\nif(gi !==_b_.None){return gi(obj,item)}\nthrow _b_.TypeError.$factory(\"'\"+$B.class_name(obj)+\n\"' object is not subscriptable\")}\n$B.getitem_slice=function(obj,slice){var res\nif(Array.isArray(obj)&& obj.__class__===_b_.list){if(slice.start===_b_.None && slice.stop===_b_.None){if(slice.step===_b_.None ||slice.step==1){res=obj.slice()}else if(slice.step==-1){res=obj.slice().reverse()}}else if(slice.step===_b_.None){if(slice.start===_b_.None){slice.start=0}\nif(slice.stop===_b_.None){slice.stop=obj.length}\nif(typeof slice.start==\"number\" &&\ntypeof slice.stop==\"number\"){if(slice.start < 0){slice.start+=obj.length}\nif(slice.stop < 0){slice.stop+=obj.length}\nres=obj.slice(slice.start,slice.stop)}}\nif(res){res.__class__=obj.__class__ \nreturn res}else{return _b_.list.$getitem(obj,slice)}}\nreturn $B.$getattr(obj,\"__getitem__\")(slice)}\n$B.set_list_key=function(obj,key,value){try{key=$B.$GetInt(key)}\ncatch(err){if(_b_.isinstance(key,_b_.slice)){var s=_b_.slice.$conv_for_seq(key,obj.length)\nreturn $B.set_list_slice_step(obj,s.start,s.stop,s.step,value)}}\nif(key < 0){key+=obj.length}\nif(obj[key]===undefined){console.log(obj,key)\nthrow _b_.IndexError.$factory(\"list assignment index out of range\")}\nobj[key]=value}\n$B.set_list_slice=function(obj,start,stop,value){if(start===null){start=0}else{start=$B.$GetInt(start)\nif(start < 0){start=Math.max(0,start+obj.length)}}\nif(stop===null){stop=obj.length}\nstop=$B.$GetInt(stop)\nif(stop < 0){stop=Math.max(0,stop+obj.length)}\nvar res=_b_.list.$factory(value)\nobj.splice.apply(obj,[start,stop-start].concat(res))}\n$B.set_list_slice_step=function(obj,start,stop,step,value){if(step===null ||step==1){return $B.set_list_slice(obj,start,stop,value)}\nif(step==0){throw _b_.ValueError.$factory(\"slice step cannot be zero\")}\nstep=$B.$GetInt(step)\nif(start===null){start=step > 0 ? 0 :obj.length-1}else{start=$B.$GetInt(start)}\nif(stop===null){stop=step > 0 ? obj.length :-1}else{stop=$B.$GetInt(stop)}\nvar repl=_b_.list.$factory(value),j=0,test,nb=0\nif(step > 0){test=function(i){return i < stop}}\nelse{test=function(i){return i > stop}}\nfor(var i=start;test(i);i+=step){nb++}\nif(nb !=repl.length){throw _b_.ValueError.$factory(\n\"attempt to assign sequence of size \"+repl.length+\n\" to extended slice of size \"+nb)}\nfor(var i=start;test(i);i+=step){obj[i]=repl[j]\nj++}}\n$B.$setitem=function(obj,item,value){if(Array.isArray(obj)&& obj.__class__===undefined &&\ntypeof item==\"number\" &&\n!_b_.isinstance(obj,_b_.tuple)){if(item < 0){item+=obj.length}\nif(obj[item]===undefined){throw _b_.IndexError.$factory(\"list assignment index out of range\")}\nobj[item]=value\nreturn}else if(obj.__class__===_b_.dict){_b_.dict.$setitem(obj,item,value)\nreturn}else if(obj.__class__===_b_.list){return _b_.list.$setitem(obj,item,value)}\nvar si=$B.$getattr(obj.__class__ ||$B.get_class(obj),\"__setitem__\",null)\nif(si===null){throw _b_.TypeError.$factory(\"'\"+$B.class_name(obj)+\n\"' object does not support item assignment\")}\nreturn si(obj,item,value)}\n$B.$delitem=function(obj,item){if(Array.isArray(obj)&& obj.__class__===_b_.list &&\ntypeof item==\"number\" &&\n!_b_.isinstance(obj,_b_.tuple)){if(item < 0){item+=obj.length}\nif(obj[item]===undefined){throw _b_.IndexError.$factory(\"list deletion index out of range\")}\nobj.splice(item,1)\nreturn}else if(obj.__class__===_b_.dict){_b_.dict.__delitem__(obj,item)\nreturn}else if(obj.__class__===_b_.list){return _b_.list.__delitem__(obj,item)}\nvar di=$B.$getattr(obj.__class__ ||$B.get_class(obj),\"__delitem__\",null)\nif(di===null){throw _b_.TypeError.$factory(\"'\"+$B.class_name(obj)+\n\"' object doesn't support item deletion\")}\nreturn di(obj,item)}\n$B.delitem_slice=function(obj,slice){if(Array.isArray(obj)&& obj.__class__===_b_.list){if(slice.start===_b_.None && slice.stop===_b_.None){if(slice.step===_b_.None ||slice.step==1 ||\nslice.step==-1){while(obj.length > 0){obj.pop()}\nreturn _b_.None}}else if(slice.step===_b_.None){if(slice.start===_b_.None){slice.start=0}\nif(slice.stop===_b_.None){slice.stop=obj.length}\nif(typeof slice.start==\"number\" &&\ntypeof slice.stop==\"number\"){if(slice.start < 0){slice.start+=obj.length}\nif(slice.stop < 0){slice.stop+=obj.length}\nobj.splice(slice.start,slice.stop-slice.start)\nreturn _b_.None}}}\nvar di=$B.$getattr(obj.__class__ ||$B.get_class(obj),\"__delitem__\",null)\nif(di===null){throw _b_.TypeError.$factory(\"'\"+$B.class_name(obj)+\n\"' object doesn't support item deletion\")}\nreturn di(obj,slice)}\n$B.augm_assign=function(left,op,right){\nvar op1=op.substr(0,op.length-1)\nif(typeof left=='number' && typeof right=='number'\n&& op !='//='){\nvar res=eval(left+' '+op1+' '+right)\nif(res <=$B.max_int && res >=$B.min_int &&\nres.toString().search(/e/i)==-1){return res}else{res=eval(`${BigInt(left)}n ${op1} ${BigInt(right)}n`)\nvar pos=res > 0n,res=res+''\nreturn pos ? $B.fast_long_int(res,true):\n$B.fast_long_int(res.substr(1),false)}}else if(typeof left=='string' && typeof right=='string' &&\nop=='+='){return left+right}else{var method=$B.op2method.augmented_assigns[op],augm_func=$B.$getattr(left,'__'+method+'__',null)\nif(augm_func !==null){return $B.$call(augm_func)(right)}else{var method1=$B.op2method.operations[op1]\nif(method1===undefined){method1=$B.op2method.binary[op1]}\nreturn $B.rich_op(method1,left,right)}}}\n$B.extend=function(fname,arg){\nfor(var i=2;i < arguments.length;i++){var mapping=arguments[i]\nvar it=_b_.iter(mapping),getter=$B.$getattr(mapping,\"__getitem__\")\nwhile(true){try{var key=_b_.next(it)\nif(typeof key !==\"string\"){throw _b_.TypeError.$factory(fname+\n\"() keywords must be strings\")}\nif(arg[key]!==undefined){throw _b_.TypeError.$factory(fname+\n\"() got multiple values for argument '\"+key+\"'\")}\narg[key]=getter(key)}catch(err){if(_b_.isinstance(err,[_b_.StopIteration])){break}\nthrow err}}}\nreturn arg}\n$B.extend_list=function(){\nvar res=Array.prototype.slice.call(arguments,0,arguments.length-1),last=$B.last(arguments)\nvar it=_b_.iter(last)\nwhile(true){try{res.push(_b_.next(it))}catch(err){if(_b_.isinstance(err,[_b_.StopIteration])){break}\nthrow err}}\nreturn res}\n$B.$test_item=function(expr){\n$B.$test_result=expr\nreturn _b_.bool.$factory(expr)}\n$B.$test_expr=function(){\nreturn $B.$test_result}\n$B.$is=function(a,b){\nif(a instanceof Number && b instanceof Number){return a.valueOf()==b.valueOf()}\nif((a===_b_.int && b==$B.long_int)||\n(a===$B.long_int && b===_b_.int)){return true}\nreturn a===b}\n$B.conv_undef=function(obj){\nvar res={}\nfor(var key in obj){res[key]=obj[key]===undefined ? $B.Undefined :obj[key]}\nreturn res}\n$B.$is_member=function(item,_set){\nvar f,_iter,method\ntry{method=$B.$getattr(_set.__class__ ||$B.get_class(_set),\"__contains__\")}\ncatch(err){}\nif(method){return $B.$call(method)(_set,item)}\ntry{_iter=_b_.iter(_set)}\ncatch(err){}\nif(_iter){while(1){try{var elt=_b_.next(_iter)\nif($B.rich_comp(\"__eq__\",elt,item)){return true}}catch(err){return false}}}\ntry{f=$B.$getattr(_set,\"__getitem__\")}\ncatch(err){throw _b_.TypeError.$factory(\"'\"+$B.class_name(_set)+\n\"' object is not iterable\")}\nif(f){var i=-1\nwhile(1){i++\ntry{var elt=f(i)\nif($B.rich_comp(\"__eq__\",elt,item)){return true}}catch(err){if(err.__class__===_b_.IndexError){return false}\nthrow err}}}}\n$B.$call=function(callable){if(callable.__class__===$B.method){return callable}else if(callable.$factory){return callable.$factory}else if(callable.$is_class){\nreturn callable.$factory=$B.$instance_creator(callable)}else if(callable.$is_js_class){\nreturn callable.$factory=function(){return new callable(...arguments)}}else if(callable.$in_js_module){\nreturn function(){var res=callable(...arguments)\nreturn res===undefined ? _b_.None :res}}else if(callable.$is_func ||typeof callable==\"function\"){return callable}\ntry{return $B.$getattr(callable,\"__call__\")}catch(err){throw _b_.TypeError.$factory(\"'\"+$B.class_name(callable)+\n\"' object is not callable\")}}\nvar $io=$B.make_class(\"io\",function(out){return{\n__class__:$io,out}}\n)\n$io.flush=function(self){console[self.out].apply(null,self.buf)\nself.buf=[]}\n$io.write=function(self,msg){\nif(self.buf===undefined){self.buf=[]}\nif(typeof msg !=\"string\"){throw _b_.TypeError.$factory(\"write() argument must be str, not \"+\n$B.class_name(msg))}\nself.buf.push(msg)\nreturn _b_.None}\nif(console.error !==undefined){$B.stderr=$io.$factory(\"error\")}else{$B.stderr=$io.$factory(\"log\")}\n$B.stdout=$io.$factory(\"log\")\n$B.stdin={__class__:$io,__original__:true,closed:false,len:1,pos:0,read:function(){return \"\"},readline:function(){return \"\"}}\n$B.make_iterator_class=function(name){\nvar klass={__class__:_b_.type,__mro__:[_b_.object],$factory:function(items){return{\n__class__:klass,__dict__:$B.empty_dict(),counter:-1,items:items,len:items.length}},$infos:{__name__:name},$is_class:true,__iter__:function(self){self.counter=self.counter===undefined ?-1 :self.counter\nself.len=self.items.length\nreturn self},__len__:function(self){return self.items.length},__next__:function(self){if(typeof self.test_change==\"function\" && self.test_change()){\nthrow _b_.RuntimeError.$factory(\n\"dictionary changed size during iteration\")}\nself.counter++\nif(self.counter < self.items.length){var item=self.items[self.counter]\nif(self.items.$brython_class==\"js\"){\nitem=$B.$JS2Py(item)}\nreturn item}\nthrow _b_.StopIteration.$factory(\"StopIteration\")},__reduce_ex__:function(self,protocol){return $B.fast_tuple([_b_.iter,_b_.tuple.$factory([self.items])])}}\n$B.set_func_names(klass,\"builtins\")\nreturn klass}\nfunction $err(op,klass,other){var msg=\"unsupported operand type(s) for \"+op+\" : '\"+\nklass.$infos.__name__+\"' and '\"+$B.class_name(other)+\"'\"\nthrow _b_.TypeError.$factory(msg)}\nvar r_opnames=[\"add\",\"sub\",\"mul\",\"truediv\",\"floordiv\",\"mod\",\"pow\",\"lshift\",\"rshift\",\"and\",\"xor\",\"or\"]\nvar ropsigns=[\"+\",\"-\",\"*\",\"/\",\"//\",\"%\",\"**\",\"<<\",\">>\",\"&\",\"^\",\"|\"]\n$B.make_rmethods=function(klass){for(var r_opname of r_opnames){if(klass[\"__r\"+r_opname+\"__\"]===undefined &&\nklass['__'+r_opname+'__']){klass[\"__r\"+r_opname+\"__\"]=(function(name){return function(self,other){return klass[\"__\"+name+\"__\"](other,self)}})(r_opname)}}}\n$B.UUID=function(){return $B.$py_UUID++}\n$B.$GetInt=function(value){\nif(typeof value==\"number\" ||value.constructor===Number){return value}\nelse if(typeof value===\"boolean\"){return value ? 1 :0}\nelse if(_b_.isinstance(value,_b_.int)){return value}\nelse if(_b_.isinstance(value,_b_.float)){return value.valueOf()}\nif(! value.$is_class){try{var v=$B.$getattr(value,\"__int__\")();return v}catch(e){}\ntry{var v=$B.$getattr(value,\"__index__\")();return v}catch(e){}}\nthrow _b_.TypeError.$factory(\"'\"+$B.class_name(value)+\n\"' object cannot be interpreted as an integer\")}\n$B.to_num=function(obj,methods){\nvar expected_class={\"__complex__\":_b_.complex,\"__float__\":_b_.float,\"__index__\":_b_.int,\"__int__\":_b_.int}\nvar klass=obj.__class__ ||$B.get_class(obj)\nfor(var i=0;i < methods.length;i++){var missing={},method=$B.$getattr(klass,methods[i],missing)\nif(method !==missing){var res=method(obj)\nif(!_b_.isinstance(res,expected_class[methods[i]])){console.log(res,methods[i],expected_class[methods[i]])\nthrow _b_.TypeError.$factory(methods[i]+\"returned non-\"+\nexpected_class[methods[i]].$infos.__name__+\n\"(type \"+$B.get_class(res)+\")\")}\nreturn res}}\nreturn null}\n$B.PyNumber_Index=function(item){switch(typeof item){case \"boolean\":\nreturn item ? 1 :0\ncase \"number\":\nreturn item\ncase \"object\":\nif(item.__class__===$B.long_int){return item}\nif(_b_.isinstance(item,_b_.int)){\nreturn item.$brython_value}\nvar method=$B.$getattr(item,\"__index__\",_b_.None)\nif(method !==_b_.None){method=typeof method==\"function\" ?\nmethod :$B.$getattr(method,\"__call__\")\nreturn $B.int_or_bool(method())}else{throw _b_.TypeError.$factory(\"'\"+$B.class_name(item)+\n\"' object cannot be interpreted as an integer\")}\ndefault:\nthrow _b_.TypeError.$factory(\"'\"+$B.class_name(item)+\n\"' object cannot be interpreted as an integer\")}}\n$B.int_or_bool=function(v){switch(typeof v){case \"boolean\":\nreturn v ? 1 :0\ncase \"number\":\nreturn v\ncase \"object\":\nif(v.__class__===$B.long_int){return v}\nelse{throw _b_.TypeError.$factory(\"'\"+$B.class_name(v)+\n\"' object cannot be interpreted as an integer\")}\ndefault:\nthrow _b_.TypeError.$factory(\"'\"+$B.class_name(v)+\n\"' object cannot be interpreted as an integer\")}}\n$B.enter_frame=function(frame){\n$B.frames_stack.push(frame)\nif($B.tracefunc && $B.tracefunc !==_b_.None){if(frame[4]===$B.tracefunc ||\n($B.tracefunc.$infos && frame[4]&&\nframe[4]===$B.tracefunc.$infos.__func__)){\n$B.tracefunc.$frame_id=frame[0]\nreturn _b_.None}else{\nfor(var i=$B.frames_stack.length-1;i >=0;i--){if($B.frames_stack[i][0]==$B.tracefunc.$frame_id){return _b_.None}}\ntry{return $B.tracefunc($B._frame.$factory($B.frames_stack,$B.frames_stack.length-1),'call',_b_.None)}catch(err){err.$in_trace_func=true\nthrow err}}}\nreturn _b_.None}\n$B.trace_exception=function(){var top_frame=$B.last($B.frames_stack)\nif(top_frame[0]==$B.tracefunc.$current_frame_id){return _b_.None}\nvar trace_func=top_frame[1].$f_trace,exc=top_frame[1].$current_exception,frame_obj=$B._frame.$factory($B.frames_stack,$B.frames_stack.length-1)\nreturn trace_func(frame_obj,'exception',$B.fast_tuple([exc.__class__,exc,$B.traceback.$factory(exc)]))}\n$B.trace_line=function(){var top_frame=$B.last($B.frames_stack)\nif(top_frame[0]==$B.tracefunc.$current_frame_id){return _b_.None}\nvar trace_func=top_frame[1].$f_trace,frame_obj=$B._frame.$factory($B.frames_stack,$B.frames_stack.length-1)\nreturn trace_func(frame_obj,'line',_b_.None)}\n$B.set_line=function(line_info){\nvar top_frame=$B.last($B.frames_stack)\nif($B.tracefunc && top_frame[0]==$B.tracefunc.$current_frame_id){return _b_.None}\ntop_frame[1].$line_info=line_info\nvar trace_func=top_frame[1].$f_trace\nif(trace_func !==_b_.None){var frame_obj=$B._frame.$factory($B.frames_stack,$B.frames_stack.length-1)\ntop_frame[1].$ftrace=trace_func(frame_obj,'line',_b_.None)}\nreturn true}\n$B.trace_return=function(value){var top_frame=$B.last($B.frames_stack),trace_func=top_frame[1].$f_trace,frame_obj=$B._frame.$factory($B.frames_stack,$B.frames_stack.length-1)\nif(top_frame[0]==$B.tracefunc.$current_frame_id){\nreturn _b_.None}\ntrace_func(frame_obj,'return',value)}\n$B.leave_frame=function(arg){\nif($B.frames_stack.length==0){console.log(\"empty stack\");return}\nif(arg && arg.value !==undefined && $B.tracefunc){if($B.last($B.frames_stack)[1].$f_trace===undefined){$B.last($B.frames_stack)[1].$f_trace=$B.tracefunc}\nif($B.last($B.frames_stack)[1].$f_trace !==_b_.None){$B.trace_return(arg.value)}}\nvar frame=$B.frames_stack.pop()\nif(frame[1].$is_generator){\nvar ctx_managers=new Set()\nfor(var key in frame[1]){if(key.startsWith('$ctx_manager')){ctx_managers.add(frame[1][key])}}\nif(ctx_managers.size > 0 && $B.frames_stack.length > 0){\nvar caller=$B.last($B.frames_stack)\ncaller[1].$ctx_managers_in_gen=caller[1].$ctx_managers_in_gen ||\nnew Set()\nfor(var cm of ctx_managers){caller[1].$ctx_managers_in_gen.add(cm)}}}\nframe[1].$current_exception=undefined\nif(frame[1].$ctx_managers_in_gen){for(var cm of frame[1].$ctx_managers_in_gen){$B.$call($B.$getattr(cm,'__exit__'))(_b_.None,_b_.None,_b_.None)}}\nreturn _b_.None}\n$B.leave_frame_exec=function(arg){\nif($B.profile > 0){$B.$profile.return()}\nif($B.frames_stack.length==0){console.log(\"empty stack\");return}\nvar frame=$B.last($B.frames_stack)\n$B.frames_stack.pop()\nif(frame[1].$ctx_managers_in_gen){\nfor(var cm of frame[1].$ctx_managers_in_gen){$B.$call($B.$getattr(cm,'__exit__'))(_b_.None,_b_.None,_b_.None)}}\nfor(var i=$B.frames_stack.length-1;i >=0;i--){if($B.frames_stack[i][2]==frame[2]){$B.frames_stack[i][3]=frame[3]}}}\nvar min_int=Math.pow(-2,53),max_int=Math.pow(2,53)-1\n$B.is_safe_int=function(){for(var i=0;i < arguments.length;i++){var arg=arguments[i]\nif((typeof arg !=\"number\")||\n(arg < min_int ||arg > max_int)){return false}}\nreturn true}\n$B.add=function(x,y){if(x.valueOf && typeof x.valueOf()==\"number\" &&\ny.valueOf && typeof y.valueOf()==\"number\"){if(typeof x==\"number\" && typeof y==\"number\"){\nvar z=x+y\nif(z < $B.max_int && z > $B.min_int){return z}else if(z===Infinity){return _b_.float.$factory(\"inf\")}else if(z===-Infinity){return _b_.float.$factory(\"-inf\")}else if(isNaN(z)){return _b_.float.$factory('nan')}\nreturn $B.long_int.__add__($B.long_int.$factory(x),$B.long_int.$factory(y))}else{\nreturn new Number(x+y)}}else if(typeof x==\"string\" && typeof y==\"string\"){\nreturn x+y}\ntry{var method=$B.$getattr(x.__class__ ||$B.get_class(x),\"__add__\")}catch(err){if(err.__class__===_b_.AttributeError){throw _b_.TypeError.$factory(\"unsupported operand type(s) for \"+\n\"+: '\"+$B.class_name(x)+\"' and '\"+$B.class_name(y)+\"'\")}\nthrow err}\nvar res=$B.$call(method)(x,y)\nif(res===_b_.NotImplemented){\nreturn $B.rich_op(\"add\",x,y)}\nreturn res}\n$B.div=function(x,y){var z=x/y\nif(x > min_int && x < max_int && y > min_int && y < max_int\n&& z > min_int && z < max_int){return z}\nelse{return $B.long_int.__truediv__($B.long_int.$factory(x),$B.long_int.$factory(y))}}\n$B.eq=function(x,y){if(x > min_int && x < max_int && y > min_int && y < max_int){return x==y}\nreturn $B.long_int.__eq__($B.long_int.$factory(x),$B.long_int.$factory(y))}\n$B.floordiv=function(x,y){var z=x/y\nif(x > min_int && x < max_int && y > min_int && y < max_int\n&& z > min_int && z < max_int){return Math.floor(z)}\nelse{return $B.long_int.__floordiv__($B.long_int.$factory(x),$B.long_int.$factory(y))}}\n$B.mul=function(x,y){var z=(typeof x !=\"number\" ||typeof y !=\"number\")?\nnew Number(x*y):x*y\nif(x > min_int && x < max_int && y > min_int && y < max_int\n&& z > min_int && z < max_int){return z}\nelse if((typeof x==\"number\" ||x.__class__===$B.long_int)\n&&(typeof y==\"number\" ||y.__class__===$B.long_int)){if((typeof x==\"number\" && isNaN(x))||\n(typeof y==\"number\" && isNaN(y))){return _b_.float.$factory(\"nan\")}\nswitch(x){case Infinity:\ncase-Infinity:\nif(y==0){return _b_.float.$factory(\"nan\")}else{return y > 0 ? x :-x}}\nreturn $B.long_int.__mul__($B.long_int.$factory(x),$B.long_int.$factory(y))}else{return z}}\n$B.sub=function(x,y){if(x instanceof Number && y instanceof Number){return x-y}\nvar z=(typeof x !=\"number\" ||typeof y !=\"number\")?\nnew Number(x-y):x-y\nif(x > min_int && x < max_int && y > min_int && y < max_int\n&& z > min_int && z < max_int){return z}else if((typeof x==\"number\" ||x.__class__===$B.long_int)\n&&(typeof y==\"number\" ||y.__class__===$B.long_int)){if(typeof x==\"number\" && typeof y==\"number\"){if(isNaN(x)||isNaN(y)){return _b_.float.$factory(\"nan\")}else if(x===Infinity ||x===-Infinity){if(y===x){return _b_.float.$factory(\"nan\")}else{return x}}else if(y===Infinity ||y===-Infinity){if(y===x){return _b_.float.$factory(\"nan\")}else{return-y}}}\nif((typeof x==\"number\" && isNaN(x))||\n(typeof y==\"number\" && isNaN(y))){return _b_.float.$factory(\"nan\")}\nreturn $B.long_int.__sub__($B.long_int.$factory(x),$B.long_int.$factory(y))}else{return z}}\n$B.ge=function(x,y){if(typeof x==\"number\" && typeof y==\"number\"){return x >=y}\nelse if(typeof x==\"number\" && typeof y !=\"number\"){return ! y.pos}\nelse if(typeof x !=\"number\" && typeof y==\"number\"){return x.pos===true}else{return $B.long_int.__ge__(x,y)}}\n$B.gt=function(x,y){if(typeof x==\"number\" && typeof y==\"number\"){return x > y}\nelse if(typeof x==\"number\" && typeof y !=\"number\"){return ! y.pos}\nelse if(typeof x !=\"number\" && typeof y==\"number\"){return x.pos===true}else{return $B.long_int.__gt__(x,y)}}\nvar reversed_op={\"__lt__\":\"__gt__\",\"__le__\":\"__ge__\",\"__gt__\":\"__lt__\",\"__ge__\":\"__le__\"}\nvar method2comp={\"__lt__\":\"<\",\"__le__\":\"<=\",\"__gt__\":\">\",\"__ge__\":\">=\"}\n$B.rich_comp=function(op,x,y){if(x===undefined){throw _b_.RuntimeError.$factory('error in rich comp')}\nvar x1=x.valueOf ? x.valueOf():x,y1=y.valueOf ? y.valueOf():y\nif(typeof x1==\"number\" && typeof y1==\"number\" &&\nx.__class__===undefined && y.__class__===undefined){switch(op){case \"__eq__\":\nreturn x1==y1\ncase \"__ne__\":\nreturn x1 !=y1\ncase \"__le__\":\nreturn x1 <=y1\ncase \"__lt__\":\nreturn x1 < y1\ncase \"__ge__\":\nreturn x1 >=y1\ncase \"__gt__\":\nreturn x1 > y1}}\nvar res\nif(x.$is_class ||x.$factory){if(op==\"__eq__\"){return(x===y)}else if(op==\"__ne__\"){return !(x===y)}else{throw _b_.TypeError.$factory(\"'\"+method2comp[op]+\n\"' not supported between instances of '\"+$B.class_name(x)+\n\"' and '\"+$B.class_name(y)+\"'\")}}\nvar x_class_op=$B.$call($B.$getattr(x.__class__ ||$B.get_class(x),op)),rev_op=reversed_op[op]||op\nif(x.__class__ && y.__class__){\nif(y.__class__.__mro__.indexOf(x.__class__)>-1){var rev_func=$B.$getattr(y,rev_op)\nres=$B.$call($B.$getattr(y,rev_op))(x)\nif(res !==_b_.NotImplemented){return res}}}\nres=x_class_op(x,y)\nif(res !==_b_.NotImplemented){return res}\nvar y_class_op=$B.$call($B.$getattr(y.__class__ ||$B.get_class(y),rev_op))\nres=y_class_op(y,x)\nif(res !==_b_.NotImplemented ){return res}\nif(op==\"__eq__\"){return _b_.False}else if(op==\"__ne__\"){return _b_.True}\nthrow _b_.TypeError.$factory(\"'\"+method2comp[op]+\n\"' not supported between instances of '\"+$B.class_name(x)+\n\"' and '\"+$B.class_name(y)+\"'\")}\nvar opname2opsign={sub:\"-\",xor:\"^\",mul:\"*\"}\n$B.rich_op=function(op,x,y){var x_class=x.__class__ ||$B.get_class(x),y_class=y.__class__ ||$B.get_class(y),special_method='__'+op+'__',method\nif(x_class===y_class){\nif(x_class===_b_.int){return _b_.int[special_method](x,y)}else if(x_class===_b_.bool){return(_b_.bool[special_method]||_b_.int[special_method])\n(x,y)}\ntry{method=$B.$call($B.$getattr(x_class,\"__\"+op+\"__\"))}catch(err){if(err.__class__===_b_.AttributeError){var kl_name=$B.class_name(x)\nthrow _b_.TypeError.$factory(\"unsupported operand type(s) \"+\n\"for \"+opname2opsign[op]+\" : '\"+kl_name+\"' and '\"+\nkl_name+\"'\")}\nthrow err}\nreturn method(x,y)}\nif(_b_.issubclass(y_class,x_class)){\nvar reflected_left=$B.$getattr(x_class,'__r'+op+'__'),reflected_right=$B.$getattr(y_class,'__r'+op+'__')\nif(reflected_right !==reflected_left){return reflected_right(y,x)}}\nvar res\ntry{method=$B.$call($B.$getattr(x,\"__\"+op+\"__\"))}catch(err){if(err.__class__ !==_b_.AttributeError){throw err}\nres=$B.$call($B.$getattr(y,\"__r\"+op+\"__\"))(x)\nif(res !==_b_.NotImplemented){return res}\nthrow _b_.TypeError.$factory(\"'\"+(opname2opsign[op]||op)+\n\"' not supported between instances of '\"+$B.class_name(x)+\n\"' and '\"+$B.class_name(y)+\"'\")}\nres=method(y)\nif(res===_b_.NotImplemented){var reflected=$B.$getattr(y,\"__r\"+op+\"__\",null)\nif(reflected !==null){res=$B.$call(reflected)(x)\nif(res !==_b_.NotImplemented){return res}}\nthrow _b_.TypeError.$factory(\"'\"+(opname2opsign[op]||op)+\n\"' not supported between instances of '\"+$B.class_name(x)+\n\"' and '\"+$B.class_name(y)+\"'\")}else{return res}}\n$B.is_none=function(o){return o===undefined ||o===null ||o==_b_.None}\nvar repr_stack=new Set()\n$B.repr={enter:function(obj){if(repr_stack.has(obj)){return true}else{repr_stack.add(obj)}},leave:function(obj){repr_stack.delete(obj)}}})(__BRYTHON__)\n;\n;(function($B){\nvar DEFAULT_MIN_MERGE=32\nvar DEFAULT_MIN_GALLOPING=7\nvar DEFAULT_TMP_STORAGE_LENGTH=256\nvar POWERS_OF_TEN=[1e0,1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8,1e9]\nfunction log10(x){if(x < 1e5){if(x < 1e2){return x < 1e1 ? 0 :1}\nif(x < 1e4){return x < 1e3 ? 2 :3}\nreturn 4}\nif(x < 1e7){return x < 1e6 ? 5 :6}\nif(x < 1e9){return x < 1e8 ? 7 :8}\nreturn 9}\nfunction alphabeticalCompare(a,b){if(a===b){return 0}\nif(~~a===a && ~~b===b){if(a===0 ||b===0){return a < b ?-1 :1}\nif(a < 0 ||b < 0){if(b >=0){return-1}\nif(a >=0){return 1}\na=-a\nb=-b}\nal=log10(a)\nbl=log10(b)\nvar t=0\nif(al < bl){a*=POWERS_OF_TEN[bl-al-1]\nb/=10\nt=-1}else if(al > bl){b*=POWERS_OF_TEN[al-bl-1]\na/=10;\nt=1;}\nif(a===b){return t}\nreturn a < b ?-1 :1}\nvar aStr=String(a)\nvar bStr=String(b)\nif(aStr===bStr){return 0}\nreturn aStr < bStr ?-1 :1}\nfunction minRunLength(n){var r=0\nwhile(n >=DEFAULT_MIN_MERGE){r |=(n & 1)\nn >>=1}\nreturn n+r}\nfunction makeAscendingRun(array,lo,hi,compare){var runHi=lo+1\nif(runHi===hi){return 1;}\nif(compare(array[runHi++],array[lo])< 0){while(runHi < hi && compare(array[runHi],array[runHi-1])< 0){runHi++}\nreverseRun(array,lo,runHi)}else{while(runHi < hi && compare(array[runHi],array[runHi-1])>=0){runHi++}}\nreturn runHi-lo}\nfunction reverseRun(array,lo,hi){hi--\nwhile(lo < hi){var t=array[lo]\narray[lo++]=array[hi]\narray[hi--]=t}}\nfunction binaryInsertionSort(array,lo,hi,start,compare){if(start===lo){start++}\nfor(;start < hi;start++){var pivot=array[start]\nvar left=lo\nvar right=start\nwhile(left < right){var mid=(left+right)>>> 1\nif(compare(pivot,array[mid])< 0){right=mid}else{left=mid+1}}\nvar n=start-left\nswitch(n){case 3:\narray[left+3]=array[left+2]\ncase 2:\narray[left+2]=array[left+1]\ncase 1:\narray[left+1]=array[left]\nbreak;\ndefault:\nwhile(n > 0){array[left+n]=array[left+n-1]\nn--;}}\narray[left]=pivot}}\nfunction gallopLeft(value,array,start,length,hint,compare){var lastOffset=0,maxOffset=0,offset=1\nif(compare(value,array[start+hint])> 0){maxOffset=length-hint\nwhile(offset < maxOffset && compare(value,array[start+hint+offset])> 0){lastOffset=offset\noffset=(offset << 1)+1\nif(offset <=0){offset=maxOffset}}\nif(offset > maxOffset){offset=maxOffset}\nlastOffset+=hint\noffset+=hint}else{maxOffset=hint+1\nwhile(offset < maxOffset && compare(value,array[start+hint-offset])<=0){lastOffset=offset\noffset=(offset << 1)+1\nif(offset <=0){offset=maxOffset}}\nif(offset > maxOffset){offset=maxOffset}\nvar tmp=lastOffset\nlastOffset=hint-offset\noffset=hint-tmp}\nlastOffset++\nwhile(lastOffset < offset){var m=lastOffset+((offset-lastOffset)>>> 1)\nif(compare(value,array[start+m])> 0){lastOffset=m+1}else{offset=m}}\nreturn offset}\nfunction gallopRight(value,array,start,length,hint,compare){var lastOffset=0,maxOffset=0,offset=1\nif(compare(value,array[start+hint])< 0){maxOffset=hint+1\nwhile(offset < maxOffset && compare(value,array[start+hint-offset])< 0){lastOffset=offset\noffset=(offset << 1)+1\nif(offset <=0){offset=maxOffset}}\nif(offset > maxOffset){offset=maxOffset}\nvar tmp=lastOffset\nlastOffset=hint-offset\noffset=hint-tmp}else{maxOffset=length-hint\nwhile(offset < maxOffset && compare(value,array[start+hint+offset])>=0){lastOffset=offset\noffset=(offset << 1)+1\nif(offset <=0){offset=maxOffset}}\nif(offset > maxOffset){offset=maxOffset}\nlastOffset+=hint\noffset+=hint}\nlastOffset++\nwhile(lastOffset < offset){var m=lastOffset+((offset-lastOffset)>>> 1)\nif(compare(value,array[start+m])< 0){offset=m}else{lastOffset=m+1}}\nreturn offset}\nvar TIM_SORT_ASSERTION=\"TimSortAssertion\"\nvar TimSortAssertion=function(message){this.name=TIM_SORT_ASSERTION\nthis.message=message}\nvar TimSort=function(array,compare){var self={array:array,compare:compare,minGallop:DEFAULT_MIN_GALLOPING,length :array.length,tmpStorageLength:DEFAULT_TMP_STORAGE_LENGTH,stackLength:0,runStart:null,runLength:null,stackSize:0,\npushRun:function(runStart,runLength){this.runStart[this.stackSize]=runStart\nthis.runLength[this.stackSize]=runLength\nthis.stackSize+=1},\nmergeRuns:function(){while(this.stackSize > 1){var n=this.stackSize-2\nif((n >=1 && this.runLength[n-1]<=\nthis.runLength[n]+this.runLength[n+1])||\n(n >=2 && this.runLength[n-2]<=\nthis.runLength[n]+this.runLength[n-1])){if(this.runLength[n-1]< this.runLength[n+1]){n--}}else if(this.runLength[n]> this.runLength[n+1]){break}\nthis.mergeAt(n)}},\nforceMergeRuns:function(){while(this.stackSize > 1){var n=this.stackSize-2\nif(n > 0 && this.runLength[n-1]< this.runLength[n+1]){n--}\nthis.mergeAt(n)}},\nmergeAt:function(i){var compare=this.compare,array=this.array,start1=this.runStart[i],length1=this.runLength[i],start2=this.runStart[i+1],length2=this.runLength[i+1]\nthis.runLength[i]=length1+length2\nif(i===this.stackSize-3){this.runStart[i+1]=this.runStart[i+2]\nthis.runLength[i+1]=this.runLength[i+2]}\nthis.stackSize--;\nvar k=gallopRight(array[start2],array,start1,length1,0,compare)\nstart1+=k\nlength1-=k\nif(length1===0){return}\nlength2=gallopLeft(array[start1+length1-1],array,start2,length2,length2-1,compare)\nif(length2===0){return}\nif(length1 <=length2){this.mergeLow(start1,length1,start2,length2)}else{this.mergeHigh(start1,length1,start2,length2)}},\nmergeLow:function(start1,length1,start2,length2){var compare=this.compare,array=this.array,tmp=this.tmp,i=0\nfor(var i=0;i < length1;i++){tmp[i]=array[start1+i]}\nvar cursor1=0,cursor2=start2,dest=start1\narray[dest++]=array[cursor2++]\nif(--length2===0){for(var i=0;i < length1;i++){array[dest+i]=tmp[cursor1+i]}\nreturn}\nif(length1===1){for(var i=0;i < length2;i++){array[dest+i]=array[cursor2+i]}\narray[dest+length2]=tmp[cursor1]\nreturn}\nvar minGallop=this.minGallop\nwhile(true){var count1=0,count2=0,exit=false\ndo{if(compare(array[cursor2],tmp[cursor1])< 0){array[dest++]=array[cursor2++]\ncount2++\ncount1=0\nif(--length2===0){exit=true\nbreak}}else{array[dest++]=tmp[cursor1++]\ncount1++\ncount2=0\nif(--length1===1){exit=true\nbreak}}}while((count1 |count2)< minGallop)\nif(exit){break}\ndo{\ncount1=gallopRight(array[cursor2],tmp,cursor1,length1,0,compare)\nif(count1 !==0){for(var i=0;i < count1;i++){array[dest+i]=tmp[cursor1+i]}\ndest+=count1\ncursor1+=count1\nlength1-=count1\nif(length1 <=1){exit=true\nbreak}}\narray[dest++]=array[cursor2++]\nif(--length2===0){exit=true\nbreak}\ncount2=gallopLeft(tmp[cursor1],array,cursor2,length2,0,compare)\nif(count2 !==0){for(var i=0;i < count2;i++){array[dest+i]=array[cursor2+i]}\ndest+=count2\ncursor2+=count2\nlength2-=count2\nif(length2===0){exit=true\nbreak}}\narray[dest++]=tmp[cursor1++]\nif(--length1===1){exit=true\nbreak}\nminGallop--;}while(count1 >=DEFAULT_MIN_GALLOPING ||\ncount2 >=DEFAULT_MIN_GALLOPING);\nif(exit){break}\nif(minGallop < 0){minGallop=0}\nminGallop+=2}\nthis.minGallop=minGallop\nif(minGallop < 1){this.minGallop=1}\nif(length1===1){for(var i=0;i < length2;i++){array[dest+i]=array[cursor2+i]}\narray[dest+length2]=tmp[cursor1]}else if(length1===0){throw new TimSortAssertion('mergeLow preconditions were not respected')}else{for(var i=0;i < length1;i++){array[dest+i]=tmp[cursor1+i]}}},\nmergeHigh:function(start1,length1,start2,length2){var compare=this.compare,array=this.array,tmp=this.tmp,i=0\nfor(var i=0;i < length2;i++){tmp[i]=array[start2+i]}\nvar cursor1=start1+length1-1,cursor2=length2-1,dest=start2+length2-1,customCursor=0,customDest=0\narray[dest--]=array[cursor1--]\nif(--length1===0){customCursor=dest-(length2-1)\nfor(var i=0;i < length2;i++){array[customCursor+i]=tmp[i]}\nreturn}\nif(length2===1){dest-=length1\ncursor1-=length1\ncustomDest=dest+1\ncustomCursor=cursor1+1\nfor(var i=length1-1;i >=0;i--){array[customDest+i]=array[customCursor+i]}\narray[dest]=tmp[cursor2]\nreturn}\nvar minGallop=this.minGallop\nwhile(true){var count1=0,count2=0,exit=false\ndo{if(compare(tmp[cursor2],array[cursor1])< 0){array[dest--]=array[cursor1--]\ncount1++\ncount2=0\nif(--length1===0){exit=true\nbreak}}else{array[dest--]=tmp[cursor2--]\ncount2++\ncount1=0\nif(--length2===1){exit=true\nbreak}}}while((count1 |count2)< minGallop)\nif(exit){break}\ndo{count1=length1-gallopRight(tmp[cursor2],array,start1,length1,length1-1,compare)\nif(count1 !==0){dest-=count1\ncursor1-=count1\nlength1-=count1\ncustomDest=dest+1\ncustomCursor=cursor1+1\nfor(var i=count1-1;i >=0;i--){array[customDest+i]=array[customCursor+i]}\nif(length1===0){exit=true\nbreak}}\narray[dest--]=tmp[cursor2--]\nif(--length2===1){exit=true\nbreak}\ncount2=length2-gallopLeft(array[cursor1],tmp,0,length2,length2-1,compare)\nif(count2 !==0){dest-=count2\ncursor2-=count2\nlength2-=count2\ncustomDest=dest+1\ncustomCursor=cursor2+1\nfor(var i=0;i < count2;i++){array[customDest+i]=tmp[customCursor+i]}\nif(length2 <=1){exit=true\nbreak}}\narray[dest--]=array[cursor1--]\nif(--length1===0){exit=true\nbreak}\nminGallop--}while(count1 >=DEFAULT_MIN_GALLOPING ||\ncount2 >=DEFAULT_MIN_GALLOPING)\nif(exit){break}\nif(minGallop < 0){minGallop=0}\nminGallop+=2}\nthis.minGallop=minGallop\nif(minGallop < 1){this.minGallop=1}\nif(length2===1){dest-=length1\ncursor1-=length1\ncustomDest=dest+1\ncustomCursor=cursor1+1\nfor(var i=length1-1;i >=0;i--){array[customDest+i]=array[customCursor+i]}\narray[dest]=tmp[cursor2]}else if(length2==0){throw new TimSortAssertion(\"mergeHigh preconditions were not respected\")}else{customCursor=dest-(length2-1)\nfor(var i=0;i < length2;i++){array[customCursor+i]=tmp[i]}}}}\nif(self.length < 2*DEFAULT_TMP_STORAGE_LENGTH){self.tmpStorageLength=self.length >>> 1}\nself.tmp=new Array(self.tmpStorageLength)\nself.stackLength=\n(self.length < 120 ? 5 :\nself.length < 1542 ? 10 :\nself.length < 119151 ? 19 :40)\nself.runStart=new Array(self.stackLength)\nself.runLength=new Array(self.stackLength)\nreturn self}\nfunction tim_sort(array,compare,lo,hi){if(!Array.isArray(array)){throw _b_.TypeError.$factory(\"Can only sort arrays\")}\nif(!compare){compare=alphabeticalCompare}else if(typeof compare !==\"function\"){hi=lo\nlo=compare\ncompare=alphabeticalCompare}\nif(!lo){lo=0}\nif(!hi){hi=array.length}\nvar remaining=hi-lo\nif(remaining < 2){return}\nvar runLength=0\nif(remaining < DEFAULT_MIN_MERGE){runLength=makeAscendingRun(array,lo,hi,compare)\nbinaryInsertionSort(array,lo,hi,lo+runLength,compare)\nreturn}\nvar ts=new TimSort(array,compare)\nvar minRun=minRunLength(remaining)\ndo{runLength=makeAscendingRun(array,lo,hi,compare)\nif(runLength < minRun){var force=remaining\nif(force > minRun){force=minRun}\nbinaryInsertionSort(array,lo,lo+force,lo+runLength,compare)\nrunLength=force}\nts.pushRun(lo,runLength)\nts.mergeRuns()\nremaining-=runLength\nlo+=runLength}while(remaining !==0)\nts.forceMergeRuns()}\nfunction tim_sort_safe(array,compare){\ntry{\ntim_sort(array,compare,0,array.length)}catch(e){if(e.name==TIM_SORT_ASSERTION){array.sort(compare);}else{\nthrow e;}}}\n$B.$TimSort=tim_sort_safe\n$B.$AlphabeticalCompare=alphabeticalCompare})(__BRYTHON__)\n;\n\n;(function($B){var _b_=$B.builtins\n_b_.__debug__=false\n$B.$comps={'>':'gt','>=':'ge','<':'lt','<=':'le'}\n$B.$inv_comps={'>':'lt','>=':'le','<':'gt','<=':'ge'}\nvar check_nb_args=$B.check_nb_args=function(name,expected,args){\nvar len=args.length,last=args[len-1]\nif(last && last.$nat==\"kw\"){var kw=last.kw\nif(Array.isArray(kw)&& kw[1]&& kw[1].__class__===_b_.dict){if(Object.keys(kw[1].$string_dict).length==0){len--}}}\nif(len !=expected){if(expected==0){throw _b_.TypeError.$factory(name+\"() takes no argument\"+\n\" (\"+len+\" given)\")}else{throw _b_.TypeError.$factory(name+\"() takes exactly \"+\nexpected+\" argument\"+(expected < 2 ? '' :'s')+\n\" (\"+len+\" given)\")}}}\nvar check_no_kw=$B.check_no_kw=function(name,x,y){\nif(x===undefined){console.log(\"x undef\",name,x,y)}\nif((x.$nat && x.kw && x.kw[0]&& x.kw[0].length > 0)||\n(y !==undefined && y.$nat)){throw _b_.TypeError.$factory(name+\"() takes no keyword arguments\")}}\nvar NoneType={$factory:function(){return None},$infos:{__name__:\"NoneType\",__module__:\"builtins\"},__bool__:function(self){return False},__class__:_b_.type,__hash__:function(self){return 0},__mro__:[_b_.object],__repr__:function(self){return 'None'},__str__:function(self){return 'None'},$is_class:true}\nNoneType.__setattr__=function(self,attr){return no_set_attr(NoneType,attr)}\nvar None={__class__:NoneType,}\nfor(var $op in $B.$comps){\nvar key=$B.$comps[$op]\nswitch(key){case 'ge':\ncase 'gt':\ncase 'le':\ncase 'lt':\nNoneType['__'+key+'__']=(function(op){return function(other){return _b_.NotImplemented}})($op)}}\nfor(var $func in None){if(typeof None[$func]=='function'){None[$func].__str__=(function(f){return function(){return \"<method-wrapper \"+f+\n\" of NoneType object>\"}})($func)}}\n$B.set_func_names(NoneType,\"builtins\")\nfunction __build_class__(){throw _b_.NotImplementedError.$factory('__build_class__')}\nfunction abs(obj){check_nb_args('abs',1,arguments)\ncheck_no_kw('abs',obj)\nif(isinstance(obj,_b_.int)){if(obj.__class__===$B.long_int){return{\n__class__:$B.long_int,value:obj.value,pos:true}}else{return _b_.int.$factory(Math.abs(obj))}}\nif(isinstance(obj,_b_.float)){\nreturn _b_.float.$factory(Math.abs(_b_.float.numerator(obj)))}\nvar klass=obj.__class__ ||$B.get_class(obj)\ntry{var method=$B.$getattr(klass,\"__abs__\")}catch(err){if(err.__class__===_b_.AttributeError){throw _b_.TypeError.$factory(\"Bad operand type for abs(): '\"+\n$B.class_name(obj)+\"'\")}\nthrow err}\nreturn $B.$call(method)(obj)}\nfunction aiter(async_iterable){return $B.$call($B.$getattr(async_iterable,'__aiter__'))()}\nfunction all(obj){check_nb_args('all',1,arguments)\ncheck_no_kw('all',obj)\nvar iterable=iter(obj)\nwhile(1){try{var elt=next(iterable)\nif(!$B.$bool(elt)){return false}}catch(err){return true}}}\nfunction anext(async_iterator,_default){var missing={},$=$B.args('anext',2,{async_iterator:null,_default:null},['async_iterator','_default'],arguments,{_default:missing},null,null)\nvar awaitable=$B.$call($B.$getattr(async_iterator,'__anext__'))()\nreturn awaitable}\nfunction any(obj){check_nb_args('any',1,arguments)\ncheck_no_kw('any',obj)\nvar iterable=iter(obj)\nwhile(1){try{var elt=next(iterable)\nif($B.$bool(elt)){return true}}catch(err){return false}}}\nfunction ascii(obj){check_nb_args('ascii',1,arguments)\ncheck_no_kw('ascii',obj)\nvar res=repr(obj),res1='',cp\nfor(var i=0;i < res.length;i++){cp=res.charCodeAt(i)\nif(cp < 128){res1+=res.charAt(i)}\nelse if(cp < 256){res1+='\\\\x'+cp.toString(16)}\nelse{var s=cp.toString(16)\nif(s.length % 2==1){s=\"0\"+s}\nres1+='\\\\u'+s}}\nreturn res1}\nfunction $builtin_base_convert_helper(obj,base){var prefix=\"\";\nswitch(base){case 2:\nprefix='0b';break\ncase 8:\nprefix='0o';break\ncase 16:\nprefix='0x';break\ndefault:\nconsole.log('invalid base:'+base)}\nif(obj.__class__===$B.long_int){var res=prefix+$B.long_int.to_base(obj,base)\nif(! obj.pos){res=\"-\"+res}\nreturn res}\nvar value=$B.$GetInt(obj)\nif(value===undefined){\nthrow _b_.TypeError.$factory('Error, argument must be an integer or'+\n' contains an __index__ function')}\nif(value >=0){return prefix+value.toString(base)}\nreturn '-'+prefix+(-value).toString(base)}\nfunction bin_hex_oct(base,obj){\nif(isinstance(obj,_b_.int)){return $builtin_base_convert_helper(obj,base)}else{try{var klass=obj.__class__ ||$B.get_class(obj),method=$B.$getattr(klass,'__index__')}catch(err){if(err.__class__===_b_.AttributeError){throw _b_.TypeError.$factory(\"'\"+$B.class_name(obj)+\n\"' object cannot be interpreted as an integer\")}\nthrow err}\nvar res=$B.$call(method)(obj)\nreturn $builtin_base_convert_helper(res,base)}}\nfunction bin(obj){check_nb_args('bin',1,arguments)\ncheck_no_kw('bin',obj)\nreturn bin_hex_oct(2,obj)}\nfunction breakpoint(){\n$B.$import('sys',[])\nvar missing={},hook=$B.$getattr($B.imported.sys,'breakpointhook',missing)\nif(hook===missing){throw _b_.RuntimeError.$factory('lost sys.breakpointhook')}\nreturn $B.$call(hook).apply(null,arguments)}\nfunction callable(obj){check_nb_args('callable',1,arguments)\ncheck_no_kw('callable',obj)\nreturn hasattr(obj,'__call__')}\nfunction chr(i){check_nb_args('chr',1,arguments)\ncheck_no_kw('chr',i)\ni=$B.PyNumber_Index(i)\nif(i < 0 ||i > 1114111){throw _b_.ValueError.$factory('Outside valid range')}else if(i >=0x10000 && i <=0x10FFFF){var code=(i-0x10000)\nreturn String.fromCodePoint(0xD800 |(code >> 10))+\nString.fromCodePoint(0xDC00 |(code & 0x3FF))}else{return String.fromCodePoint(i)}}\nvar classmethod=$B.make_class(\"classmethod\",function(func){check_nb_args('classmethod',1,arguments)\ncheck_no_kw('classmethod',func)\nvar f=function(){return func.apply(null,arguments)}\nf.__class__=$B.method\nif(func.$attrs){for(var key in func.$attrs){f[key]=func.$attrs[key]}}\nf.$infos={__func__:func,__name__:func.$infos.__name__}\nf.__get__=function(obj,cls){var method=function(){return f(cls,...arguments)}\nmethod.__class__=$B.method\nmethod.$infos={__self__:cls,__func__:f,__name__:func.$infos.__name__,__qualname__:cls.$infos.__name__+\".\"+func.$infos.__name__}\nreturn method}\nf.__get__.__class__=$B.method_wrapper\nf.__get__.$infos=func.$infos\nreturn f}\n)\n$B.set_func_names(classmethod,\"builtins\")\nvar code=$B.code=$B.make_class(\"code\")\ncode.__repr__=code.__str__=function(self){return '<code object '+self.co_name+', file '+self.co_filename+'>'}\ncode.__getattribute__=function(self,attr){return self[attr]}\n$B.set_func_names(code,\"builtins\")\nfunction compile(){var $=$B.args('compile',6,{source:null,filename:null,mode:null,flags:null,dont_inherit:null,optimize:null,_feature_version:null},['source','filename','mode','flags','dont_inherit','optimize','_feature_version'],arguments,{flags:0,dont_inherit:false,optimize:-1,_feature_version:0},null,null)\nvar module_name='$exec_'+$B.UUID()\n$.__class__=code\n$.co_flags=$.flags\n$.name=\"<module>\"\nvar interactive=$.mode==\"single\" &&($.flags & 0x200)\nif(interactive && ! $.source.endsWith(\"\\n\")){\nvar lines=$.source.split(\"\\n\")\nif($B.last(lines).startsWith(\" \")){throw _b_.SyntaxError.$factory(\"unexpected EOF while parsing\")}}\nvar root=$B.parser.$create_root_node(\n{src:$.source,filename:$.filename},module_name,module_name)\nroot.parent_block=$B.builtins_scope\n$B.parser.dispatch_tokens(root,$.source)\nif($.flags==$B.PyCF_ONLY_AST){var ast=root.ast(),klass=ast.constructor.$name\n$B.create_python_ast_classes()\nreturn $B.python_ast_classes[klass].$factory(ast)}\nreturn $}\nvar __debug__=$B.debug > 0\nfunction delattr(obj,attr){\ncheck_no_kw('delattr',obj,attr)\ncheck_nb_args('delattr',2,arguments)\nif(typeof attr !='string'){throw _b_.TypeError.$factory(\"attribute name must be string, not '\"+\n$B.class_name(attr)+\"'\")}\nreturn $B.$getattr(obj,'__delattr__')(attr)}\n$B.$delete=function(name,is_global){\nfunction del(obj){if(obj.__class__===$B.generator){\nobj.js_gen.return()}}\nvar found=false,frame=$B.last($B.frames_stack)\nif(! is_global){if(frame[1][name]!==undefined){found=true\ndel(frame[1][name])\ndelete frame[1][name]}}else{if(frame[2]!=frame[0]&& frame[3][name]!==undefined){found=true\ndel(frame[3][name])\ndelete frame[3][name]}}\nif(!found){throw $B.name_error(name)}}\nfunction dir(obj){if(obj===undefined){\nvar frame=$B.last($B.frames_stack)\nlocals_obj=frame[1],res=_b_.list.$factory(),pos=0\nfor(var attr in locals_obj){if(attr.charAt(0)=='$' && attr.charAt(1)!='$'){\ncontinue}\nres[pos++]=attr}\n_b_.list.sort(res)\nreturn res}\ncheck_nb_args('dir',1,arguments)\ncheck_no_kw('dir',obj)\nvar klass=obj.__class__ ||$B.get_class(obj)\nif(obj.$is_class){\nvar dir_func=$B.$getattr(obj.__class__,\"__dir__\")\nreturn $B.$call(dir_func)(obj)}\ntry{var res=$B.$call($B.$getattr(obj,'__dir__'))()\nres=_b_.list.$factory(res)\nreturn res}catch(err){}\nvar res=[],pos=0\nfor(var attr in obj){if(attr.charAt(0)!=='$' && attr !=='__class__' &&\nobj[attr]!==undefined){res[pos++]=attr}}\nres.sort()\nreturn res}\nfunction divmod(x,y){check_no_kw('divmod',x,y)\ncheck_nb_args('divmod',2,arguments)\nvar klass=x.__class__ ||$B.get_class(x)\nvar dm=$B.$getattr(klass,\"__divmod__\",_b_.None)\nif(dm !==_b_.None){return dm(x,y)}\nreturn _b_.tuple.$factory([$B.$getattr(klass,'__floordiv__')(x,y),$B.$getattr(klass,'__mod__')(x,y)])}\nvar enumerate=$B.make_class(\"enumerate\",function(){var $ns=$B.args(\"enumerate\",2,{iterable:null,start:null},['iterable','start'],arguments,{start:0},null,null),_iter=iter($ns[\"iterable\"]),start=$ns[\"start\"]\nreturn{\n__class__:enumerate,__name__:'enumerate iterator',counter:start-1,iter:_iter,start:start}}\n)\nenumerate.__iter__=function(self){self.counter=self.start-1\nreturn self}\nenumerate.__next__=function(self){self.counter++\nreturn $B.fast_tuple([self.counter,next(self.iter)])}\n$B.set_func_names(enumerate,\"builtins\")\nfunction $$eval(src,_globals,_locals){var $=$B.args(\"eval\",4,{src:null,globals:null,locals:null,mode:null},[\"src\",\"globals\",\"locals\",\"mode\"],arguments,{globals:_b_.None,locals:_b_.None,mode:\"eval\"},null,null),src=$.src,_globals=$.globals,_locals=$.locals,mode=$.mode\nif($.src.mode && $.src.mode==\"single\" &&\n[\"<console>\",\"<stdin>\"].indexOf($.src.filename)>-1){\n_b_.print(\">\",$.src.source.trim())}\nif(src.__class__===code){mode=src.mode\nsrc=src.source}else if((! src.valueOf)||typeof src.valueOf()!=='string'){throw _b_.TypeError.$factory(`${mode}() arg 1 must be a string,`+\n\" bytes or code object\")}else{\nsrc=src.valueOf()}\nvar current_frame=$B.frames_stack[$B.frames_stack.length-1]\nif(current_frame !==undefined){var current_locals_id=current_frame[0].replace(/\\./g,'_'),current_globals_id=current_frame[2].replace(/\\./g,'_')}\nvar stack_len=$B.frames_stack.length\nvar globals_id='$exec_'+$B.UUID(),globals_name=globals_id,locals_id='$exec_'+$B.UUID(),parent_scope\nif(_globals===_b_.None){if(current_locals_id==current_globals_id){locals_id=globals_id}\nvar local_scope={module:globals_id,id:locals_id,binding:{},bindings:{}}\nfor(var attr in current_frame[1]){local_scope.binding[attr]=true\nlocal_scope.bindings[attr]=true}\nvar global_scope={module:globals_id,id:globals_id,binding:{},bindings:{}}\nfor(var attr in current_frame[3]){global_scope.binding[attr]=true\nglobal_scope.bindings[attr]=true}\nlocal_scope.parent_block=global_scope\nglobal_scope.parent_block=$B.builtins_scope\nparent_scope=local_scope\neval(\"$locals_\"+parent_scope.id+\" = current_frame[1]\")}else{\nif(_globals.__class__ !=_b_.dict){throw _b_.TypeError.$factory(\"exec() globals must be a dict, not \"+\n$B.class_name(_globals))}\nif(_globals.globals_id){globals_id=globals_name=_globals.globals_id}\n_globals.globals_id=globals_id\nif(_locals===_globals ||_locals===_b_.None){locals_id=globals_id\nparent_scope=$B.builtins_scope}else{\nvar grandparent_scope={id:globals_id,parent_block:$B.builtins_scope,binding:{}}\nparent_scope={id:locals_id,parent_block:grandparent_scope,binding:{}}\nfor(var attr in _globals.$string_dict){grandparent_scope.binding[attr]=true}\nfor(var attr in _locals.$string_dict){parent_scope.binding[attr]=true}}}\neval('var $locals_'+globals_id+' = {}\\nvar $locals_'+\nlocals_id+' = {}')\nif(_globals===_b_.None){var gobj=current_frame[3],ex='var $locals_'+globals_id+' = gobj;',obj={}\neval(ex)\nfor(var attr in gobj){if(attr.startsWith(\"$\")){continue}\nobj[attr]=gobj[attr]}\neval(\"$locals_\"+globals_id+\" = obj\")}else{var globals_is_dict=false\nif(_globals.$jsobj){var items=_globals.$jsobj}else{var items=_b_.dict.$to_obj(_globals)\n_globals.$jsobj=items\nglobals_is_dict=true}\neval(\"$locals_\"+globals_id+\" = _globals.$jsobj\")\nfor(var item in items){try{eval('$locals_'+globals_id+'[\"'+item+'\"] = items.'+item)}catch(err){console.log(err)\nconsole.log('error setting',item)\nbreak}}}\n_globals.$is_namespace=true\nif(_locals===_b_.None){if(_globals !==_b_.None){eval('var $locals_'+locals_id+' = $locals_'+globals_id)}else{var lobj=current_frame[1],ex='',obj={}\nfor(var attr in current_frame[1]){if(attr.startsWith(\"$\")){continue}\nobj[attr]=lobj[attr]}\neval('$locals_'+locals_id+\" = obj\")}}else{var items\nif(_locals.$jsobj){items=_locals.$jsobj}else if(_locals.__class__ !==_b_.dict){items=_locals}else{items=_b_.dict.$to_obj(_locals)\n_locals.$jsobj=items}\nfor(var item in items){try{eval('$locals_'+locals_id+'[\"'+item+'\"] = items.'+item)}catch(err){console.log(err)\nconsole.log('error setting',item)\nbreak}}\neval(\"$locals_\"+locals_id+\".$exec_locals = true\")\neval(\"$locals_\"+locals_id+\".$is_not_dict = \"+\n(_locals.__class__ !==_b_.dict))}\n_locals.$is_namespace=true\nif(_globals===_b_.None && _locals===_b_.None &&\ncurrent_frame[0]==current_frame[2]){}else{eval(\"$locals_\"+locals_id+\".$src = src\")}\nvar root=$B.py2js(src,globals_id,locals_id,parent_scope),js,gns,lns\nif(_globals !==_b_.None &&\n(_locals===_b_.None ||_locals===_globals)){for(var attr in _globals.$string_dict){root.binding[attr]=true}}\nfunction update_namespaces(){var gns=eval(\"$locals_\"+globals_id)\nif($B.frames_stack[$B.frames_stack.length-1][2]==globals_id){gns=$B.frames_stack[$B.frames_stack.length-1][3]}\nif(_locals !==_b_.None){var lns=eval(\"$locals_\"+locals_id)}\nif(_globals !==_b_.None){\nif(globals_is_dict){var jsobj=_globals.$jsobj\ndelete _globals.$jsobj}\nfor(var attr in gns){if(attr.charAt(0)!='$'){if(globals_is_dict){_b_.dict.$setitem(_globals,attr,gns[attr])}else{_globals.$jsobj[attr]=gns[attr]}}}\nfor(var attr in _globals.$string_dict){if(attr.startsWith(\"$\")){delete _globals.$string_dict[attr]}}}else{for(var attr in gns){if(attr !==\"$src\"){current_frame[3][attr]=gns[attr]}}}\nif(_locals !==_b_.None){for(var attr in lns){if(attr.charAt(0)!='$'){if(_locals.$jsobj){_locals.$jsobj[attr]=lns[attr]}else if(_locals.__class__ !==_b_.dict){$B.$setitem(_locals,attr,lns[attr])}else{_b_.dict.$setitem(_locals,attr,lns[attr])}}}}else{for(var attr in lns){if(attr !==\"$src\"){current_frame[1][attr]=lns[attr]}}}}\ntry{\nvar try_node=root.children[root.children.length-2],instr=try_node.children[try_node.children.length-2]\nvar type=instr.C.tree[0].type\nswitch(type){case 'expr':\ncase 'list_or_tuple':\ncase 'op':\ncase 'ternary':\ncase 'unary':\nvar children=try_node.children\nroot.children.splice(root.children.length-2,2)\nfor(var i=0;i < children.length-1;i++){root.add(children[i])}\nbreak\ndefault:\nif(mode==\"eval\"){throw _b_.SyntaxError.$factory(\n\"eval() argument must be an expression\",'<string>',1,1,src)}}\nif(mode !=\"eval\"){\nvar last=$B.last(root.children),js=last.to_js()\nif([\"node_js\"].indexOf(last.C.type)==-1){last.to_js=function(){while(js.endsWith(\"\\n\")){js=js.substr(0,js.length-1)}\nwhile(js.endsWith(\";\")){js=js.substr(0,js.length-1)}\nreturn \"return (\"+js+\")\"}}\njs=root.to_js()\nvar locals_obj=eval(\"$locals_\"+locals_id),globals_obj=eval(\"$locals_\"+globals_id)\nif(_globals===_b_.None){var res=new Function(\"$locals_\"+globals_id,\"$locals_\"+locals_id,js)(\nglobals_obj,locals_obj)}else{current_globals_obj=current_frame[3]\ncurrent_locals_obj=current_frame[1]\nvar res=new Function(\"$locals_\"+globals_id,\"$locals_\"+locals_id,\"$locals_\"+current_globals_id,\"$locals_\"+current_locals_id,js)(globals_obj,locals_obj,current_globals_obj,current_locals_obj)}\nif($.src.mode && $.src.mode==\"single\" &&\n$.src.filename==\"<stdin>\"){if(res !==_b_.None && res !==undefined){_b_.print(_b_.repr(res))}}}else{js=root.to_js()\nvar res=eval(js)}\nif($.src.filename==\"<console>\" && $.src.mode==\"single\" &&\nres !==undefined && res !==_b_.None){_b_.print(res)}\nupdate_namespaces()\nif(res===undefined){return _b_.None}\nreturn res}catch(err){update_namespaces()\nerr.src=src\nerr.module=globals_id\nif(err.$py_error===undefined){console.log('Javascript error',Object.getPrototypeOf(err).name,err.message)\nvar lineNumber=err.lineNumber\nif(lineNumber !==undefined){console.log('around JS line',lineNumber)\nconsole.log(js.split('\\n').\nslice(lineNumber-5,lineNumber+5).join('\\n'))\nvar lines_before=js.split('\\n').slice(0,lineNumber),re=new RegExp('line_info = \"(.*?)\"','g'),matches=(new String(lines_before)).matchAll(re),line_info\nfor(var match of matches){line_info=match[1]}\nif(line_info){console.log('around source line',line_info.split(',')[0])}}\nthrow $B.exception(err)}\nif(globals_is_dict){delete _globals.$jsobj}\nthrow err}finally{\nif($B.frames_stack.length==stack_len+1){$B.frames_stack.pop()}\nroot=null\njs=null\ngns=null\nlns=null\n$B.clear_ns(globals_id)\n$B.clear_ns(locals_id)}}\n$$eval.$is_func=true\nfunction exec(src,globals,locals){var missing={}\nvar $=$B.args(\"exec\",3,{src:null,globals:null,locals:null},[\"src\",\"globals\",\"locals\"],arguments,{globals:_b_.None,locals:_b_.None},null,null),src=$.src,globals=$.globals,locals=$.locals\nreturn $$eval(src,globals,locals,\"exec\")||_b_.None}\nexec.$is_func=true\nfunction exit(){throw _b_.SystemExit}\nexit.__repr__=exit.__str__=function(){return \"Use exit() or Ctrl-Z plus Return to exit\"}\nvar filter=$B.make_class(\"filter\",function(func,iterable){check_no_kw('filter',func,iterable)\ncheck_nb_args('filter',2,arguments)\niterable=iter(iterable)\nif(func===_b_.None){func=$B.$bool}\nreturn{\n__class__:filter,func:func,iterable:iterable}}\n)\nfilter.__iter__=function(self){return self}\nfilter.__next__=function(self){while(true){var _item=next(self.iterable)\nif(self.func(_item)){return _item}}}\n$B.set_func_names(filter,\"builtins\")\nfunction format(value,format_spec){var $=$B.args(\"format\",2,{value:null,format_spec:null},[\"value\",\"format_spec\"],arguments,{format_spec:''},null,null)\nvar klass=value.__class__ ||$B.get_class(value)\ntry{var method=$B.$getattr(klass,'__format__')}catch(err){if(err.__class__===_b_.AttributeError){throw _b_.NotImplementedError(\"__format__ is not implemented \"+\n\"for object '\"+_b_.str.$factory(value)+\"'\")}\nthrow err}\nreturn $B.$call(method)(value,$.format_spec)}\nfunction attr_error(attr,obj){var cname=$B.get_class(obj)\nvar msg=\"bad operand type for unary #: '\"+cname+\"'\"\nswitch(attr){case '__neg__':\nthrow _b_.TypeError.$factory(msg.replace('#','-'))\ncase '__pos__':\nthrow _b_.TypeError.$factory(msg.replace('#','+'))\ncase '__invert__':\nthrow _b_.TypeError.$factory(msg.replace('#','~'))\ncase '__call__':\nthrow _b_.TypeError.$factory(\"'\"+cname+\"'\"+\n' object is not callable')\ndefault:\nthrow $B.attr_error(attr,obj)}}\nfunction getattr(){var missing={}\nvar $=$B.args(\"getattr\",3,{obj:null,attr:null,_default:null},[\"obj\",\"attr\",\"_default\"],arguments,{_default:missing},null,null)\nreturn $B.$getattr($.obj,$.attr,$._default===missing ? undefined :$._default)}\nfunction in_mro(klass,attr){if(klass===undefined){return false}\nif(klass.hasOwnProperty(attr)){return klass[attr]}\nvar mro=klass.__mro__\nfor(var i=0,len=mro.length;i < len;i++){if(mro[i].hasOwnProperty(attr)){return mro[i][attr]}}\nreturn false}\n$B.$getattr=function(obj,attr,_default){\nif(obj.$method_cache &&\nobj.$method_cache[attr]&&\nobj.__class__ &&\nobj.__class__[attr]==obj.$method_cache[attr][1]){\nreturn obj.$method_cache[attr][0]}\nvar rawname=attr\nif(obj===undefined){console.log(\"get attr\",attr,\"of undefined\")}\nvar is_class=obj.$is_class ||obj.$factory\nvar klass=obj.__class__\nvar $test=false \nif($test){console.log(\"$getattr\",attr,'\\nobj',obj,'\\nklass',klass)}\nif(klass !==undefined &&(! klass.$native)&& klass.__bases__ &&\nklass.__getattribute__===undefined &&\n(klass.__bases__.length==0 ||\n(klass.__bases__.length==1 &&\nklass.__bases__[0]===_b_.object))){if($test){console.log(\"class without parent\",klass)\nconsole.log('\\nobj[attr]',obj[attr])}\nif(obj[attr]!==undefined){return obj[attr]}else if(obj.__dict__ &&\nobj.__dict__.$string_dict.hasOwnProperty(attr)&&\n!(klass.hasOwnProperty(attr)&&\nklass[attr].__get__)){return obj.__dict__.$string_dict[attr][0]}else if(klass.hasOwnProperty(attr)){if(typeof klass[attr]!=\"function\" &&\nattr !=\"__dict__\" &&\nklass[attr].__get__===undefined){var kl=klass[attr].__class__\nif(! in_mro(kl,\"__get__\")){return klass[attr]}}}}\nif($test){console.log(\"attr\",attr,\"of\",obj,\"class\",klass,\"isclass\",is_class)}\nif(klass===undefined){\nif(typeof obj=='string'){klass=_b_.str}\nelse if(typeof obj=='number'){klass=obj % 1==0 ? _b_.int :_b_.float}else if(obj instanceof Number){klass=_b_.float}else{klass=$B.get_class(obj)\nif(klass===undefined){\nif($test){console.log(\"no class\",attr,obj.hasOwnProperty(attr),obj[attr])}\nvar res=obj[attr]\nif(res !==undefined){if(typeof res==\"function\"){var f=function(){\nreturn res.apply(obj,arguments)}\nf.$infos={__name__:attr,__qualname__:attr}\nreturn f}else{return $B.$JS2Py(res)}}\nif(_default !==undefined){return _default}\nthrow $B.attr_error(rawname,obj)}}}\nswitch(attr){case '__call__':\nif(typeof obj=='function'){var res=function(){return obj.apply(null,arguments)}\nres.__class__=method_wrapper\nres.$infos={__name__:\"__call__\"}\nreturn res}\nbreak\ncase '__class__':\nreturn klass\ncase '__dict__':\nif(is_class){var proxy={}\nfor(var key in obj){if(! key.startsWith(\"$\")){proxy[key]=obj[key]}}\nproxy.__dict__=$B.getset_descriptor.$factory(obj,\"__dict__\")\nreturn $B.mappingproxy.$factory(proxy)}else if(! klass.$native){if(obj[attr]!==undefined){return obj[attr]}else if(obj.$infos){if(obj.$infos.hasOwnProperty(\"__dict__\")){return obj.$infos.__dict__}else if(obj.$infos.hasOwnProperty(\"__func__\")){return obj.$infos.__func__.$infos.__dict__}}\nreturn $B.obj_dict(obj,function(attr){return['__class__'].indexOf(attr)>-1}\n)}\ncase '__doc__':\nfor(var i=0;i < builtin_names.length;i++){if(obj===_b_[builtin_names[i]]){_get_builtins_doc()\nreturn $B.builtins_doc[builtin_names[i]]}}\nbreak\ncase '__mro__':\nif(obj.$is_class){\nreturn _b_.tuple.$factory([obj].concat(obj.__mro__))}else if(obj.__dict__ &&\nobj.__dict__.$string_dict.__mro__ !==undefined){return obj.__dict__.$string_dict.__mro__}\nthrow $B.attr_error(attr,obj)\ncase '__subclasses__':\nif(klass.$factory ||klass.$is_class){var subclasses=obj.$subclasses ||[]\nreturn function(){return subclasses}}\nbreak}\nif(typeof obj=='function'){var value=obj[attr]\nif(value !==undefined){if(attr=='__module__'){return value}}}\nif((! is_class)&& klass.$native){if(obj.$method_cache && obj.$method_cache[attr]){return obj.$method_cache[attr]}\nif($test){console.log(\"native class\",klass,klass[attr])}\nif(attr==\"__doc__\" && klass[attr]===undefined && klass.$infos){_get_builtins_doc()\nklass[attr]=$B.builtins_doc[klass.$infos.__name__]}\nif(klass[attr]===undefined){var object_attr=_b_.object[attr]\nif($test){console.log(\"object attr\",object_attr)}\nif(object_attr !==undefined){klass[attr]=object_attr}else{if($test){console.log(\"obj[attr]\",obj[attr])}\nvar attrs=obj.__dict__\nif(attrs &&\n(object_attr=attrs.$string_dict[attr])!==undefined){return object_attr[0]}\nif(_default===undefined){throw $B.attr_error(attr,obj)}\nreturn _default}}\nif(klass.$descriptors && klass.$descriptors[attr]!==undefined){return klass[attr](obj)}\nif(typeof klass[attr]=='function'){var func=klass[attr]\nif(attr=='__new__'){func.$type=\"staticmethod\"}\nif(func.$type==\"staticmethod\"){return func}\nvar self=klass[attr].__class__==$B.method ? klass :obj,method=klass[attr].bind(null,self)\nmethod.__class__=$B.method\nmethod.$infos={__func__:func,__name__:attr,__self__:self,__qualname__:klass.$infos.__name__+\".\"+attr}\nif(typeof obj==\"object\"){\nobj.__class__=klass\nobj.$method_cache=obj.$method_cache ||{}\nobj.$method_cache[attr]=method}\nreturn method}else if(klass[attr]!==undefined){return klass[attr]}\nattr_error(rawname,klass)}\nvar mro,attr_func\nif(is_class){attr_func=_b_.type.__getattribute__ }else{attr_func=klass.__getattribute__\nif(attr_func===undefined){var mro=klass.__mro__\nif(mro===undefined){console.log(obj,attr,\"no mro, klass\",klass)}\nfor(var i=0,len=mro.length;i < len;i++){attr_func=mro[i]['__getattribute__']\nif(attr_func !==undefined){break}}}}\nif(typeof attr_func !=='function'){console.log(attr+' is not a function '+attr_func,klass)}\nvar odga=_b_.object.__getattribute__\nif($test){console.log(\"attr_func is odga ?\",attr_func,attr_func===odga,'\\nobj[attr]',obj[attr])}\nif(attr_func===odga){var res=obj[attr]\nif(Array.isArray(obj)&& Array.prototype[attr]!==undefined){\nres=undefined}else if(res===null){return null}else if(res===undefined && obj[attr]!==undefined){if(_default===undefined){throw $B.attr_error(attr,obj)}\nreturn _default}else if(res !==undefined){if($test){console.log(obj,attr,obj[attr],res.__set__ ||res.$is_class)}\nif(res.$is_property){return property.__get__(res)}\nif(res.__set__===undefined ||res.$is_class){if($test){console.log(\"return\",res,res+'',res.__set__,res.$is_class)}\nreturn res}}}\ntry{var res=attr_func(obj,attr)\nif($test){console.log(\"result of attr_func\",res)}}catch(err){if(_default !==undefined){return _default}\nthrow err}\nif(res !==undefined){return res}\nif(_default !==undefined){return _default}\nvar cname=klass.$infos.__name__\nif(is_class){cname=obj.$infos.__name__}\nattr_error(rawname,is_class ? obj :klass)}\nfunction globals(){\ncheck_nb_args('globals',0,arguments)\nvar res=$B.obj_dict($B.last($B.frames_stack)[3])\nres.$jsobj.__BRYTHON__=$B.JSObj.$factory($B)\nres.$is_namespace=true\nreturn res}\nfunction hasattr(obj,attr){check_no_kw('hasattr',obj,attr)\ncheck_nb_args('hasattr',2,arguments)\ntry{$B.$getattr(obj,attr)\nreturn true}catch(err){return false}}\nvar hash_cache={}\nfunction hash(obj){check_no_kw('hash',obj)\ncheck_nb_args('hash',1,arguments)\nif(obj.__hashvalue__ !==undefined){return obj.__hashvalue__}\nif(isinstance(obj,_b_.bool)){return _b_.int.$factory(obj)}\nif(obj.$is_class ||\nobj.__class__===_b_.type ||\nobj.__class__===$B.Function){return obj.__hashvalue__=$B.$py_next_hash--}\nif(typeof obj==\"string\"){var cached=hash_cache[obj]\nif(cached !==undefined){return cached}\nelse{return hash_cache[obj]=_b_.str.__hash__(obj)}}\nvar klass=obj.__class__ ||$B.get_class(obj)\nif(klass===undefined){throw _b_.TypeError.$factory(\"unhashable type: '\"+\n_b_.str.$factory($B.JSObj.$factory(obj))+\"'\")}\nvar hash_method=$B.$getattr(klass,'__hash__',_b_.None)\nif(hash_method===_b_.None){throw _b_.TypeError.$factory(\"unhashable type: '\"+\n$B.class_name(obj)+\"'\")}\nif(hash_method.$infos.__func__===_b_.object.__hash__){if($B.$getattr(obj,'__eq__').$infos.__func__ !==_b_.object.__eq__){throw _b_.TypeError.$factory(\"unhashable type: '\"+\n$B.class_name(obj)+\"'\",'hash')}else{return obj.__hashvalue__=_b_.object.__hash__(obj)}}else{return $B.$call(hash_method)(obj)}}\nfunction _get_builtins_doc(){if($B.builtins_doc===undefined){\nvar url=$B.brython_path\nif(url.charAt(url.length-1)=='/'){url=url.substr(0,url.length-1)}\nurl+='/builtins_docstrings.js'\nvar f=_b_.open(url)\neval(f.$content)\n$B.builtins_doc=docs}}\nfunction help(obj){if(obj===undefined){obj='help'}\nif(typeof obj=='string' && _b_[obj]!==undefined){_get_builtins_doc()\nvar _doc=$B.builtins_doc[obj]\nif(_doc !==undefined && _doc !=''){_b_.print(_doc)\nreturn}}\nfor(var i=0;i < builtin_names.length;i++){if(obj===_b_[builtin_names[i]]){_get_builtins_doc()\n_b_.print(_doc=$B.builtins_doc[builtin_names[i]])}}\nif(typeof obj=='string'){$B.$import(\"pydoc\");\nvar pydoc=$B.imported[\"pydoc\"]\n$B.$getattr($B.$getattr(pydoc,\"help\"),\"__call__\")(obj)\nreturn}\ntry{return $B.$getattr(obj,'__doc__')}\ncatch(err){return ''}}\nhelp.__repr__=help.__str__=function(){return \"Type help() for interactive help, or help(object) \"+\n\"for help about object.\"}\nfunction hex(obj){check_no_kw('hex',obj)\ncheck_nb_args('hex',1,arguments)\nreturn bin_hex_oct(16,obj)}\nfunction id(obj){check_no_kw('id',obj)\ncheck_nb_args('id',1,arguments)\nif(isinstance(obj,[_b_.str,_b_.int,_b_.float])&&\n!isinstance(obj,$B.long_int)){return $B.$getattr(_b_.str.$factory(obj),'__hash__')()}else if(obj.$id !==undefined){return obj.$id}\nelse{return obj.$id=$B.UUID()}}\nfunction __import__(mod_name,globals,locals,fromlist,level){\nvar $=$B.args('__import__',5,{name:null,globals:null,locals:null,fromlist:null,level:null},['name','globals','locals','fromlist','level'],arguments,{globals:None,locals:None,fromlist:_b_.tuple.$factory(),level:0},null,null)\nreturn $B.$__import__($.name,$.globals,$.locals,$.fromlist)}\nfunction input(msg){var res=prompt(msg ||'')||''\nif($B.imported[\"sys\"]&& $B.imported[\"sys\"].ps1){\nvar ps1=$B.imported[\"sys\"].ps1,ps2=$B.imported[\"sys\"].ps2\nif(msg==ps1 ||msg==ps2){console.log(msg,res)}}\nreturn res}\nfunction isinstance(obj,cls){check_no_kw('isinstance',obj,cls)\ncheck_nb_args('isinstance',2,arguments)\nif(obj===null){return cls===None}\nif(obj===undefined){return false}\nif(Array.isArray(cls)){for(var kls of cls){if(isinstance(obj,kls)){return true}}\nreturn false}\nif(cls.__class__===$B.GenericAlias){\nthrow _b_.TypeError.$factory(\n'isinstance() arg 2 cannot be a parameterized generic')}\nif(!cls.__class__ ||\n!(cls.$factory !==undefined ||cls.$is_class !==undefined)){throw _b_.TypeError.$factory(\"isinstance() arg 2 must be a type \"+\n\"or tuple of types\")}\nif(cls===_b_.int &&(obj===True ||obj===False)){return True}\nif(cls===_b_.bool){switch(typeof obj){case \"string\":\nreturn false\ncase \"number\":\nreturn false\ncase \"boolean\":\nreturn true}}\nvar klass=obj.__class__\nif(klass==undefined){if(typeof obj=='string'){if(cls==_b_.str){return true}\nelse if($B.builtin_classes.indexOf(cls)>-1){return false}}else if(obj.contructor===Number && Number.isFinite(obj)){if(cls==_b_.float){return true}}else if(typeof obj=='number' && Number.isFinite(obj)){if(Number.isFinite(obj)&& cls==_b_.int){return true}}\nklass=$B.get_class(obj)}\nif(klass===undefined){return false}\nfunction check(kl,cls){if(kl===cls){return true}\nelse if(cls===_b_.str && kl===$B.StringSubclass){return true}\nelse if(cls===_b_.int && kl===$B.IntSubclass){return true}}\nif(check(klass,cls)){return true}\nvar mro=klass.__mro__\nfor(var i=0;i < mro.length;i++){if(check(mro[i],cls)){return true}}\nvar instancecheck=$B.$getattr(cls.__class__ ||$B.get_class(cls),'__instancecheck__',_b_.None)\nif(instancecheck !==_b_.None){return instancecheck(cls,obj)}\nreturn false}\nfunction issubclass(klass,classinfo){check_no_kw('issubclass',klass,classinfo)\ncheck_nb_args('issubclass',2,arguments)\nif(!klass.__class__ ||\n!(klass.$factory !==undefined ||klass.$is_class !==undefined)){throw _b_.TypeError.$factory(\"issubclass() arg 1 must be a class\")}\nif(isinstance(classinfo,_b_.tuple)){for(var i=0;i < classinfo.length;i++){if(issubclass(klass,classinfo[i])){return true}}\nreturn false}\nif(classinfo.__class__===$B.GenericAlias){throw _b_.TypeError.$factory(\n'issubclass() arg 2 cannot be a parameterized generic')}\nif(classinfo.$factory ||classinfo.$is_class){if(klass===classinfo ||\nklass.__mro__.indexOf(classinfo)>-1){return true}}\nvar sch=$B.$getattr(classinfo.__class__ ||$B.get_class(classinfo),'__subclasscheck__',_b_.None)\nif(sch==_b_.None){return false}\nreturn sch(classinfo,klass)}\nvar iterator_class=$B.make_class(\"iterator\",function(getitem,len){return{\n__class__:iterator_class,getitem:getitem,len:len,counter:-1}}\n)\niterator_class.__next__=function(self){self.counter++\nif(self.len !==null && self.counter==self.len){throw _b_.StopIteration.$factory('')}\ntry{return self.getitem(self.counter)}\ncatch(err){throw _b_.StopIteration.$factory('')}}\n$B.set_func_names(iterator_class,\"builtins\")\ncallable_iterator=$B.make_class(\"callable_iterator\",function(func,sentinel){return{\n__class__:callable_iterator,func:func,sentinel:sentinel}}\n)\ncallable_iterator.__iter__=function(self){return self}\ncallable_iterator.__next__=function(self){var res=self.func()\nif($B.rich_comp(\"__eq__\",res,self.sentinel)){throw _b_.StopIteration.$factory()}\nreturn res}\n$B.set_func_names(callable_iterator,\"builtins\")\n$B.$iter=function(obj,sentinel){\nif(sentinel===undefined){var klass=obj.__class__ ||$B.get_class(obj)\ntry{var _iter=$B.$call($B.$getattr(klass,'__iter__'))}catch(err){if(err.__class__===_b_.AttributeError){try{var gi_method=$B.$call($B.$getattr(klass,'__getitem__')),gi=function(i){return gi_method(obj,i)},ln=len(obj)\nreturn iterator_class.$factory(gi,len)}catch(err){throw _b_.TypeError.$factory(\"'\"+$B.class_name(obj)+\n\"' object is not iterable\")}}\nthrow err}\nvar res=$B.$call(_iter)(obj)\ntry{$B.$getattr(res,'__next__')}\ncatch(err){if(isinstance(err,_b_.AttributeError)){throw _b_.TypeError.$factory(\n\"iter() returned non-iterator of type '\"+\n$B.class_name(res)+\"'\")}}\nreturn res}else{return callable_iterator.$factory(obj,sentinel)}}\nfunction iter(){\nvar $=$B.args('iter',1,{obj:null},['obj'],arguments,{},'args','kw'),sentinel\nif($.args.length > 0){var sentinel=$.args[0]}\nreturn $B.$iter($.obj,sentinel)}\nfunction len(obj){check_no_kw('len',obj)\ncheck_nb_args('len',1,arguments)\nvar klass=obj.__class__ ||$B.get_class(obj)\ntry{var method=$B.$getattr(klass,'__len__')}catch(err){throw _b_.TypeError.$factory(\"object of type '\"+\n$B.class_name(obj)+\"' has no len()\")}\nreturn $B.$call(method)(obj)}\nfunction locals(){\ncheck_nb_args('locals',0,arguments)\nvar res=$B.obj_dict($B.clone($B.last($B.frames_stack)[1]))\nres.$is_namespace=true\ndelete res.$jsobj.__annotations__\nreturn res}\nvar map=$B.make_class(\"map\",function(){var $=$B.args('map',2,{func:null,it1:null},['func','it1'],arguments,{},'args',null),func=$B.$call($.func)\nvar iter_args=[$B.$iter($.it1)]\n$.args.forEach(function(item){iter_args.push($B.$iter(item))})\nvar obj={__class__:map,args:iter_args,func:func}\nreturn obj}\n)\nmap.__iter__=function(self){return self}\nmap.__next__=function(self){var args=[]\nfor(var i=0;i < self.args.length;i++){args.push(next(self.args[i]))}\nreturn self.func.apply(null,args)}\n$B.set_func_names(map,\"builtins\")\nfunction $extreme(args,op){\nvar $op_name='min'\nif(op==='__gt__'){$op_name=\"max\"}\nvar $=$B.args($op_name,0,{},[],args,{},'args','kw')\nvar has_default=false,func=false\nfor(var attr in $.kw.$string_dict){switch(attr){case 'key':\nfunc=$.kw.$string_dict[attr][0]\nbreak\ncase 'default':\nvar default_value=$.kw.$string_dict[attr][0]\nhas_default=true\nbreak\ndefault:\nthrow _b_.TypeError.$factory(\"'\"+attr+\n\"' is an invalid keyword argument for this function\")}}\nif((! func)||func===_b_.None){func=x=> x}\nif($.args.length==0){throw _b_.TypeError.$factory($op_name+\n\" expected 1 arguments, got 0\")}else if($.args.length==1){\nvar $iter=iter($.args[0]),res=null,x_value,extr_value\nwhile(true){try{var x=next($iter)\nif(res===null){extr_value=func(x)\nres=x}else{x_value=func(x)\nif($B.rich_comp(op,x_value,extr_value)){res=x\nextr_value=x_value}}}catch(err){if(err.__class__==_b_.StopIteration){if(res===null){if(has_default){return default_value}else{throw _b_.ValueError.$factory($op_name+\n\"() arg is an empty sequence\")}}else{return res}}\nthrow err}}}else{if(has_default){throw _b_.TypeError.$factory(\"Cannot specify a default for \"+\n$op_name+\"() with multiple positional arguments\")}\nif($B.last(args).$nat){var _args=[$.args].concat($B.last(args))}else{var _args=[$.args]}\nreturn $extreme.call(null,_args,op)}}\nfunction max(){return $extreme(arguments,'__gt__')}\nvar memoryview=$B.make_class('memoryview',function(obj){check_no_kw('memoryview',obj)\ncheck_nb_args('memoryview',1,arguments)\nif(obj.__class__===memoryview){return obj}\nif($B.get_class(obj).$buffer_protocol){return{\n__class__:memoryview,obj:obj,\nformat:'B',itemsize:1,ndim:1,shape:_b_.tuple.$factory([_b_.len(obj)]),strides:_b_.tuple.$factory([1]),suboffsets:_b_.tuple.$factory([]),c_contiguous:true,f_contiguous:true,contiguous:true}}else{throw _b_.TypeError.$factory(\"memoryview: a bytes-like object \"+\n\"is required, not '\"+$B.class_name(obj)+\"'\")}}\n)\nmemoryview.$match_sequence_pattern=true,\nmemoryview.__eq__=function(self,other){if(other.__class__ !==memoryview){return false}\nreturn $B.$getattr(self.obj,'__eq__')(other.obj)}\nmemoryview.__getitem__=function(self,key){if(isinstance(key,_b_.int)){var start=key*self.itemsize\nif(self.format==\"I\"){var res=self.obj.source[start],coef=256\nfor(var i=1;i < 4;i++){res+=self.obj.source[start+i]*coef\ncoef*=256}\nreturn res}else if(\"B\".indexOf(self.format)>-1){if(key > self.obj.source.length-1){throw _b_.KeyError.$factory(key)}\nreturn self.obj.source[key]}else{\nreturn self.obj.source[key]}}\nvar res=self.obj.__class__.__getitem__(self.obj,key)\nif(key.__class__===_b_.slice){return memoryview.$factory(res)}}\nmemoryview.__len__=function(self){return len(self.obj)/self.itemsize}\nmemoryview.__setitem__=function(self,key,value){try{$B.$setitem(self.obj,key,value)}catch(err){throw _b_.TypeError.$factory(\"cannot modify read-only memory\")}}\nmemoryview.cast=function(self,format){switch(format){case \"B\":\nreturn memoryview.$factory(self.obj)\ncase \"I\":\nvar res=memoryview.$factory(self.obj),objlen=len(self.obj)\nres.itemsize=4\nres.format=\"I\"\nif(objlen % 4 !=0){throw _b_.TypeError.$factory(\"memoryview: length is not \"+\n\"a multiple of itemsize\")}\nreturn res}}\nmemoryview.hex=function(self){var res='',bytes=_b_.bytes.$factory(self)\nbytes.source.forEach(function(item){res+=item.toString(16)})\nreturn res}\nmemoryview.tobytes=function(self){return _b_.bytes.$factory(self.obj)}\nmemoryview.tolist=function(self){if(self.itemsize==1){return _b_.list.$factory(_b_.bytes.$factory(self.obj))}else if(self.itemsize==4){if(self.format==\"I\"){var res=[]\nfor(var i=0;i < self.obj.source.length;i+=4){var item=self.obj.source[i],coef=256\nfor(var j=1;j < 4;j++){item+=coef*self.obj.source[i+j]\ncoef*=256}\nres.push(item)}\nreturn res}}}\n$B.set_func_names(memoryview,\"builtins\")\nfunction min(){return $extreme(arguments,'__lt__')}\nfunction next(obj){check_no_kw('next',obj)\nvar missing={},$=$B.args(\"next\",2,{obj:null,def:null},['obj','def'],arguments,{def:missing},null,null)\nvar klass=obj.__class__ ||$B.get_class(obj),ga=$B.$call($B.$getattr(klass,\"__next__\"))\nif(ga !==undefined){try{return $B.$call(ga)(obj)}catch(err){if(err.__class__===_b_.StopIteration &&\n$.def !==missing){return $.def}\nthrow err}}\nthrow _b_.TypeError.$factory(\"'\"+$B.class_name(obj)+\n\"' object is not an iterator\")}\nvar NotImplementedType=$B.make_class(\"NotImplementedType\",function(){return NotImplemented}\n)\nNotImplementedType.__repr__=NotImplementedType.__str__=function(self){return \"NotImplemented\"}\n$B.set_func_names(NotImplementedType,\"builtins\")\nvar NotImplemented={__class__:NotImplementedType}\nfunction $not(obj){return !$B.$bool(obj)}\nfunction oct(obj){check_no_kw('oct',obj)\ncheck_nb_args('oct',1,arguments)\nreturn bin_hex_oct(8,obj)}\nfunction ord(c){check_no_kw('ord',c)\ncheck_nb_args('ord',1,arguments)\nif(typeof c.valueOf()=='string'){if(c.length==1){return c.charCodeAt(0)}\nif((0xD800 <=c[0]&& c[0]<=0xDBFF)||\n(0xDC00 <=c[1]&& c[1]<=0xDFFF)){throw _b_.TypeError.$factory('ord() expected a character, but '+\n'string of length '+c.length+' found')}\nvar code=0x10000\ncode+=(c.charCodeAt(0)& 0x03FF)<< 10\ncode+=(c.charCodeAt(1)& 0x03FF)\nreturn code}\nswitch($B.get_class(c)){case _b_.str:\nif(c.length==1){return c.charCodeAt(0)}\nthrow _b_.TypeError.$factory('ord() expected a character, but '+\n'string of length '+c.length+' found')\ncase _b_.bytes:\ncase _b_.bytearray:\nif(c.source.length==1){return c.source[0]}\nthrow _b_.TypeError.$factory('ord() expected a character, but '+\n'string of length '+c.source.length+' found')\ndefault:\nthrow _b_.TypeError.$factory('ord() expected a character, but '+\n$B.class_name(c)+' was found')}}\nfunction pow(){var $=$B.args('pow',3,{x:null,y:null,mod:null},['x','y','mod'],arguments,{mod:None},null,null),x=$.x,y=$.y,z=$.mod\nvar klass=x.__class__ ||$B.get_class(x)\nif(z===_b_.None){return $B.rich_op('pow',x,y)}else{if(x !=_b_.int.$factory(x)||y !=_b_.int.$factory(y)){throw _b_.TypeError.$factory(\"pow() 3rd argument not allowed \"+\n\"unless all arguments are integers\")}\nreturn $B.$call($B.$getattr(klass,'__pow__'))(x,y,z)}}\nfunction $print(){var $ns=$B.args('print',0,{},[],arguments,{},'args','kw')\nvar ks=$ns['kw'].$string_dict\nvar end=(ks['end']===undefined ||ks['end']===None)? '\\n' :ks['end'][0],sep=(ks['sep']===undefined ||ks['sep']===None)? ' ' :ks['sep'][0],file=ks['file']===undefined ? $B.stdout :ks['file'][0],args=$ns['args'],writer=$B.$getattr(file,'write')\nvar items=[]\nfor(var i=0,len=args.length;i < len;i++){var arg=_b_.str.$factory(args[i])\nwriter(arg)\nif(i < len-1){writer(sep)}}\nwriter(end)\nvar flush=$B.$getattr(file,'flush',None)\nif(flush !==None){$B.$call(flush)()}\nreturn None}\n$print.__name__='print'\n$print.is_func=true\nvar property=$B.make_class(\"property\",function(fget,fset,fdel,doc){var res={__class__:property}\nproperty.__init__(res,fget,fset,fdel,doc)\nreturn res}\n)\nproperty.__init__=function(self,fget,fset,fdel,doc){var $=$B.args('__init__',5,{self:null,fget:null,fset:null,fdel:null,doc:null},['self','fget','fset','fdel','doc'],arguments,{fget:_b_.None,fset:_b_.None,fdel:_b_.None,doc:_b_.None},null,null),self=$.self,fget=$.fget,fset=$.fset,fdel=$.fdel,doc=$.doc\nself.__doc__=doc ||\"\"\nself.$type=fget.$type\nself.fget=fget\nself.fset=fset\nself.fdel=fdel\nself.$is_property=true\nif(fget && fget.$attrs){for(var key in fget.$attrs){self[key]=fget.$attrs[key]}}\nself.__delete__=fdel;\nself.getter=function(fget){return property.$factory(fget,self.fset,self.fdel,self.__doc__)}\nself.setter=function(fset){return property.$factory(self.fget,fset,self.fdel,self.__doc__)}\nself.deleter=function(fdel){return property.$factory(self.fget,self.fset,fdel,self.__doc__)}}\nproperty.__get__=function(self,obj){if(self.fget===undefined){throw _b_.AttributeError.$factory(\"unreadable attribute\")}\nreturn $B.$call(self.fget)(obj)}\nproperty.__repr__=function(self){$B.builtins_repr_check(property,arguments)\nreturn _b_.repr(self.fget(self))}\nproperty.__set__=function(self,obj,value){if(self.fset===undefined){throw _b_.AttributeError.$factory(\"can't set attribute\")}\n$B.$getattr(self.fset,'__call__')(obj,value)}\n$B.set_func_names(property,\"builtins\")\nfunction quit(){throw _b_.SystemExit}\nquit.__repr__=quit.__str__=function(){return \"Use quit() or Ctrl-Z plus Return to exit\"}\nfunction repr(obj){check_no_kw('repr',obj)\ncheck_nb_args('repr',1,arguments)\nvar klass=obj.__class__ ||$B.get_class(obj)\nreturn $B.$call($B.$getattr(klass,\"__repr__\"))(obj)}\nvar reversed=$B.make_class(\"reversed\",function(seq){\ncheck_no_kw('reversed',seq)\ncheck_nb_args('reversed',1,arguments)\nvar klass=seq.__class__ ||$B.get_class(seq),rev_method=$B.$getattr(klass,'__reversed__',null)\nif(rev_method !==null){return $B.$call(rev_method)(seq)}\ntry{var method=$B.$getattr(klass,'__getitem__')}catch(err){throw _b_.TypeError.$factory(\"argument to reversed() must be a sequence\")}\nvar res={__class__:reversed,$counter :_b_.len(seq),getter:function(i){return $B.$call(method)(seq,i)}}\nreturn res}\n)\nreversed.__iter__=function(self){return self}\nreversed.__next__=function(self){self.$counter--\nif(self.$counter < 0){throw _b_.StopIteration.$factory('')}\nreturn self.getter(self.$counter)}\n$B.set_func_names(reversed,\"builtins\")\nfunction round(){var $=$B.args('round',2,{number:null,ndigits:null},['number','ndigits'],arguments,{ndigits:None},null,null),arg=$.number,n=$.ndigits===None ? 0 :$.ndigits\nif(!isinstance(arg,[_b_.int,_b_.float])){var klass=arg.__class__ ||$B.get_class(arg)\ntry{return $B.$call($B.$getattr(klass,\"__round__\")).apply(null,arguments)}catch(err){if(err.__class__===_b_.AttributeError){throw _b_.TypeError.$factory(\"type \"+$B.class_name(arg)+\n\" doesn't define __round__ method\")}else{throw err}}}\nif(isinstance(arg,_b_.float)&&\n(arg.value===Infinity ||arg.value===-Infinity)){throw _b_.OverflowError.$factory(\"cannot convert float infinity to integer\")}\nif(!isinstance(n,_b_.int)){throw _b_.TypeError.$factory(\n\"'\"+$B.class_name(n)+\"' object cannot be interpreted as an integer\")}\nvar mult=Math.pow(10,n),x=arg*mult,floor=Math.floor(x),diff=Math.abs(x-floor),res\nif(diff==0.5){if(floor % 2){floor+=1}\nres=_b_.int.__truediv__(floor,mult)}else{res=_b_.int.__truediv__(Math.round(x),mult)}\nif($.ndigits===None){\nreturn res.valueOf()}else if(arg instanceof Number){return new Number(res)}else{return res.valueOf()}}\nfunction setattr(){var $=$B.args('setattr',3,{obj:null,attr:null,value:null},['obj','attr','value'],arguments,{},null,null),obj=$.obj,attr=$.attr,value=$.value\nif(!(typeof attr=='string')){throw _b_.TypeError.$factory(\"setattr(): attribute name must be string\")}\nreturn $B.$setattr(obj,attr,value)}\n$B.$setattr=function(obj,attr,value){\nvar $test=false \nif(attr=='__dict__'){\nif(! isinstance(value,_b_.dict)){throw _b_.TypeError.$factory(\"__dict__ must be set to a dictionary, \"+\n\"not a '\"+$B.class_name(value)+\"'\")}\nif(obj.$infos){obj.$infos.__dict__=value\nreturn None}\nobj.__dict__=value\nreturn None}else if(attr==\"__class__\"){\nfunction error(msg){throw _b_.TypeError.$factory(msg)}\nif(value.__class__){if(value.__module__==\"builtins\"){error(\"__class__ assignement only \"+\n\"supported for heap types or ModuleType subclasses\")}else if(Array.isArray(value.__bases__)){for(var i=0;i < value.__bases__.length;i++){if(value.__bases__[i]!==_b_.object &&\nvalue.__bases__[i].__module__==\"builtins\"){error(\"__class__ assignment: '\"+$B.class_name(obj)+\n\"' object layout differs from '\"+\n$B.class_name(value)+\"'\")}}}}\nobj.__class__=value\nreturn None}else if(attr==\"__doc__\" && obj.__class__===_b_.property){obj[attr]=value}\nif($test){console.log(\"set attr\",attr,\"to\",obj)}\nif(obj.$factory ||obj.$is_class){var metaclass=obj.__class__\nif($test){console.log(\"obj is class\",metaclass,metaclass[attr])}\nif(metaclass && metaclass[attr]&& metaclass[attr].__get__ &&\nmetaclass[attr].__set__){metaclass[attr].__set__(obj,value)\nreturn None}\nif(attr==\"__module__\"){obj.$infos.__module__=value\nreturn _b_.None}\nif(obj.$infos && obj.$infos.__module__==\"builtins\"){throw _b_.TypeError.$factory(\n\"can't set attributes of built-in/extension type '\"+\nobj.$infos.__name__+\"'\")}\nobj[attr]=value\nif(attr==\"__init__\" ||attr==\"__new__\"){\nobj.$factory=$B.$instance_creator(obj)}else if(attr==\"__bases__\"){\nobj.__mro__=_b_.type.mro(obj)}\nif($test){console.log(\"after setattr\",obj)}\nreturn None}\nvar res=obj[attr],klass=obj.__class__ ||$B.get_class(obj)\nif($test){console.log('set attr',attr,'of obj',obj,'class',klass,\"obj[attr]\",obj[attr])}\nif(res===undefined && klass){res=klass[attr]\nif(res===undefined){var mro=klass.__mro__,_len=mro.length\nfor(var i=0;i < _len;i++){res=mro[i][attr]\nif(res !==undefined){break}}}}\nif($test){console.log('set attr',attr,'klass',klass,'found in class',res)}\nif(res !==undefined && res !==null){\nif(res.__get__ && res.__set__===undefined){throw _b_.AttributeError.$factory(\"can't set attribute '\"+attr+\n\"'\")}\nif(res.__set__ !==undefined){res.__set__(res,obj,value);return None}\nvar rcls=res.__class__,__set1__\nif(rcls !==undefined){var __set1__=rcls.__set__\nif(__set1__===undefined){var mro=rcls.__mro__\nfor(var i=0,_len=mro.length;i < _len;i++){__set1__=mro[i].__set__\nif(__set1__){break}}}}\nif(__set1__ !==undefined){var __set__=$B.$getattr(res,'__set__',null)\nif(__set__ &&(typeof __set__=='function')){__set__.apply(res,[obj,value])\nreturn None}}else if(klass && klass.$descriptors !==undefined &&\nklass[attr]!==undefined){var setter=klass[attr].setter\nif(typeof setter=='function'){setter(obj,value)\nreturn None}else{throw _b_.AttributeError.$factory('readonly attribute')}}}\nvar _setattr=false\nif(klass !==undefined){_setattr=klass.__setattr__\nif(_setattr===undefined){var mro=klass.__mro__\nfor(var i=0,_len=mro.length-1;i < _len;i++){_setattr=mro[i].__setattr__\nif(_setattr){break}}}}\nvar special_attrs=[\"__module__\"]\nif(klass && klass.__slots__ && special_attrs.indexOf(attr)==-1 &&\n! _setattr){function mangled_slots(klass){if(klass.__slots__){if(Array.isArray(klass.__slots__)){return klass.__slots__.map(function(item){if(item.startsWith(\"__\")&& ! item.endsWith(\"_\")){return \"_\"+klass.$infos.__name__+item}else{return item}})}else{return klass.__slots__}}\nreturn[]}\nvar has_slot=false\nif(mangled_slots(klass).indexOf(attr)>-1){has_slot=true}else{for(var i=0;i < klass.__mro__.length;i++){var kl=klass.__mro__[i]\nif(mangled_slots(kl).indexOf(attr)>-1){has_slot=true\nbreak}}}\nif(! has_slot){throw $B.attr_error(attr,klass)}}\nif($test){console.log(\"attr\",attr,\"use _setattr\",_setattr)}\nif(!_setattr){if(obj.__dict__===undefined){obj[attr]=value}else{_b_.dict.$setitem(obj.__dict__,attr,value)}\nif($test){console.log(\"no setattr, obj\",obj)}}else{_setattr(obj,attr,value)}\nreturn None}\nfunction sorted(){var $=$B.args('sorted',1,{iterable:null},['iterable'],arguments,{},null,'kw')\nvar _list=_b_.list.$factory(iter($.iterable)),args=[_list]\nfor(var i=1;i < arguments.length;i++){args.push(arguments[i])}\n_b_.list.sort.apply(null,args)\nreturn _list}\nvar staticmethod=$B.make_class(\"staticmethod\",function(func){var f={$infos:func.$infos,__get__:function(){return func}}\nf.__get__.__class__=$B.method_wrapper\nf.__get__.$infos=func.$infos\nreturn f}\n)\n$B.set_func_names(staticmethod,\"builtins\")\nfunction sum(iterable,start){var $=$B.args('sum',2,{iterable:null,start:null},['iterable','start'],arguments,{start:0},null,null),iterable=$.iterable,start=$.start\nif(_b_.isinstance(start,[_b_.str,_b_.bytes])){throw _b_.TypeError.$factory(\"sum() can't sum bytes\"+\n\" [use b''.join(seq) instead]\")}\nvar res=start,iterable=iter(iterable)\nwhile(1){try{var _item=next(iterable)\nres=$B.add(res,_item)}catch(err){if(err.__class__===_b_.StopIteration){break}else{throw err}}}\nreturn res}\n$B.missing_super2=function(obj){obj.$missing=true\nreturn obj}\nvar $$super=$B.make_class(\"super\",function(_type,object_or_type){var no_object_or_type=object_or_type===undefined\nif(_type===undefined && object_or_type===undefined){var frame=$B.last($B.frames_stack),pyframe=$B.imported[\"_sys\"].Getframe()\nif(pyframe.f_code && pyframe.f_code.co_varnames){_type=frame[1].__class__\nif(_type===undefined){throw _b_.RuntimeError.$factory(\"super(): no arguments\")}\nobject_or_type=frame[1][pyframe.f_code.co_varnames[0]]}else{throw _b_.RuntimeError.$factory(\"super(): no arguments\")}}\nif(! no_object_or_type && Array.isArray(object_or_type)){object_or_type=object_or_type[0]}\nreturn{\n__class__:$$super,__thisclass__:_type,__self_class__:object_or_type}}\n)\n$$super.__get__=function(self,instance,klass){\nreturn $$super.$factory(self.__thisclass__,instance)}\n$$super.__getattribute__=function(self,attr){var mro=self.__thisclass__.__mro__,res\nif(self.__thisclass__.$is_js_class){if(attr==\"__init__\"){\nreturn function(){mro[0].$js_func.call(self.__self_class__,...arguments)}}}\nvar sc=self.__self_class__\nif(sc !==undefined){if(!sc.$is_class){sc=sc.__class__ ||$B.get_class(sc)}\nvar sc_mro=[sc].concat(sc.__mro__)\nfor(var i=0;i < sc_mro.length;i++){if(sc_mro[i]===self.__thisclass__){mro=sc_mro.slice(i+1)\nbreak}}}\nvar $test=false \nvar f\nfor(var i=0,len=mro.length;i < len;i++){if(mro[i][attr]!==undefined){f=mro[i][attr]\nbreak}}\nif(f===undefined){if($$super[attr]!==undefined){return(function(x){return function(){var args=[x]\nfor(var i=0,len=arguments.length;i < len;i++){args.push(arguments[i])}\nreturn $$super[attr].apply(null,args)}})(self)}\nif($test){console.log(\"no attr\",attr,self,\"mro\",mro)}\nthrow $B.attr_error(attr,self)}\nif($test){console.log(\"super\",attr,self,\"mro\",mro,\"found in mro[0]\",mro[0],f,f+'')}\nif(f.$type==\"staticmethod\" ||attr==\"__new__\"){return f}else if(typeof f !=\"function\"){return f}else{if(f.__class__===$B.method){\nf=f.$infos.__func__}\nvar callable=$B.$call(f)\nvar method=function(){var res=callable(self.__self_class__,...arguments)\nif($test){console.log(\"calling super\",self.__self_class__,attr,f,\"res\",res)}\nreturn res}\nmethod.__class__=$B.method\nvar module\nif(f.$infos !==undefined){module=f.$infos.__module__}else if(f.__class__===property){module=f.fget.$infos.__module}else if(f.$is_class){module=f.__module__}\nmethod.$infos={__self__:self.__self_class__,__func__:f,__name__:attr,__module__:module,__qualname__:self.__thisclass__.$infos.__name__+\".\"+attr}\nreturn method}\nthrow $B.attr_error(attr,self)}\n$$super.__init__=function(cls){if(cls===undefined){throw _b_.TypeError.$factory(\"descriptor '__init__' of 'super' \"+\n\"object needs an argument\")}\nif(cls.__class__ !==$$super){throw _b_.TypeError.$factory(\"descriptor '__init__' requires a\"+\n\" 'super' object but received a '\"+$B.class_name(cls)+\"'\")}}\n$$super.__repr__=function(self){$B.builtins_repr_check($$super,arguments)\nvar res=\"<super: <class '\"+self.__thisclass__.$infos.__name__+\"'>\"\nif(self.__self_class__ !==undefined){res+=', <'+self.__self_class__.__class__.$infos.__name__+' object>'}else{res+=', NULL'}\nreturn res+'>'}\n$B.set_func_names($$super,\"builtins\")\nfunction vars(){var def={},$=$B.args('vars',1,{obj:null},['obj'],arguments,{obj:def},null,null)\nif($.obj===def){return _b_.locals()}else{try{return $B.$getattr($.obj,'__dict__')}\ncatch(err){if(err.__class__===_b_.AttributeError){throw _b_.TypeError.$factory(\"vars() argument must have __dict__ attribute\")}\nthrow err}}}\nvar $Reader=$B.make_class(\"Reader\")\n$Reader.__enter__=function(self){return self}\n$Reader.__exit__=function(self){return false}\n$Reader.__iter__=function(self){\nreturn iter($Reader.readlines(self))}\n$Reader.__len__=function(self){return self.lines.length}\n$Reader.close=function(self){self.closed=true}\n$Reader.flush=function(self){return None}\n$Reader.read=function(){var $=$B.args(\"read\",2,{self:null,size:null},[\"self\",\"size\"],arguments,{size:-1},null,null),self=$.self,size=$B.$GetInt($.size)\nif(self.closed===true){throw _b_.ValueError.$factory('I/O operation on closed file')}\nif(size < 0){size=self.$length-self.$counter}\nif(self.$binary){res=_b_.bytes.$factory(self.$content.source.slice(self.$counter,self.$counter+size))}else{res=self.$content.substr(self.$counter,size)}\nself.$counter+=size\nreturn res}\n$Reader.readable=function(self){return true}\nfunction make_lines(self){\nif(self.$lines===undefined){if(! self.$binary){self.$lines=self.$content.split(\"\\n\")\nif($B.last(self.$lines)==''){self.$lines.pop()}\nself.$lines=self.$lines.map(x=> x+'\\n')}else{var lines=[],pos=0,source=self.$content.source\nwhile(pos < self.$length){var ix=source.indexOf(10,pos)\nif(ix==-1){lines.push({__class__:_b_.bytes,source:source.slice(pos)})\nbreak}else{lines.push({__class__:_b_.bytes,source:source.slice(pos,ix+1)})\npos=ix+1}}\nself.$lines=lines}}}\n$Reader.readline=function(self,size){var $=$B.args(\"readline\",2,{self:null,size:null},[\"self\",\"size\"],arguments,{size:-1},null,null),self=$.self,size=$B.$GetInt($.size)\nself.$lc=self.$lc===undefined ?-1 :self.$lc\nif(self.closed===true){throw _b_.ValueError.$factory('I/O operation on closed file')}\nif(self.$binary){var ix=self.$content.source.indexOf(10,self.$counter)\nif(ix==-1){var rest=self.$content.source.slice(self.$counter)\nself.$counter=self.$content.source.length\nreturn _b_.bytes.$factory(rest)}else{var res={__class__:_b_.bytes,source :self.$content.source.slice(self.$counter,ix+1)}\nself.$counter=ix+1\nreturn res}}else{if(self.$counter==self.$content.length){return ''}\nvar ix=self.$content.indexOf(\"\\n\",self.$counter)\nif(ix==-1){var rest=self.$content.substr(self.$counter)\nself.$counter=self.$content.length\nreturn rest}else{var res=self.$content.substring(self.$counter,ix+1)\nself.$counter=ix+1\nself.$lc+=1\nreturn res}}}\n$Reader.readlines=function(){var $=$B.args(\"readlines\",2,{self:null,hint:null},[\"self\",\"hint\"],arguments,{hint:-1},null,null),self=$.self,hint=$B.$GetInt($.hint)\nvar nb_read=0\nif(self.closed===true){throw _b_.ValueError.$factory('I/O operation on closed file')}\nself.$lc=self.$lc===undefined ?-1 :self.$lc\nmake_lines(self)\nif(hint < 0){var lines=self.$lines.slice(self.$lc+1)}else{var lines=[]\nwhile(self.$lc < self.$lines.length &&\nnb_read < hint){self.$lc++\nlines.push(self.$lines[self.$lc])}}\nreturn lines}\n$Reader.seek=function(self,offset,whence){if(self.closed===True){throw _b_.ValueError.$factory('I/O operation on closed file')}\nif(whence===undefined){whence=0}\nif(whence===0){self.$counter=offset}else if(whence===1){self.$counter+=offset}else if(whence===2){self.$counter=self.$length+offset}\nreturn None}\n$Reader.seekable=function(self){return true}\n$Reader.tell=function(self){return self.$counter}\n$Reader.writable=function(self){return false}\n$B.set_func_names($Reader,\"builtins\")\nvar $BufferedReader=$B.make_class('_io.BufferedReader')\n$BufferedReader.__mro__=[$Reader,_b_.object]\nvar $TextIOWrapper=$B.make_class('_io.TextIOWrapper',function(){var $=$B.args(\"TextIOWrapper\",6,{buffer:null,encoding:null,errors:null,newline:null,line_buffering:null,write_through:null},[\"buffer\",\"encoding\",\"errors\",\"newline\",\"line_buffering\",\"write_through\"],arguments,{encoding:\"utf-8\",errors:_b_.None,newline:_b_.None,line_buffering:_b_.False,write_through:_b_.False},null,null)\nreturn{\n__class__:$TextIOWrapper,$content:_b_.bytes.decode($.buffer.$content,$.encoding),encoding:$.encoding,errors:$.errors,newline:$.newline}}\n)\n$TextIOWrapper.__mro__=[$Reader,_b_.object]\n$B.set_func_names($TextIOWrapper,\"builtins\")\n$B.Reader=$Reader\n$B.TextIOWrapper=$TextIOWrapper\n$B.BufferedReader=$BufferedReader\nfunction $url_open(){\nvar $=$B.args('open',3,{file:null,mode:null,encoding:null},['file','mode','encoding'],arguments,{mode:'r',encoding:'utf-8'},'args','kw'),file=$.file,mode=$.mode,encoding=$.encoding,result={}\nif(mode.search('w')>-1){throw _b_.IOError.$factory(\"Browsers cannot write on disk\")}else if(['r','rb'].indexOf(mode)==-1){throw _b_.ValueError.$factory(\"Invalid mode '\"+mode+\"'\")}\nif(isinstance(file,_b_.str)){\nvar is_binary=mode.search('b')>-1\nif($B.file_cache.hasOwnProperty($.file)){result.content=$B.file_cache[$.file]\nif(is_binary){result.content=_b_.str.encode(result.content,'utf-8')}}else if($B.files && $B.files.hasOwnProperty($.file)){\nvar $res=atob($B.files[$.file].content)\nvar source=[]\nfor(const char of $res){source.push(char.charCodeAt(0))}\nresult.content=_b_.bytes.$factory(source)\nif(!is_binary){\ntry{result.content=_b_.bytes.decode(result.content,encoding)}catch(error){result.error=error}}}else if($B.protocol !=\"file\"){\nvar req=new XMLHttpRequest()\nreq.overrideMimeType('text/plain;charset=x-user-defined')\nreq.onreadystatechange=function(){if(this.readyState !=4){return}\nvar status=this.status\nif(status==404){result.error=_b_.FileNotFoundError.$factory(file)}else if(status !=200){result.error=_b_.IOError.$factory('Could not open file '+\nfile+' : status '+status)}else{var bytes=[]\nfor(var i=0,len=this.response.length;i < len;i++){var cp=this.response.codePointAt(i)\nif(cp > 0xf700){cp-=0xf700}\nbytes.push(cp)}\nresult.content=_b_.bytes.$factory(bytes)\nif(! is_binary){\ntry{result.content=_b_.bytes.decode(result.content,encoding)}catch(error){result.error=error}}}}\nvar fake_qs=$B.$options.cache ? '' :\n'?foo='+(new Date().getTime())\nreq.open('GET',encodeURI(file+fake_qs),false)\nreq.send()}else{throw _b_.FileNotFoundError.$factory(\n\"cannot use 'open()' with protocol 'file'\")}\nif(result.error !==undefined){throw result.error}\nvar res={$binary:is_binary,$content:result.content,$counter:0,$encoding:encoding,$length:is_binary ? result.content.source.length :\nresult.content.length,closed:False,mode,name:file}\nres.__class__=is_binary ? $BufferedReader :$TextIOWrapper\nreturn res}else{throw _b_.TypeError.$factory(\"invalid argument for open(): \"+\n_b_.str.$factory(file))}}\nvar zip=$B.make_class(\"zip\",function(){var res={__class__:zip,items:[]}\nif(arguments.length==0){return res}\nvar $ns=$B.args('zip',0,{},[],arguments,{},'args','kw')\nvar _args=$ns['args'],strict=$ns.kw.$string_dict.strict &&\n$ns.kw.$string_dict.strict[0]\nvar args=[],nexts=[],only_lists=true,min_len\nfor(var i=0;i < _args.length;i++){if(only_lists && Array.isArray(_args[i])){if(strict){if(i==0){var len=_args[i].length}else if(_args[i]!=len){throw _b_.ValueError.$factory(`zip() argument ${i} `+\n`is ${_args[i] > len ? 'longer' : 'shorter'} `+\n`than argument ${i - 1}`)}}\nif(min_len===undefined ||_args[i].length < min_len){min_len=_args[i].length}}else{only_lists=false}\nvar _next=$B.$call($B.$getattr(iter(_args[i]),\"__next__\"))\nargs.push(_next)}\nvar rank=0,items=[]\nif(only_lists){$B.nb_zip_list=$B.nb_zip_list===undefined ?\n1 :$B.nb_zip_list+1\nfor(var i=0;i < min_len;i++){var line=[]\nfor(var j=0;j < _args.length;j++){line.push(_args[j][i])}\nitems.push($B.fast_tuple(line))}\nres.items=items\nreturn zip_iterator.$factory(items)}\nfunction*iterator(args){while(true){var line=[],flag=true\nfor(var i=0;i < args.length;i++){try{line.push(args[i]())}catch(err){if(err.__class__==_b_.StopIteration){if(strict){if(i > 0){throw _b_.ValueError.$factory(\n`zip() argument ${i + 1} is shorter `+\n`than argument ${i}`)}else{for(var j=1;j < args.length;j++){var exhausted=true\ntry{args[j]()\nexhausted=false}catch(err){}\nif(! exhausted){throw _b_.ValueError.$factory(\n`zip() argument ${j + 1} is longer `+\n`than argument ${i + 1}`)}}}}\nflag=false\nbreak}else{throw err}}}\nif(! flag){return}\nyield $B.fast_tuple(line)}}\nreturn $B.generator.$factory(iterator,'zip')(args)}\n)\nvar zip_iterator=$B.make_iterator_class('zip')\nzip.__iter__=function(self){return zip_iterator.$factory(self.items)}\n$B.set_func_names(zip,\"builtins\")\nfunction no_set_attr(klass,attr){if(klass[attr]!==undefined){throw _b_.AttributeError.$factory(\"'\"+klass.$infos.__name__+\n\"' object attribute '\"+attr+\"' is read-only\")}else{throw $B.attr_error(attr,klass)}}\nvar True=true\nvar False=false\nvar ellipsis=$B.make_class(\"ellipsis\",function(){return Ellipsis}\n)\nellipsis.__repr__=function(self){return 'Ellipsis'}\nvar Ellipsis={__class__:ellipsis}\nfor(var $key in $B.$comps){\nswitch($B.$comps[$key]){case 'ge':\ncase 'gt':\ncase 'le':\ncase 'lt':\nellipsis['__'+$B.$comps[$key]+'__']=(function(k){return function(other){throw _b_.TypeError.$factory(\"unorderable types: ellipsis() \"+\nk+\" \"+$B.class_name(other))}})($key)}}\nfor(var $func in Ellipsis){if(typeof Ellipsis[$func]=='function'){Ellipsis[$func].__str__=(function(f){return function(){return \"<method-wrapper \"+f+\n\" of Ellipsis object>\"}})($func)}}\n$B.set_func_names(ellipsis)\nvar FunctionCode=$B.make_class(\"function code\")\nvar FunctionGlobals=$B.make_class(\"function globals\")\n$B.Function={__class__:_b_.type,__code__:{__class__:FunctionCode,__name__:'function code'},__globals__:{__class__:FunctionGlobals,__name__:'function globals'},__mro__:[_b_.object],$infos:{__name__:'function',__module__:\"builtins\"},$is_class:true}\n$B.Function.__delattr__=function(self,attr){if(attr==\"__dict__\"){throw _b_.TypeError.$factory(\"can't deleted function __dict__\")}}\n$B.Function.__dir__=function(self){var infos=self.$infos ||{},attrs=self.$attrs ||{}\nreturn Object.keys(infos).concat(Object.keys(attrs))}\n$B.Function.__eq__=function(self,other){return self===other}\n$B.Function.__get__=function(self,obj){if(obj===_b_.None){return self}\nvar method=function(){return self(obj,...arguments)}\nmethod.__class__=$B.method\nif(self.$infos===undefined){console.log(\"no $infos\",self)\nconsole.log($B.last($B.frames_stack))}\nmethod.$infos={__name__:self.$infos.__name__,__qualname__:$B.class_name(obj)+\".\"+self.$infos.__name__,__self__:obj,__func__:self}\nreturn method}\n$B.Function.__getattribute__=function(self,attr){\nif(self.$infos && self.$infos[attr]!==undefined){if(attr=='__code__'){var res={__class__:code}\nfor(var attr in self.$infos.__code__){res[attr]=self.$infos.__code__[attr]}\nres.name=self.$infos.__name__\nres.filename=self.$infos.__code__.co_filename\nres.co_code=self+\"\" \nreturn res}else if(attr=='__annotations__'){\nreturn $B.obj_dict(self.$infos[attr])}else if(self.$infos.hasOwnProperty(attr)){return self.$infos[attr]}}else if(self.$infos && self.$infos.__dict__ &&\nself.$infos.__dict__.$string_dict[attr]!==undefined){return self.$infos.__dict__.$string_dict[attr][0]}else if(attr==\"__closure__\"){var free_vars=self.$infos.__code__.co_freevars\nif(free_vars.length==0){return None}\nvar cells=[]\nfor(var i=0;i < free_vars.length;i++){try{cells.push($B.cell.$factory($B.$check_def_free(free_vars[i])))}catch(err){\ncells.push($B.cell.$factory(None))}}\nreturn _b_.tuple.$factory(cells)}else if(attr==\"__globals__\"){return $B.obj_dict($B.imported[self.$infos.__module__])}else if(self.$attrs && self.$attrs[attr]!==undefined){return self.$attrs[attr]}else{return _b_.object.__getattribute__(self,attr)}}\n$B.Function.__repr__=function(self){if(self.$infos===undefined){return '<function '+self.name+'>'}else{return '<function '+self.$infos.__qualname__+'>'}}\n$B.Function.__mro__=[_b_.object]\n$B.Function.__setattr__=function(self,attr,value){if(attr==\"__closure__\"){throw _b_.AttributeError.$factory(\"readonly attribute\")}else if(attr==\"__defaults__\"){\nif(value===_b_.None){value=[]}else if(! isinstance(value,_b_.tuple)){throw _b_.TypeError.$factory(\n\"__defaults__ must be set to a tuple object\")}\nvar set_func=self.$set_defaults\nif(set_func===undefined){throw _b_.AttributeError.$factory(\"cannot set attribute \"+attr+\n\" of \"+_b_.str.$factory(self))}\nif(self.$infos && self.$infos.__code__){\nvar argcount=self.$infos.__code__.co_argcount,varnames=self.$infos.__code__.co_varnames,params=varnames.slice(0,argcount),$defaults={}\nfor(var i=value.length-1;i >=0;i--){var pos=params.length-value.length+i\nif(pos < 0){break}\n$defaults[params[pos]]=value[i]}}else{throw _b_.AttributeError.$factory(\"cannot set attribute \"+attr+\n\" of \"+_b_.str.$factory(self))}\nvar klass=self.$infos.$class \nvar new_func=set_func($defaults)\nnew_func.$set_defaults=set_func\nif(klass){klass[self.$infos.__name__]=new_func\nnew_func.$infos.$class=klass\nnew_func.$infos.__defaults__=value}else{\nself.$infos.$defaults=value\nself.$infos.__defaults__=value}\nreturn _b_.None}\nif(self.$infos[attr]!==undefined){self.$infos[attr]=value}\nelse{self.$attrs=self.$attrs ||{};self.$attrs[attr]=value}}\n$B.Function.$factory=function(){}\n$B.set_func_names($B.Function,\"builtins\")\n_b_.__BRYTHON__=__BRYTHON__\n$B.builtin_funcs=[\"__build_class__\",\"abs\",\"aiter\",\"all\",\"anext\",\"any\",\"ascii\",\"bin\",\"breakpoint\",\"callable\",\"chr\",\"compile\",\"delattr\",\"dir\",\"divmod\",\"eval\",\"exec\",\"exit\",\"format\",\"getattr\",\"globals\",\"hasattr\",\"hash\",\"help\",\"hex\",\"id\",\"input\",\"isinstance\",\"issubclass\",\"iter\",\"len\",\"locals\",\"max\",\"min\",\"next\",\"oct\",\"open\",\"ord\",\"pow\",\"print\",\"quit\",\"repr\",\"round\",\"setattr\",\"sorted\",\"sum\",\"vars\"\n]\nvar builtin_function=$B.builtin_function=$B.make_class(\n\"builtin_function_or_method\",function(f){f.__class__=builtin_function\nreturn f})\nbuiltin_function.__getattribute__=$B.Function.__getattribute__\nbuiltin_function.__reduce_ex__=builtin_function.__reduce__=function(self){return self.$infos.__name__}\nbuiltin_function.__repr__=builtin_function.__str__=function(self){return '<built-in function '+self.$infos.__name__+'>'}\n$B.set_func_names(builtin_function,\"builtins\")\nvar method_wrapper=$B.make_class(\"method_wrapper\")\nmethod_wrapper.__repr__=method_wrapper.__str__=function(self){return \"<method wrapper '\"+self.$infos.__name__+\"' of function object>\"}\n$B.set_func_names(method_wrapper,\"builtins\")\nvar wrapper_descriptor=$B.wrapper_descriptor=\n$B.make_class(\"wrapper_descriptor\")\nwrapper_descriptor.__getattribute__=$B.Function.__getattribute__\nwrapper_descriptor.__repr__=wrapper_descriptor.__str__=function(self){return \"<slot wrapper '\"+self.$infos.__name__+\"' of '\"+\nself.__objclass__.$infos.__name__+\"' object>\"}\n$B.set_func_names(wrapper_descriptor,\"builtins\")\n$B.builtin_classes=[\"bool\",\"bytearray\",\"bytes\",\"classmethod\",\"complex\",\"dict\",\"enumerate\",\"filter\",\"float\",\"frozenset\",\"int\",\"list\",\"map\",\"memoryview\",\"object\",\"property\",\"range\",\"reversed\",\"set\",\"slice\",\"staticmethod\",\"str\",\"super\",\"tuple\",\"type\",\"zip\"\n]\nvar other_builtins=['Ellipsis','False','None','True','__debug__','__import__','copyright','credits','license','NotImplemented'\n]\nvar builtin_names=$B.builtin_funcs.\nconcat($B.builtin_classes).\nconcat(other_builtins)\nfor(var i=0;i < builtin_names.length;i++){var name=builtin_names[i],orig_name=name,name1=name\nif(name=='open'){name1='$url_open'}\nif(name=='super'){name1='$$super'}\nif(name=='eval'){name1='$$eval'}\nif(name=='print'){name1='$print'}\ntry{_b_[name]=eval(name1)\nif($B.builtin_funcs.indexOf(orig_name)>-1){_b_[name].__class__=builtin_function\n_b_[name].$infos={__module__:'builtins',__name__:orig_name,__qualname__:orig_name}}}\ncatch(err){}}\n_b_['open']=$url_open\n_b_['print']=$print\n_b_['super']=$$super\n_b_.object.__init__.__class__=wrapper_descriptor\n_b_.object.__new__.__class__=builtin_function})(__BRYTHON__)\n;\n;(function($B){var _b_=$B.builtins\n$B.del_exc=function(){var frame=$B.last($B.frames_stack)\nframe[1].$current_exception=undefined}\n$B.set_exc=function(exc){var frame=$B.last($B.frames_stack)\nif(frame===undefined){console.log(\"no frame\",exc,exc.__class__,exc.args)}\nframe[1].$current_exception=$B.exception(exc)}\n$B.get_exc=function(){var frame=$B.last($B.frames_stack)\nreturn frame[1].$current_exception}\n$B.$raise=function(arg){\nif(arg===undefined){var es=$B.get_exc()\nif(es !==undefined){throw es}\nthrow _b_.RuntimeError.$factory(\"No active exception to reraise\")}else if(_b_.isinstance(arg,BaseException)){if(arg.__class__===_b_.StopIteration &&\n$B.last($B.frames_stack)[1].$is_generator){\narg=_b_.RuntimeError.$factory(\"generator raised StopIteration\")}\nthrow arg}else if(arg.$is_class && _b_.issubclass(arg,BaseException)){if(arg===_b_.StopIteration){if($B.last($B.frames_stack)[1].$is_generator){\nthrow _b_.RuntimeError.$factory(\"generator raised StopIteration\")}}\nthrow $B.$call(arg)()}else{throw _b_.TypeError.$factory(\"exceptions must derive from BaseException\")}}\n$B.$syntax_err_line=function(exc,module,src,pos,line_num){\nvar pos2line={},lnum=1,module=module.charAt(0)==\"$\" ? \"<string>\" :module\nif(src===undefined){exc.$line_info=line_num+','+module\nexc.args=$B.fast_tuple([$B.$getitem(exc.args,0),$B.fast_tuple([module,line_num,0,0])])}else{var line_pos={1:0}\nfor(var i=0,len=src.length;i < len;i++){pos2line[i]=lnum\nif(src.charAt(i)==\"\\n\"){line_pos[++lnum]=i}}\nwhile(line_num===undefined){line_num=pos2line[pos]\npos--}\nexc.$line_info=line_num+\",\"+module\nvar lines=src.split(\"\\n\"),line=lines[line_num-1],lpos=pos-line_pos[line_num],len=line.length\nexc.text=line+'\\n'\nlpos-=len-line.length\nif(lpos < 0){lpos=0}\nwhile(line.charAt(0)==' '){line=line.substr(1)\nif(lpos > 0){lpos--}}\nexc.offset=lpos+1 \nexc.args=$B.fast_tuple([$B.$getitem(exc.args,0),$B.fast_tuple([module,line_num,lpos,line])])}\nexc.lineno=line_num\nexc.msg=exc.args[0]\nexc.filename=module}\n$B.$SyntaxError=function(module,msg,src,pos,line_num,root){if(root !==undefined && root.line_info !==undefined){\nline_num=root.line_info}\nvar exc=_b_.SyntaxError.$factory(msg)\n$B.$syntax_err_line(exc,module,src,pos,line_num)\nthrow exc}\n$B.$IndentationError=function(module,msg,src,pos,line_num,root,indented_node){$B.frames_stack.push([module,{$line_info:line_num+\",\"+module},module,{$src:src}])\nif(root !==undefined && root.line_info !==undefined){\nline_num=root.line_info}\nif(indented_node){var type=indented_node.C.tree[0].type\nswitch(type){case 'class':\ntype='class definition'\nbreak\ncase 'condition':\ntype=`'${indented_node.C.tree[0].token}' statement`\nbreak\ncase 'def':\ntype='function definition'\nbreak\ncase 'case':\ncase 'for':\ncase 'match':\ncase 'try':\ncase 'while':\ncase 'with':\ntype=`'${type}' statement`\nbreak\ncase 'single_kw':\ntype=`'${indented_node.C.tree[0].token}' statement`\nbreak}\nmsg+=` after ${type} on line ${indented_node.line_num}`}\nvar exc=_b_.IndentationError.$factory(msg)\n$B.$syntax_err_line(exc,module,src,pos,line_num)\nthrow exc}\n$B.print_stack=function(stack){stack=stack ||$B.frames_stack\nvar trace=[]\nstack.forEach(function(frame){var line_info=frame[1].$line_info\nif(line_info !==undefined){var info=line_info.split(\",\")\nif(info[1].startsWith(\"$exec\")){info[1]=\"<module>\"}\ntrace.push(info[1]+\" line \"+info[0])\nvar src=$B.file_cache[frame[3].__file__]\nif(src){var lines=src.split(\"\\n\"),line=lines[parseInt(info[0])-1]\ntrace.push(\"  \"+line.trim())}}})\nconsole.log(\"print stack ok\",trace)\nreturn trace.join(\"\\n\")}\nvar traceback=$B.traceback=$B.make_class(\"traceback\",function(exc,stack){var frame=$B.last($B.frames_stack)\nif(stack===undefined){stack=exc.$stack}\nreturn{\n__class__ :traceback,$stack:stack,exc:exc}}\n)\ntraceback.__getattribute__=function(self,attr){var line_info\nif(attr==='tb_frame' ||\nattr==='tb_lineno' ||\nattr==='tb_lasti' ||\nattr==='tb_next'){if(self.$stack.length==0){console.log(\"no stack\",attr)}\nvar first_frame=self.$stack[0]\nline_info=self.exc.$line_infos[self.exc.$line_infos.length-\nself.$stack.length]}\nswitch(attr){case \"tb_frame\":\nreturn frame.$factory(self.$stack)\ncase \"tb_lineno\":\nvar lineno\nif(line_info===undefined ||\nfirst_frame[0].startsWith($B.lambda_magic)){if(first_frame[4]&& first_frame[4].$infos &&\nfirst_frame[4].$infos.__code__){lineno=first_frame[4].$infos.__code__.co_firstlineno}else{lineno=-1}}else{lineno=parseInt(line_info.split(\",\")[0])}\nreturn lineno\ncase \"tb_lasti\":\nif(line_info===undefined){console.log(\"no line info\",self.$stack)\nreturn \"\"}else{var info=line_info.split(\",\"),src,file\nfor(var i=self.$stack.length-1;i >=0;i--){var fr=self.$stack[i]\nif(fr[2]==info[1].replace(/\\./g,'_')){file=fr[3].__file__\nsrc=fr[3].$src\nbreak}}\nif(src===undefined){if($B.file_cache.hasOwnProperty(file)){src=$B.file_cache[file]}else if($B.imported[info[1]]&&\n$B.imported[info[1]].__file__ ){src=$B.file_cache[$B.imported[info[1]].__file__]\nconsole.log(\"from filecache\",line_info,$B.imported[info[1]].__file__)}}\nif(src !==undefined){try{return src.split(\"\\n\")[parseInt(info[0]-1)].trim()}catch(err){console.log(\"error in attr tb_lasti of\",self)\nconsole.log(src,info)\nthrow err}}else{console.log('stack',self.$stack)\nconsole.log(file)\nconsole.log(\"no src for\",info)\nreturn \"\"}}\ncase \"tb_next\":\nif(self.$stack.length <=1){return _b_.None}\nelse{return traceback.$factory(self.exc,self.$stack.slice(1))}\ndefault:\nreturn _b_.object.__getattribute__(self,attr)}}\n$B.set_func_names(traceback,\"builtins\")\nvar frame=$B.make_class(\"frame\",function(stack,pos){var fs=stack\nvar res={__class__:frame,f_builtins :{},\n$stack:stack.slice()}\nif(pos===undefined){pos=0}\nres.$pos=pos\nif(fs.length){var _frame=fs[pos],locals_id=_frame[0],filename\ntry{res.f_locals=$B.obj_dict(_frame[1])}catch(err){console.log(\"err \"+err)\nthrow err}\nres.f_globals=$B.obj_dict(_frame[3])\nif(_frame[3].__file__ !==undefined){filename=_frame[3].__file__}\nif(locals_id.startsWith(\"$exec\")){filename=\"<string>\"}\nif(_frame[1].$line_info===undefined){res.f_lineno=-1}else{var line_info=_frame[1].$line_info.split(\",\")\nres.f_lineno=parseInt(line_info[0])\nvar module_name=line_info[1]\nif($B.imported.hasOwnProperty(module_name)){filename=$B.imported[module_name].__file__}\nres.f_lineno=parseInt(_frame[1].$line_info.split(',')[0])}\nvar co_name=locals_id.startsWith(\"$exec\")? \"<module>\" :\nlocals_id\nif(locals_id==_frame[2]){co_name=\"<module>\"}else if(locals_id.startsWith(\"lc\"+$B.lambda_magic)){co_name=\"<listcomp>\"}else{if(_frame[1].$name){co_name=_frame[1].$name}else if(_frame[1].$comprehension){co_name='<'+_frame[1].$comprehension+'>'}else if(_frame[1].$list_comp){co_name='<listcomp>'}else if(_frame.length > 4){if(_frame[4].$infos){co_name=_frame[4].$infos.__name__}else{co_name=_frame[4].name}\nif(_frame[4].$infos===undefined){\nif(_frame[4].name.startsWith(\"__ge\")){co_name=\"<genexpr>\"}else if(_frame[4].name.startsWith(\"set_comp\"+\n$B.lambda_magic)){co_name=\"<setcomp>\"}else if(_frame[4].name.startsWith(\"lambda\"+\n$B.lambda_magic)){co_name=\"<lambda>\"}}else if(filename===undefined && _frame[4].$infos.__code__){filename=_frame[4].$infos.__code__.co_filename\nif(filename===undefined){filename=_frame[4].$infos.__module__}\nres.f_lineno=_frame[4].$infos.__code__.co_firstlineno}}}\nif(_frame.length > 4 && _frame[4].$infos !==undefined){res.f_code=_frame[4].$infos.__code__}else{res.f_code={co_name:co_name,co_filename:filename}\nif(_frame[1].$comp_code){$B.update_obj(res.f_code,_frame[1].$comp_code)}}\nres.f_code.__class__=$B.code\nres.f_code.co_code=_b_.None\nif(filename===undefined){res.f_code.co_filename=\"<string>\"}}\nreturn res}\n)\nframe.__delattr__=function(self,attr){if(attr==\"f_trace\"){$B.last(self.$stack)[1].$f_trace=_b_.None}}\nframe.__getattr__=function(self,attr){\nif(attr==\"f_back\"){if(self.$pos > 0){return frame.$factory(self.$stack.slice(0,self.$stack.length-1),self.$pos-1)}else{return _b_.None}}else if(attr==\"clear\"){return function(){}}else if(attr==\"f_trace\"){var locals=$B.last(self.$stack)[1]\nif(locals.$f_trace===undefined){return _b_.None}\nreturn locals.$f_trace}}\nframe.__setattr__=function(self,attr,value){if(attr==\"f_trace\"){\n$B.last(self.$stack)[1].$f_trace=value}}\nframe.__str__=frame.__repr__=function(self){return '<frame object, file '+self.f_code.co_filename+\n', line '+self.f_lineno+', code '+self.f_code.co_name+'>'}\n$B.set_func_names(frame,\"builtins\")\n$B._frame=frame \nvar BaseException=_b_.BaseException={__class__:_b_.type,__bases__ :[_b_.object],__mro__:[_b_.object],args:[],$infos:{__name__:\"BaseException\",__module__:\"builtins\"},$is_class:true}\nBaseException.__init__=function(self){var args=arguments[1]===undefined ?[]:[arguments[1]]\nself.args=_b_.tuple.$factory(args)}\nBaseException.__repr__=function(self){var res=self.__class__.$infos.__name__+'('\nif(self.args[0]!==undefined){res+=_b_.repr(self.args[0])}\nif(self.args.length > 1){res+=', '+_b_.repr($B.fast_tuple(self.args.slice(1)))}\nreturn res+')'}\nBaseException.__str__=function(self){if(self.args.length > 0 && self.args[0]!==_b_.None){return _b_.str.$factory(self.args[0])}\nreturn ''}\nBaseException.__new__=function(cls){var err=_b_.BaseException.$factory()\nerr.__class__=cls\nerr.__dict__=$B.empty_dict()\nreturn err}\nvar getExceptionTrace=function(exc,includeInternal){if(exc.__class__===undefined){if($B.debug > 1){console.log(\"no class\",exc)}\nreturn exc+''}\nvar info=''\nif(exc.$js_exc !==undefined && includeInternal){info+=\"\\nJS stack:\\n\"+exc.$js_exc.stack+\"\\n\"}\ninfo+=\"Traceback (most recent call last):\"\nvar line_info=exc.$line_info\nfor(var i=0;i < exc.$stack.length;i++){var frame=exc.$stack[i]\nif(! frame[1]||! frame[1].$line_info){continue}\nvar $line_info=frame[1].$line_info\nvar line_info=$line_info.split(','),src\nif(exc.module==line_info[1]){src=exc.src}\nif(!includeInternal){var src=frame[3].$src\nif(src===undefined){if($B.VFS && $B.VFS.hasOwnProperty(frame[2])){src=$B.VFS[frame[2]][1]}else if(src=$B.file_cache[frame[3].__file__]){}else{continue}}}\nvar file=frame[3].__file__ ||\"<string>\",module=line_info[1],is_exec=module.charAt(0)==\"$\"\nif(is_exec){module=\"<module>\"}\ninfo+=\"\\n  File \"+file+\" line \"+line_info[0]\nif(frame.length > 4){if(frame[4].$infos){var name=frame[4].$infos.__name__\nif(name.startsWith(\"lc\"+$B.lambda_magic)){info+=', in <listcomp>'}else if(name.startsWith(\"lambda_\"+$B.lambda_magic)){info+=', in <lambda>'}else{info+=', in '+name}}else if(frame[4].name.startsWith(\"__ge\")){info+=', in <genexpr>'}else if(frame[4].name.startsWith(\"set_comp\"+$B.lambda_magic)){info+=', in <setcomp>'}else if(frame[4].name.startsWith(\"lc\"+$B.lambda_magic)){info+=', in <listcomp>'}else{console.log(\"frame[4]\",frame[4])}}else if(frame[1].$list_comp){info+=', in <listcomp>'}else if(frame[1].$dict_comp){info+=', in <dictcomp>'}else{info+=', in <module>'}\nif(src !==undefined && ! is_exec){var lines=src.split(\"\\n\"),line=lines[parseInt(line_info[0])-1]\nif(line){line=line.replace(/^[ ]+/g,\"\")}\ninfo+=\"\\n    \"+line}}\nif(exc.__class__===_b_.SyntaxError){info+=\"\\n  File \"+exc.args[1][0]+\", line \"+\nexc.args[1][1]+\"\\n    \"+exc.args[1][3]}\nreturn info}\nBaseException.__getattr__=function(self,attr){if(attr==\"info\"){return getExceptionTrace(self,false);}else if(attr==\"infoWithInternal\"){return getExceptionTrace(self,true);}else if(attr==\"__traceback__\"){\nif(self.$traceback !==undefined){return self.$traceback}\nreturn traceback.$factory(self)}else{throw $B.attr_error(attr,self)}}\nBaseException.with_traceback=function(self,tb){self.$traceback=tb\nreturn self}\n$B.deep_copy=function(stack){var res=[]\nfor(const s of stack){var item=[s[0],{},s[2],{}]\nif(s[4]!==undefined){item.push(s[4])}\nfor(const i of[1,3]){for(var key in s[i]){item[i][key]=s[i][key]}}\nres.push(item)}\nreturn res}\n$B.save_stack=function(){return $B.deep_copy($B.frames_stack)}\n$B.restore_stack=function(stack,locals){$B.frames_stack=stack\n$B.frames_stack[$B.frames_stack.length-1][1]=locals}\n$B.freeze=function(err){\nif(err.$stack===undefined){err.$line_infos=[]\nfor(var i=0,len=$B.frames_stack.length;i < len;i++){err.$line_infos.push($B.frames_stack[i][1].$line_info)}\nerr.$stack=$B.frames_stack.slice()\nif($B.frames_stack.length){err.$line_info=$B.last($B.frames_stack)[1].$line_info}}}\nvar show_stack=$B.show_stack=function(stack){stack=stack ||$B.frames_stack\nfor(const frame of stack){console.log(frame[0],frame[1].$line_info)}}\nvar be_factory=`\nfunction (){\n    var err = Error()\n    err.args = $B.fast_tuple(Array.prototype.slice.call(arguments))\n    err.__class__ = _b_.BaseException\n    err.$py_error = true\n    $B.freeze(err)\n    // placeholder\n    err.__cause__ = _b_.None // XXX fix me\n    err.__context__ = _b_.None // XXX fix me\n    err.__suppress_context__ = false // XXX fix me\n    return err}`\neval('BaseException.$factory = '+be_factory)\nBaseException.$factory.$infos={__name__:\"BaseException\",__qualname__:\"BaseException\"}\n$B.set_func_names(BaseException)\n_b_.BaseException=BaseException\n$B.exception=function(js_exc,in_ctx_manager){\nif(! js_exc.__class__){var exc=Error()\nexc.__name__=\"Internal Javascript error: \"+\n(js_exc.__name__ ||js_exc.name)\nexc.__class__=_b_.Exception\nexc.$js_exc=js_exc\nif($B.is_recursion_error(js_exc)){return _b_.RecursionError.$factory(\"too much recursion\")}else if(js_exc.name==\"ReferenceError\"){exc.__name__=\"NameError\"\nexc.__class__=_b_.NameError}else if(js_exc.name==\"InternalError\"){exc.__name__=\"RuntimeError\"\nexc.__class__=_b_.RuntimeError}\nexc.__cause__=_b_.None\nexc.__context__=_b_.None\nexc.__suppress_context__=false\nvar $message=\"<Javascript \"+js_exc.name+\">: \"+\n(js_exc.message ||\"<\"+js_exc+\">\")\nexc.args=_b_.tuple.$factory([$message])\nexc.$py_error=true\nconsole.log('js error',exc.args,exc.__class__)\nconsole.log(js_exc.stack)\n$B.freeze(exc)}else{var exc=js_exc\n$B.freeze(exc)\nif(in_ctx_manager){\nvar current_locals=$B.last($B.frames_stack)[0]\nfor(var i=0,len=exc.$stack.length;i < len;i++){if(exc.$stack[i][0]==current_locals){exc.$stack=exc.$stack.slice(i)\nexc.$traceback=traceback.$factory(exc)\nbreak}}}}\nreturn exc}\n$B.is_exc=function(exc,exc_list){\nif(exc.__class__===undefined){exc=$B.exception(exc)}\nvar this_exc_class=exc.$is_class ? exc :exc.__class__\nfor(var i=0;i < exc_list.length;i++){var exc_class=exc_list[i]\nif(this_exc_class===undefined){console.log(\"exc class undefined\",exc)}\nif(_b_.issubclass(this_exc_class,exc_class)){return true}}\nreturn false}\n$B.is_recursion_error=function(js_exc){\nvar msg=js_exc+\"\",parts=msg.split(\":\"),err_type=parts[0].trim(),err_msg=parts[1].trim()\nreturn(err_type=='InternalError' && err_msg=='too much recursion')||\n(err_type=='Error' && err_msg=='Out of stack space')||\n(err_type=='RangeError' && err_msg=='Maximum call stack size exceeded')}\nfunction $make_exc(names,parent){\nif(parent===undefined){console.log('pas de parent',names)}\nvar _str=[],pos=0\nfor(var i=0;i < names.length;i++){var name=names[i],code=\"\"\nif(Array.isArray(name)){\nvar code=name[1],name=name[0]}\n$B.builtins_scope[name]=true\nvar $exc=(be_factory).replace(/BaseException/g,name)\n$exc=$exc.replace(\"// placeholder\",code)\n_str[pos++]=\"_b_.\"+name+' = {__class__:_b_.type, '+\n'__bases__: [_b_.'+parent.$infos.__name__+'], '+\n'__mro__: [_b_.'+parent.$infos.__name__+\n\"].concat(parent.__mro__), $is_class: true,\"+\n\"$infos: {__name__:'\"+name+\"'}}\"\n_str[pos++]=\"_b_.\"+name+\".$factory = \"+$exc\n_str[pos++]=\"_b_.\"+name+'.$factory.$infos = {__name__: \"'+\nname+'\", __qualname__: \"'+name+'\"}'\n_str[pos++]=\"$B.set_func_names(_b_.\"+name+\", 'builtins')\"}\ntry{eval(_str.join(\";\"))}catch(err){console.log(\"--err\"+err)\nthrow err}}\n$make_exc([\"SystemExit\",\"KeyboardInterrupt\",\"GeneratorExit\",\"Exception\"],BaseException)\n$make_exc([[\"StopIteration\",\"err.value = arguments[0]\"],[\"StopAsyncIteration\",\"err.value = arguments[0]\"],\"ArithmeticError\",\"AssertionError\",\"BufferError\",\"EOFError\",[\"ImportError\",\"err.name = arguments[0]\"],\"LookupError\",\"MemoryError\",\"OSError\",\"ReferenceError\",\"RuntimeError\",[\"SyntaxError\",\"err.msg = arguments[0]\"],\"SystemError\",\"TypeError\",\"ValueError\",\"Warning\"],_b_.Exception)\n$make_exc([\"FloatingPointError\",\"OverflowError\",\"ZeroDivisionError\"],_b_.ArithmeticError)\n$make_exc([[\"ModuleNotFoundError\",\"err.name = arguments[0]\"]],_b_.ImportError)\n$make_exc([\"IndexError\",\"KeyError\"],_b_.LookupError)\n$make_exc([\"BlockingIOError\",\"ChildProcessError\",\"ConnectionError\",\"FileExistsError\",\"FileNotFoundError\",\"InterruptedError\",\"IsADirectoryError\",\"NotADirectoryError\",\"PermissionError\",\"ProcessLookupError\",\"TimeoutError\"],_b_.OSError)\n$make_exc([\"BrokenPipeError\",\"ConnectionAbortedError\",\"ConnectionRefusedError\",\"ConnectionResetError\"],_b_.ConnectionError)\n$make_exc([\"NotImplementedError\",\"RecursionError\"],_b_.RuntimeError)\n$make_exc([\"IndentationError\"],_b_.SyntaxError)\n$make_exc([\"TabError\"],_b_.IndentationError)\n$make_exc([\"UnicodeError\"],_b_.ValueError)\n$make_exc([\"UnicodeDecodeError\",\"UnicodeEncodeError\",\"UnicodeTranslateError\"],_b_.UnicodeError)\n$make_exc([\"DeprecationWarning\",\"PendingDeprecationWarning\",\"RuntimeWarning\",\"SyntaxWarning\",\"UserWarning\",\"FutureWarning\",\"ImportWarning\",\"UnicodeWarning\",\"BytesWarning\",\"ResourceWarning\",\"EncodingWarning\"],_b_.Warning)\n$make_exc([\"EnvironmentError\",\"IOError\",\"VMSError\",\"WindowsError\"],_b_.OSError)\nvar js='\\nvar $ = $B.args(\"AttributeError\", 1, {\"msg\": null, \"name\":null, \"obj\":null}, '+\n'[\"msg\", \"name\", \"obj\"], arguments, '+\n'{msg: _b_.None, name: _b_.None, obj: _b_.None}, \"*\", null);\\n'+\n'err.args = $B.fast_tuple($.msg === _b_.None ? [] : [$.msg])\\n;'+\n'err.name = $.name\\nerr.obj = $.obj\\n'\n$make_exc([[\"AttributeError\",js]],_b_.Exception)\n_b_.AttributeError.__str__=function(self){var msg=self.args[0]\nvar suggestion=offer_suggestions_for_attribute_error(self)\nif(suggestion){msg+=`. Did you mean: '${suggestion}'?`}\nreturn msg}\n$B.set_func_names(_b_.AttributeError,'builtins')\n$B.attr_error=function(name,obj){if(obj.$is_class){var msg=`type object '${obj.$infos.__name__}'`}else{var msg=`'${$B.class_name(obj)}' object`}\nmsg+=` has no attribute '${name}'`\nreturn _b_.AttributeError.$factory({$nat:\"kw\",kw:{name,obj,msg}})}\nvar js='\\nvar $ = $B.args(\"NameError\", 1, {\"msg\": null, \"name\":null}, '+\n'[\"msg\", \"name\"], arguments, '+\n'{msg: _b_.None, name: _b_.None}, \"*\", null);\\n'+\n'err.args = $B.fast_tuple($.msg === _b_.None ? [] : [$.msg])\\n;'+\n'err.name = $.name\\n'\n$make_exc([[\"NameError\",js]],_b_.Exception)\n_b_.NameError.__str__=function(self){if(self.args.length > 0){return self.args[0]}\nvar msg=`name '${self.name}' is not defined`,suggestion=offer_suggestions_for_name_error(self)\nif(suggestion){msg+=`. Did you mean: '${suggestion}'?`}\nreturn msg}\n$B.set_func_names(_b_.NameError,'builtins')\n$make_exc([\"UnboundLocalError\"],_b_.NameError)\n$B.name_error=function(name,obj){return _b_.NameError.$factory({$nat:\"kw\",kw:{name}})}\n$B.$TypeError=function(msg){throw _b_.TypeError.$factory(msg)}\nvar se=_b_.SyntaxError.$factory\n_b_.SyntaxError.$factory=function(){var arg=arguments[0]\nif(arg.__class__===_b_.SyntaxError){return arg}\nvar exc=se.apply(null,arguments),frame=$B.last($B.frames_stack)\nif(frame){line_info=frame[1].$line_info\nexc.filename=frame[3].__file__\nexc.lineno=parseInt(line_info.split(\",\")[0])\nvar src=$B.file_cache[frame[3].__file__]\nif(src){lines=src.split(\"\\n\")\nexc.text=lines[exc.lineno-1]}\nexc.offset=arg.offset}\nreturn exc}\nvar MAX_CANDIDATE_ITEMS=750,MAX_STRING_SIZE=40,MOVE_COST=2,CASE_COST=1,SIZE_MAX=65535\nfunction LEAST_FIVE_BITS(n){return((n)& 31)}\nfunction levenshtein_distance(a,b,max_cost){\nif(a==b){return 0}\nif(a.length < b.length){[a,b]=[b,a]}\nwhile(a.length && a[0]==b[0]){a=a.substr(1)\nb=b.substr(1)}\nwhile(a.length && a[a.length-1]==b[b.length-1]){a=a.substr(0,a.length-1)\nb=b.substr(0,b.length-1)}\nif(b.length==0){return a.length*MOVE_COST}\nif((b.length-a.length)*MOVE_COST > max_cost){return max_cost+1}\nvar buffer=[]\nfor(var i=0;i < a.length;i++){\nbuffer[i]=(i+1)*MOVE_COST}\nvar result=0\nfor(var b_index=0;b_index < b.length;b_index++){var code=b[b_index]\nvar distance=result=b_index*MOVE_COST;\nvar minimum=SIZE_MAX;\nfor(var index=0;index < a.length;index++){\nvar substitute=distance+substitution_cost(code,a[index])\ndistance=buffer[index]\nvar insert_delete=Math.min(result,distance)+MOVE_COST\nresult=Math.min(insert_delete,substitute)\nbuffer[index]=result\nif(result < minimum){minimum=result}}\nif(minimum > max_cost){\nreturn max_cost+1}}\nreturn result}\nfunction substitution_cost(a,b){if(LEAST_FIVE_BITS(a)!=LEAST_FIVE_BITS(b)){\nreturn MOVE_COST}\nif(a==b){return 0}\nif(a.toLowerCase()==b.toLowerCase()){return CASE_COST}\nreturn MOVE_COST}\nfunction calculate_suggestions(dir,name){if(dir.length >=MAX_CANDIDATE_ITEMS){return null}\nvar suggestion_distance=2**52,suggestion=null\nfor(var item of dir){\nvar max_distance=(name.length+item.length+3)*MOVE_COST/6\nmax_distance=Math.min(max_distance,suggestion_distance-1)\nvar current_distance=\nlevenshtein_distance(name,item,max_distance)\nif(current_distance > max_distance){continue}\nif(!suggestion ||current_distance < suggestion_distance){suggestion=item\nsuggestion_distance=current_distance}}\nreturn suggestion}\nfunction offer_suggestions_for_attribute_error(exc){var name=exc.name,obj=exc.obj\nvar dir=_b_.dir(obj),suggestions=calculate_suggestions(dir,name)\nreturn suggestions}\nfunction offer_suggestions_for_name_error(exc){var name=exc.name,frame=$B.last(exc.$stack)\nvar locals=Object.keys(frame[1]).filter(x=> !(x.startsWith('$')))\nvar suggestion=calculate_suggestions(locals,name)\nif(suggestion){return suggestion}\nif(frame[2]!=frame[0]){var globals=Object.keys(frame[3]).filter(x=> !(x.startsWith('$')))\nvar suggestion=calculate_suggestions(globals,name)\nif(suggestion){return suggestion}}}\n$B.handle_error=function(err){\nif(err.$handled){return}\nerr.$handled=true\nif($B.debug > 1){console.log(\"handle error\",err.__class__,err.args,'stderr',$B.stderr)\nconsole.log(err)}\nif(err.__class__ !==undefined){var name=$B.class_name(err),trace=$B.$getattr(err,'info')\nif(name=='SyntaxError' ||name=='IndentationError'){var offset=err.args[1][2]\ntrace+='\\n    '+' '.repeat(offset)+'^'+\n'\\n'+name+': '+err.args[0]}else{trace+='\\n'+name+': '+_b_.str.$factory(err)}}else{console.log(err)\ntrace=err+\"\"}\ntry{$B.$getattr($B.stderr,'write')(trace)\nvar flush=$B.$getattr($B.stderr,'flush',_b_.None)\nif(flush !==_b_.None){flush()}}catch(print_exc_err){console.debug(trace)}\nthrow err}})(__BRYTHON__)\n;\n\n;(function($B){var _b_=$B.builtins,None=_b_.None,range={__class__:_b_.type,__mro__:[_b_.object],$infos:{__module__:\"builtins\",__name__:\"range\"},$is_class:true,$native:true,$match_sequence_pattern:true,\n$descriptors:{start:true,step:true,stop:true}}\nrange.__contains__=function(self,other){if(range.__len__(self)==0){return false}\ntry{other=$B.int_or_bool(other)}\ncatch(err){\ntry{range.index(self,other);return true}\ncatch(err){return false}}\nvar sub=$B.sub(other,self.start),fl=$B.floordiv(sub,self.step),res=$B.mul(self.step,fl)\nif($B.eq(res,sub)){if($B.gt(self.stop,self.start)){return $B.ge(other,self.start)&& $B.gt(self.stop,other)}else{return $B.ge(self.start,other)&& $B.gt(other,self.stop)}}else{return false}}\nrange.__delattr__=function(self,attr,value){throw _b_.AttributeError.$factory(\"readonly attribute\")}\nrange.__eq__=function(self,other){if(_b_.isinstance(other,range)){var len=range.__len__(self)\nif(! $B.eq(len,range.__len__(other))){return false}\nif(len==0){return true}\nif(! $B.eq(self.start,other.start)){return false}\nif(len==1){return true}\nreturn $B.eq(self.step,other.step)}\nreturn false}\nfunction compute_item(r,i){var len=range.__len__(r)\nif(len==0){return r.start}\nelse if(i > len){return r.stop}\nreturn $B.add(r.start,$B.mul(r.step,i))}\nrange.__getitem__=function(self,rank){if(_b_.isinstance(rank,_b_.slice)){var norm=_b_.slice.$conv_for_seq(rank,range.__len__(self)),substep=$B.mul(self.step,norm.step),substart=compute_item(self,norm.start),substop=compute_item(self,norm.stop)\nreturn range.$factory(substart,substop,substep)}\nif(typeof rank !=\"number\"){rank=$B.$GetInt(rank)}\nif($B.gt(0,rank)){rank=$B.add(rank,range.__len__(self))}\nvar res=$B.add(self.start,$B.mul(rank,self.step))\nif(($B.gt(self.step,0)&&\n($B.ge(res,self.stop)||$B.gt(self.start,res)))||\n($B.gt(0,self.step)&&\n($B.ge(self.stop,res)||$B.gt(res,self.start)))){throw _b_.IndexError.$factory(\"range object index out of range\")}\nreturn res}\nrange.__hash__=function(self){var len=range.__len__(self)\nif(len==0){return _b_.hash(_b_.tuple.$factory([0,None,None]))}\nif(len==1){return _b_.hash(_b_.tuple.$factory([1,self.start,None]))}\nreturn _b_.hash(_b_.tuple.$factory([len,self.start,self.step]))}\nvar RangeIterator={__class__:_b_.type,__mro__:[_b_.object],__iter__:function(self){return self},__next__:function(self){return _b_.next(self.obj)},$infos:{__name__:\"range_iterator\",__module__:\"builtins\"},$is_class:true}\nRangeIterator.$factory=function(obj){return{__class__:RangeIterator,obj:obj}}\n$B.set_func_names(RangeIterator,\"builtins\")\nrange.__iter__=function(self){var res={__class__ :range,start:self.start,stop:self.stop,step:self.step}\nif(self.$safe){res.$counter=self.start-self.step}else{res.$counter=$B.sub(self.start,self.step)}\nreturn RangeIterator.$factory(res)}\nrange.__len__=function(self){var len\nif($B.gt(self.step,0)){if($B.ge(self.start,self.stop)){return 0}\nvar n=$B.sub(self.stop,$B.add(1,self.start)),q=$B.floordiv(n,self.step)\nlen=$B.add(1,q)}else{if($B.ge(self.stop,self.start)){return 0}\nvar n=$B.sub(self.start,$B.add(1,self.stop)),q=$B.floordiv(n,$B.mul(-1,self.step))\nlen=$B.add(1,q)}\nif($B.maxsize===undefined){$B.maxsize=$B.long_int.__pow__($B.long_int.$factory(2),63)\n$B.maxsize=$B.long_int.__sub__($B.maxsize,1)}\nreturn len}\nrange.__next__=function(self){if(self.$safe){self.$counter+=self.step\nif((self.step > 0 && self.$counter >=self.stop)\n||(self.step < 0 && self.$counter <=self.stop)){throw _b_.StopIteration.$factory(\"\")}}else{self.$counter=$B.add(self.$counter,self.step)\nif(($B.gt(self.step,0)&& $B.ge(self.$counter,self.stop))\n||($B.gt(0,self.step)&& $B.ge(self.stop,self.$counter))){throw _b_.StopIteration.$factory(\"\")}}\nreturn self.$counter}\nrange.__reversed__=function(self){var n=$B.sub(range.__len__(self),1)\nreturn range.$factory($B.add(self.start,$B.mul(n,self.step)),$B.sub(self.start,self.step),$B.mul(-1,self.step))}\nrange.__repr__=function(self){$B.builtins_repr_check(range,arguments)\nvar res=\"range(\"+_b_.str.$factory(self.start)+\", \"+\n_b_.str.$factory(self.stop)\nif(self.step !=1){res+=\", \"+_b_.str.$factory(self.step)}\nreturn res+\")\"}\nrange.__setattr__=function(self,attr,value){throw _b_.AttributeError.$factory(\"readonly attribute\")}\nrange.start=function(self){return self.start}\nrange.step=function(self){return self.step},range.stop=function(self){return self.stop}\nrange.count=function(self,ob){if(_b_.isinstance(ob,[_b_.int,_b_.float,_b_.bool])){return _b_.int.$factory(range.__contains__(self,ob))}else{var comp=function(other){return $B.rich_comp(\"__eq__\",ob,other)},it=range.__iter__(self),_next=RangeIterator.__next__,nb=0\nwhile(true){try{if(comp(_next(it))){nb++}}catch(err){if(_b_.isinstance(err,_b_.StopIteration)){return nb}\nthrow err}}}}\nrange.index=function(self,other){var $=$B.args(\"index\",2,{self:null,other:null},[\"self\",\"other\"],arguments,{},null,null),self=$.self,other=$.other\ntry{other=$B.int_or_bool(other)}catch(err){var comp=function(x){return $B.rich_comp(\"__eq__\",other,x)},it=range.__iter__(self),_next=RangeIterator.__next__,nb=0\nwhile(true){try{if(comp(_next(it))){return nb}\nnb++}catch(err){if(_b_.isinstance(err,_b_.StopIteration)){throw _b_.ValueError.$factory(_b_.str.$factory(other)+\n\" not in range\")}\nthrow err}}}\nvar sub=$B.sub(other,self.start),fl=$B.floordiv(sub,self.step),res=$B.mul(self.step,fl)\nif($B.eq(res,sub)){if(($B.gt(self.stop,self.start)&& $B.ge(other,self.start)\n&& $B.gt(self.stop,other))||\n($B.ge(self.start,self.stop)&& $B.ge(self.start,other)\n&& $B.gt(other,self.stop))){return fl}else{throw _b_.ValueError.$factory(_b_.str.$factory(other)+\n' not in range')}}else{throw _b_.ValueError.$factory(_b_.str.$factory(other)+\n\" not in range\")}}\nrange.$factory=function(){var $=$B.args(\"range\",3,{start:null,stop:null,step:null},[\"start\",\"stop\",\"step\"],arguments,{start:null,stop:null,step:null},null,null),start=$.start,stop=$.stop,step=$.step,safe\nif(stop===null && step===null){if(start==null){throw _b_.TypeError.$factory(\"range expected 1 arguments, got 0\")}\nstop=$B.PyNumber_Index(start)\nsafe=typeof stop===\"number\"\nreturn{__class__:range,start:0,stop:stop,step:1,$is_range:true,$safe:safe}}\nif(step===null){step=1}\nstart=$B.PyNumber_Index(start)\nstop=$B.PyNumber_Index(stop)\nstep=$B.PyNumber_Index(step)\nif(step==0){throw _b_.ValueError.$factory(\"range arg 3 must not be zero\")}\nsafe=(typeof start==\"number\" && typeof stop==\"number\" &&\ntypeof step==\"number\")\nreturn{__class__:range,start:start,stop:stop,step:step,$is_range:true,$safe:safe}}\n$B.set_func_names(range,\"builtins\")\nvar slice={__class__:_b_.type,__mro__:[_b_.object],$infos:{__module__:\"builtins\",__name__:\"slice\"},$is_class:true,$native:true,$descriptors:{start:true,step:true,stop:true}}\nslice.__eq__=function(self,other){var conv1=conv_slice(self),conv2=conv_slice(other)\nreturn conv1[0]==conv2[0]&&\nconv1[1]==conv2[1]&&\nconv1[2]==conv2[2]}\nslice.__repr__=function(self){$B.builtins_repr_check(slice,arguments)\nreturn \"slice(\"+_b_.str.$factory(self.start)+\", \"+\n_b_.str.$factory(self.stop)+\", \"+_b_.str.$factory(self.step)+\")\"}\nslice.__setattr__=function(self,attr,value){throw _b_.AttributeError.$factory(\"readonly attribute\")}\nfunction conv_slice(self){var attrs=[\"start\",\"stop\",\"step\"],res=[]\nfor(var i=0;i < attrs.length;i++){var val=self[attrs[i]]\nif(val===_b_.None){res.push(val)}else{try{res.push($B.PyNumber_Index(val))}catch(err){throw _b_.TypeError.$factory(\"slice indices must be \"+\n\"integers or None or have an __index__ method\")}}}\nreturn res}\nslice.$conv_for_seq=function(self,len){\nvar step=self.step===None ? 1 :$B.PyNumber_Index(self.step),step_is_neg=$B.gt(0,step),len_1=$B.sub(len,1)\nif(step==0){throw _b_.ValueError.$factory('slice step cannot be zero')}\nvar start\nif(self.start===None){start=step_is_neg ? len_1 :0}else{start=$B.PyNumber_Index(self.start)\nif($B.gt(0,start)){start=$B.add(start,len)\nif($B.gt(0,start)){start=0}}\nif($B.ge(start,len)){start=step < 0 ? len_1 :len}}\nif(self.stop===None){stop=step_is_neg ?-1 :len}else{stop=$B.PyNumber_Index(self.stop)\nif($B.gt(0,stop)){stop=$B.add(stop,len)}\nif($B.ge(stop,len)){stop=step_is_neg ? len_1 :len}}\nreturn{start:start,stop:stop,step:step}}\nslice.start=function(self){return self.start}\nslice.step=function(self){return self.step}\nslice.stop=function(self){return self.stop}\nslice.indices=function(self,length){\nvar $=$B.args(\"indices\",2,{self:null,length:null},[\"self\",\"length\"],arguments,{},null,null)\nvar len=$B.$GetInt($.length)\nif(len < 0){_b_.ValueError.$factory(\"length should not be negative\")}\nvar _step=(self.step==_b_.None)? 1 :self.step\nif(_step < 0){var _start=self.start,_stop=self.stop\n_start=(_start==_b_.None)? len-1 :\n(_start < 0)? _b_.max(-1,_start+len):_b_.min(len-1,self.start)\n_stop=(self.stop==_b_.None)?-1 :\n(_stop < 0)? _b_.max(-1,_stop+len):_b_.min(len-1,self.stop)}else{var _start=(self.start==_b_.None)? 0 :_b_.min(len,self.start)\nvar _stop=(self.stop==_b_.None)? len :_b_.min(len,self.stop)\nif(_start < 0){_start=_b_.max(0,_start+len)}\nif(_stop < 0){_stop=_b_.max(0,_stop+len)}}\nreturn _b_.tuple.$factory([_start,_stop,_step])}\nslice.$factory=function(){var $=$B.args(\"slice\",3,{start:null,stop:null,step:null},[\"start\",\"stop\",\"step\"],arguments,{stop:null,step:null},null,null),start,stop,step\nif($.stop===null && $.step===null){start=_b_.None\nstop=$.start\nstep=_b_.None}else{start=$.start\nstop=$.stop\nstep=$.step===null ? _b_.None :$.step}\nvar res={__class__ :slice,start:start,stop:stop,step:step}\nconv_slice(res)\nreturn res}\n$B.set_func_names(slice,\"builtins\")\n_b_.range=range\n_b_.slice=slice})(__BRYTHON__)\n;\n;(function($B){var _b_=$B.builtins\nvar from_unicode={},to_unicode={}\n$B.to_bytes=function(obj){var res\nif(_b_.isinstance(obj,[bytes,bytearray])){res=obj.source}else{var ga=$B.$getattr(obj,\"tobytes\",null)\nif(ga !==null){res=$B.$call(ga)().source}\nelse{throw _b_.TypeError.$factory(\"object doesn't support the buffer protocol\")}}\nreturn res}\nfunction _strip(self,cars,lr){if(cars===undefined){cars=[]\nvar ws='\\r\\n \\t'\nfor(var i=0,len=ws.length;i < len;i++){cars.push(ws.charCodeAt(i))}}else if(_b_.isinstance(cars,bytes)){cars=cars.source}else{throw _b_.TypeError.$factory(\"Type str doesn't support the buffer API\")}\nif(lr=='l'){for(var i=0,len=self.source.length;i < len;i++){if(cars.indexOf(self.source[i])==-1){break}}\nreturn bytes.$factory(self.source.slice(i))}\nfor(var i=self.source.length-1;i >=0;i--){if(cars.indexOf(self.source[i])==-1){break}}\nreturn bytes.$factory(self.source.slice(0,i+1))}\nfunction invalid(other){return ! _b_.isinstance(other,[bytes,bytearray])}\nvar bytearray={__class__:_b_.type,__mro__:[_b_.object],$buffer_protocol:true,$infos:{__module__:\"builtins\",__name__:\"bytearray\"},$is_class:true}\nvar mutable_methods=[\"__delitem__\",\"clear\",\"copy\",\"count\",\"index\",\"pop\",\"remove\",\"reverse\",\"sort\"]\nmutable_methods.forEach(function(method){bytearray[method]=(function(m){return function(self){var args=[self.source],pos=1\nfor(var i=1,len=arguments.length;i < len;i++){args[pos++]=arguments[i]}\nreturn _b_.list[m].apply(null,args)}})(method)})\nvar bytearray_iterator=$B.make_iterator_class('bytearray_iterator')\nbytearray.__iter__=function(self){return bytearray_iterator.$factory(self.source)}\nbytearray.__mro__=[_b_.object]\nbytearray.__repr__=bytearray.__str__=function(self){return 'bytearray('+bytes.__repr__(self)+\")\"}\nbytearray.__setitem__=function(self,arg,value){if(_b_.isinstance(arg,_b_.int)){if(! _b_.isinstance(value,_b_.int)){throw _b_.TypeError.$factory('an integer is required')}else if(value > 255){throw _b_.ValueError.$factory(\"byte must be in range(0, 256)\")}\nvar pos=arg\nif(arg < 0){pos=self.source.length+pos}\nif(pos >=0 && pos < self.source.length){self.source[pos]=value}\nelse{throw _b_.IndexError.$factory('list index out of range')}}else if(_b_.isinstance(arg,_b_.slice)){var start=arg.start===_b_.None ? 0 :arg.start\nvar stop=arg.stop===_b_.None ? self.source.length :arg.stop\nif(start < 0){start=self.source.length+start}\nif(stop < 0){stop=self.source.length+stop}\nself.source.splice(start,stop-start)\ntry{var $temp=_b_.list.$factory(value)\nfor(var i=$temp.length-1;i >=0;i--){if(! _b_.isinstance($temp[i],_b_.int)){throw _b_.TypeError.$factory('an integer is required')}else if($temp[i]> 255){throw _b_.ValueError.$factory(\"byte must be in range(0, 256)\")}\nself.source.splice(start,0,$temp[i])}}catch(err){throw _b_.TypeError.$factory(\"can only assign an iterable\")}}else{throw _b_.TypeError.$factory('list indices must be integer, not '+\n$B.class_name(arg))}}\nbytearray.append=function(self,b){if(arguments.length !=2){throw _b_.TypeError.$factory(\n\"append takes exactly one argument (\"+(arguments.length-1)+\n\" given)\")}\nif(! _b_.isinstance(b,_b_.int)){throw _b_.TypeError.$factory(\"an integer is required\")}\nif(b > 255){throw _b_.ValueError.$factory(\"byte must be in range(0, 256)\")}\nself.source[self.source.length]=b}\nbytearray.extend=function(self,b){if(self.in_iteration){\nthrow _b_.BufferError.$factory(\"Existing exports of data: object \"+\n\"cannot be re-sized\")}\nif(b.__class__===bytearray ||b.__class__===bytes){b.source.forEach(function(item){self.source.push(item)})\nreturn _b_.None}\nvar it=_b_.iter(b)\nwhile(true){try{bytearray.__add__(self,_b_.next(it))}catch(err){if(err===_b_.StopIteration){break}\nthrow err}}\nreturn _b_.None}\nbytearray.insert=function(self,pos,b){if(arguments.length !=3){throw _b_.TypeError.$factory(\n\"insert takes exactly 2 arguments (\"+(arguments.length-1)+\n\" given)\")}\nif(! _b_.isinstance(b,_b_.int)){throw _b_.TypeError.$factory(\"an integer is required\")}\nif(b > 255){throw _b_.ValueError.$factory(\"byte must be in range(0, 256)\")}\n_b_.list.insert(self.source,pos,b)}\nbytearray.$factory=function(){var args=[bytearray]\nfor(var i=0,len=arguments.length;i < len;i++){args.push(arguments[i])}\nreturn bytearray.__new__.apply(null,args)}\nvar bytes={__class__ :_b_.type,__mro__:[_b_.object],$buffer_protocol:true,$infos:{__module__:\"builtins\",__name__:\"bytes\"},$is_class:true}\nbytes.__add__=function(self,other){if(_b_.isinstance(other,bytes)){return self.__class__.$factory(self.source.concat(other.source))}else if(_b_.isinstance(other,bytearray)){return self.__class__.$factory(bytes.__add__(self,bytes.$factory(other)))}else if(_b_.isinstance(other,_b_.memoryview)){return self.__class__.$factory(bytes.__add__(self,_b_.memoryview.tobytes(other)))}\nthrow _b_.TypeError.$factory(\"can't concat bytes to \"+\n_b_.str.$factory(other))}\nbytes.__contains__=function(self,other){if(typeof other==\"number\"){return self.source.indexOf(other)>-1}\nif(self.source.length < other.source.length){return false}\nvar len=other.source.length\nfor(var i=0;i < self.source.length-other.source.length+1;i++){var flag=true\nfor(var j=0;j < len;j++){if(other.source[i+j]!=self.source[j]){flag=false\nbreak}}\nif(flag){return true}}\nreturn false}\nvar bytes_iterator=$B.make_iterator_class(\"bytes_iterator\")\nbytes.__iter__=function(self){return bytes_iterator.$factory(self.source)}\nbytes.__eq__=function(self,other){if(invalid(other)){return false}\nreturn $B.$getattr(self.source,'__eq__')(other.source)}\nbytes.__ge__=function(self,other){if(invalid(other)){return _b_.NotImplemented}\nreturn _b_.list.__ge__(self.source,other.source)}\nbytes.__getitem__=function(self,arg){var i\nif(_b_.isinstance(arg,_b_.int)){var pos=arg\nif(arg < 0){pos=self.source.length+pos}\nif(pos >=0 && pos < self.source.length){return self.source[pos]}\nthrow _b_.IndexError.$factory(\"index out of range\")}else if(_b_.isinstance(arg,_b_.slice)){var s=_b_.slice.$conv_for_seq(arg,self.source.length),start=s.start,stop=s.stop,step=s.step\nvar res=[],i=null,pos=0\nif(step > 0){stop=Math.min(stop,self.source.length)\nif(stop <=start){return bytes.$factory([])}\nfor(var i=start;i < stop;i+=step){res[pos++]=self.source[i]}}else{if(stop >=start){return bytes.$factory([])}\nstop=Math.max(0,stop)\nfor(var i=start;i >=stop;i+=step){res[pos++]=self.source[i]}}\nreturn bytes.$factory(res)}else if(_b_.isinstance(arg,_b_.bool)){return self.source.__getitem__(_b_.int.$factory(arg))}}\nbytes.__gt__=function(self,other){if(invalid(other)){return _b_.NotImplemented}\nreturn _b_.list.__gt__(self.source,other.source)}\nbytes.__hash__=function(self){if(self===undefined){return bytes.__hashvalue__ ||$B.$py_next_hash--}\nvar hash=1\nfor(var i=0,len=self.source.length;i < len;i++){hash=(101*hash+self.source[i])& 0xFFFFFFFF}\nreturn hash}\nbytes.__init__=function(){return _b_.None}\nbytes.__le__=function(self,other){if(invalid(other)){return _b_.NotImplemented}\nreturn _b_.list.__le__(self.source,other.source)}\nbytes.__len__=function(self){return self.source.length}\nbytes.__lt__=function(self,other){if(invalid(other)){return _b_.NotImplemented}\nreturn _b_.list.__lt__(self.source,other.source)}\nbytes.__mod__=function(self,args){\nvar s=decode(self,\"ascii\",\"strict\"),res=_b_.str.__mod__(s,args)\nreturn _b_.str.encode(res,\"ascii\")}\nbytes.__mul__=function(){var $=$B.args('__mul__',2,{self:null,other:null},['self','other'],arguments,{},null,null),other=$B.PyNumber_Index($.other)\nvar t=[],source=$.self.source,slen=source.length\nfor(var i=0;i < other;i++){for(var j=0;j < slen;j++){t.push(source[j])}}\nvar res=bytes.$factory()\nres.source=t\nreturn res}\nbytes.__ne__=function(self,other){return ! bytes.__eq__(self,other)}\nbytes.__new__=function(cls,source,encoding,errors){var $=$B.args(\"__new__\",4,{cls:null,source:null,encoding:null,errors:null},[\"cls\",\"source\",\"encoding\",\"errors\"],arguments,{source:[],encoding:\"utf-8\",errors:\"strict\"},null,null)\nreturn bytes.$new($.cls,$.source,$.encoding,$.errors)}\nbytes.$new=function(cls,source,encoding,errors){\nvar self={__class__:cls},int_list=[],pos=0\nif(source===undefined){}else if(typeof source==\"number\" ||_b_.isinstance(source,_b_.int)){var i=source\nwhile(i--){int_list[pos++]=0}}else{if(typeof source==\"string\" ||_b_.isinstance(source,_b_.str)){if(encoding===undefined){throw _b_.TypeError.$factory(\"string argument without an encoding\")}\nint_list=encode(source,encoding ||\"utf-8\",errors ||\"strict\")}else{\nint_list=_b_.list.$factory(source)\nfor(var i=0;i < int_list.length;i++){try{var item=_b_.int.$factory(int_list[i])}catch(err){throw _b_.TypeError.$factory(\"'\"+\n$B.class_name(int_list[i])+\"' object \"+\n\"cannot be interpreted as an integer\")}\nif(item < 0 ||item > 255){throw _b_.ValueError.$factory(\"bytes must be in range\"+\n\"(0, 256)\")}}}}\nself.source=int_list\nself.encoding=encoding\nself.errors=errors\nreturn self}\nbytes.__repr__=bytes.__str__=function(self){var t=$B.special_string_repr,\nres=\"\"\nfor(var i=0,len=self.source.length;i < len;i++){var s=self.source[i]\nif(t[s]!==undefined){res+=t[s]}else if(s < 32 ||s >=128){var hx=s.toString(16)\nhx=(hx.length==1 ? '0' :'')+hx\nres+='\\\\x'+hx}else if(s==\"\\\\\".charCodeAt(0)){res+=\"\\\\\\\\\"}else{res+=String.fromCharCode(s)}}\nif(res.indexOf(\"'\")>-1 && res.indexOf('\"')==-1){return 'b\"'+res+'\"'}else{return \"b'\"+res.replace(new RegExp(\"'\",\"g\"),\"\\\\'\")+\"'\"}}\nbytes.__reduce_ex__=function(self){return bytes.__repr__(self)}\nbytes.capitalize=function(self){var src=self.source,len=src.length,buffer=src.slice()\nif(buffer[0]> 96 && buffer[0]< 123){buffer[0]-=32}\nfor(var i=1;i < len;++i){if(buffer[i]> 64 && buffer[i]< 91){buffer[i]+=32}}\nreturn bytes.$factory(buffer)}\nbytes.center=function(){var $=$B.args('center',3,{self:null,width:null,fillbyte:null},['self','width','fillbyte'],arguments,{fillbyte:bytes.$factory([32])},null,null)\nvar diff=$.width-$.self.source.length\nif(diff <=0){return bytes.$factory($.self.source)}\nvar ljust=bytes.ljust($.self,$.self.source.length+Math.floor(diff/2),$.fillbyte)\nreturn bytes.rjust(ljust,$.width,$.fillbyte)}\nbytes.count=function(){var $=$B.args('count',4,{self:null,sub:null,start:null,end:null},['self','sub','start','end'],arguments,{start:0,end:-1},null,null)\nvar n=0,index=-1,len=0\nif(typeof $.sub==\"number\"){if($.sub < 0 ||$.sub > 255)\nthrow _b_.ValueError.$factory(\"byte must be in range(0, 256)\")\nlen=1}else if(!$.sub.__class__){throw _b_.TypeError.$factory(\"first argument must be a bytes-like \"+\n\"object, not '\"+$B.class_name($.sub)+\"'\")}else if(!$.sub.__class__.$buffer_protocol){throw _b_.TypeError.$factory(\"first argument must be a bytes-like \"+\n\"object, not '\"+$B.class_name($.sub)+\"'\")}else{len=$.sub.source.length}\ndo{index=bytes.find($.self,$.sub,Math.max(index+len,$.start),$.end)\nif(index !=-1){n++}}while(index !=-1)\nreturn n}\nbytes.decode=function(self,encoding,errors){var $=$B.args(\"decode\",3,{self:null,encoding:null,errors:null},[\"self\",\"encoding\",\"errors\"],arguments,{encoding:\"utf-8\",errors:\"strict\"},null,null)\nswitch($.errors){case 'strict':\ncase 'ignore':\ncase 'replace':\ncase 'surrogateescape':\ncase 'surrogatepass':\ncase 'xmlcharrefreplace':\ncase 'backslashreplace':\nreturn decode($.self,$.encoding,$.errors)\ndefault:}}\nbytes.endswith=function(){var $=$B.args('endswith',4,{self:null,suffix:null,start:null,end:null},['self','suffix','start','end'],arguments,{start:-1,end:-1},null,null)\nif(_b_.isinstance($.suffix,bytes)){var start=$.start==-1 ?\n$.self.source.length-$.suffix.source.length :\nMath.min($.self.source.length-$.suffix.source.length,$.start)\nvar end=$.end==-1 ?\n($.start==-1 ? $.self.source.length :start+$.suffix.source.length):\nMath.min($.self.source.length-1,$.end)\nvar res=true\nfor(var i=$.suffix.source.length-1,len=$.suffix.source.length;\ni >=0 && res;--i){res=$.self.source[end-len+i]==$.suffix.source[i]}\nreturn res}else if(_b_.isinstance($.suffix,_b_.tuple)){for(var i=0;i < $.suffix.length;++i){if(_b_.isinstance($.suffix[i],bytes)){if(bytes.endswith($.self,$.suffix[i],$.start,$.end)){return true}}else{throw _b_.TypeError.$factory(\"endswith first arg must be \"+\n\"bytes or a tuple of bytes, not \"+\n$B.class_name($.suffix))}}\nreturn false}else{throw _b_.TypeError.$factory(\"endswith first arg must be bytes \"+\n\"or a tuple of bytes, not \"+$B.class_name($.suffix))}}\nbytes.expandtabs=function(){var $=$B.args('expandtabs',2,{self:null,tabsize:null},['self','tabsize'],arguments,{tabsize:8},null,null)\nvar tab_spaces=[]\nfor(let i=0;i < $.tabsize;++i){tab_spaces.push(32)}\nvar buffer=$.self.source.slice()\nfor(let i=0;i < buffer.length;++i){if(buffer[i]===9){buffer.splice.apply(buffer,[i,1].concat(tab_spaces))}}\nreturn _b_.bytes.$factory(buffer)}\nbytes.find=function(self,sub){if(arguments.length !=2){var $=$B.args('find',4,{self:null,sub:null,start:null,end:null},['self','sub','start','end'],arguments,{start:0,end:-1},null,null),sub=$.sub,start=$.start,end=$.end}else{var start=0,end=-1}\nif(typeof sub==\"number\"){if(sub < 0 ||sub > 255){throw _b_.ValueError.$factory(\"byte must be in range(0, 256)\")}\nreturn self.source.slice(0,end==-1 ? undefined :end).indexOf(sub,start)}else if(! sub.__class__){throw _b_.TypeError.$factory(\"first argument must be a bytes-like \"+\n\"object, not '\"+$B.class_name(sub)+\"'\")}else if(! sub.__class__.$buffer_protocol){throw _b_.TypeError.$factory(\"first argument must be a bytes-like \"+\n\"object, not '\"+$B.class_name(sub)+\"'\")}\nend=end==-1 ? self.source.length :Math.min(self.source.length,end)\nvar len=sub.source.length\nfor(var i=start;i <=end-len;i++){var chunk=self.source.slice(i,i+len),found=true\nfor(var j=0;j < len;j++){if(chunk[j]!=sub.source[j]){found=false\nbreak}}\nif(found){return i}}\nreturn-1}\nbytes.fromhex=function(){var $=$B.args('fromhex',2,{cls:null,string:null},['cls','string'],arguments,{},null,null),string=$.string.replace(/\\s/g,''),source=[]\nfor(var i=0;i < string.length;i+=2){if(i+2 > string.length){throw _b_.ValueError.$factory(\"non-hexadecimal number found \"+\n\"in fromhex() arg\")}\nsource.push(_b_.int.$factory(string.substr(i,2),16))}\nreturn $.cls.$factory(source)}\nbytes.hex=function(){\nvar $=$B.args('hex',3,{self:null,sep:null,bytes_per_sep:null},['self','sep','bytes_per_sep'],arguments,{sep:\"\",bytes_per_sep:1},null,null),self=$.self,sep=$.sep,bytes_per_sep=$.bytes_per_sep,res=\"\",digits=\"0123456789abcdef\",bps=bytes_per_sep,jstart=bps,len=self.source.length;\nif(bytes_per_sep < 0){bps=-bytes_per_sep;\njstart=bps}else if(bytes_per_sep==0){sep=''}else{jstart=len % bps\nif(jstart==0){jstart=bps}}\nfor(var i=0,j=jstart;i < len;i++){var c=self.source[i]\nif(j==0){res+=sep\nj=bps}\nj--\nres+=digits[c >> 4]\nres+=digits[c & 0x0f]}\nreturn res}\nbytes.index=function(){var $=$B.args('rfind',4,{self:null,sub:null,start:null,end:null},['self','sub','start','end'],arguments,{start:0,end:-1},null,null)\nvar index=bytes.find($.self,$.sub,$.start,$.end)\nif(index==-1){throw _b_.ValueError.$factory(\"subsection not found\")}\nreturn index}\nbytes.isalnum=function(self){var src=self.source,len=src.length,res=len > 0\nfor(var i=0;i < len && res;++i){res=(src[i]> 96 && src[i]< 123)||\n(src[i]> 64 && src[i]< 91)||\n(src[i]> 47 && src[i]< 58)}\nreturn res}\nbytes.isalpha=function(self){var src=self.source,len=src.length,res=len > 0\nfor(var i=0;i < len && res;++i){res=(src[i]> 96 && src[i]< 123)||(src[i]> 64 && src[i]< 91)}\nreturn res}\nbytes.isdigit=function(self){var src=self.source,len=src.length,res=len > 0\nfor(let i=0;i < len && res;++i){res=src[i]> 47 && src[i]< 58}\nreturn res}\nbytes.islower=function(self){var src=self.source,len=src.length,res=false\nfor(let i=0;i < len;++i){\nres=res ||(src[i]> 96 && src[i]< 123)\nif(src[i]> 64 && src[i]< 91){return false}}\nreturn res}\nbytes.isspace=function(self){var src=self.source,len=src.length\nfor(let i=0;i < len;++i){switch(src[i]){case 9:\ncase 10:\ncase 11:\ncase 12:\ncase 13:\ncase 32:\nbreak\ndefault:\nreturn false}}\nreturn true}\nbytes.isupper=function(self){var src=self.source,len=src.length,res=false\nfor(let i=0;i < len;++i){\nres=res ||(src[i]> 64 && src[i]< 91)\nif(src[i]> 96 && src[i]< 123){return false}}\nreturn res}\nbytes.istitle=function(self){var src=self.source,len=src.length,current_char_is_letter=false,prev_char_was_letter=false,is_uppercase=false,is_lowercase=false\nfor(var i=0;i < len;++i){is_lowercase=src[i]> 96 && src[i]< 123\nis_uppercase=src[i]> 64 && src[i]< 91\ncurrent_char_is_letter=is_lowercase ||is_uppercase\nif(current_char_is_letter &&\n(prev_char_was_letter && is_uppercase)||\n(! prev_char_was_letter && is_lowercase)){return false}\nprev_char_was_letter=current_char_is_letter}\nreturn true}\nbytes.join=function(){var $ns=$B.args('join',2,{self:null,iterable:null},['self','iterable'],arguments,{}),self=$ns['self'],iterable=$ns['iterable']\nvar next_func=$B.$getattr(_b_.iter(iterable),'__next__'),res=self.__class__.$factory(),empty=true\nwhile(true){try{var item=next_func()\nif(empty){empty=false}\nelse{res=bytes.__add__(res,self)}\nres=bytes.__add__(res,item)}catch(err){if(_b_.isinstance(err,_b_.StopIteration)){break}\nthrow err}}\nreturn res}\nvar _lower=function(char_code){if(char_code >=65 && char_code <=90){return char_code+32}else{return char_code}}\nbytes.lower=function(self){var _res=[],pos=0\nfor(var i=0,len=self.source.length;i < len;i++){if(self.source[i]){_res[pos++]=_lower(self.source[i])}}\nreturn bytes.$factory(_res)}\nbytes.ljust=function(){var $=$B.args('ljust',3,{self:null,width:null,fillbyte:null},['self','width','fillbyte'],arguments,{fillbyte:bytes.$factory([32])},null,null)\nif(!$.fillbyte.__class__){throw _b_.TypeError.$factory(\"argument 2 must be a byte string of length 1, \"+\n\"not '\"+$B.class_name($.fillbyte)+\"'\")}else if(!$.fillbyte.__class__.$buffer_protocol){throw _b_.TypeError.$factory(\"argument 2 must be a byte string of length 1, \"+\n\"not '\"+$B.class_name($.fillbyte)+\"'\")}\nvar padding=[],count=$.width-$.self.source.length\nfor(var i=0;i < count;++i){padding.push($.fillbyte.source[0])}\nreturn bytes.$factory($.self.source.concat(padding))}\nbytes.lstrip=function(self,cars){return _strip(self,cars,'l')}\nbytes.maketrans=function(from,to){var _t=[],to=$B.to_bytes(to)\nfor(var i=0;i < 256;i++){_t[i]=i}\nfor(var i=0,len=from.source.length;i < len;i++){var _ndx=from.source[i]\n_t[_ndx]=to[i]}\nreturn bytes.$factory(_t)}\nbytes.partition=function(){var $=$B.args('partition',2,{self:null,sep:null},['self','sep'],arguments,{},null,null)\nif(! $.sep.__class__){throw _b_.TypeError.$factory(\"a bytes-like object is required, \"+\n\"not '\"+$B.class_name($.sep)+\"'\")}else if(! $.sep.__class__.$buffer_protocol){throw _b_.TypeError.$factory(\"a bytes-like object is required, \"+\n\"not '\"+$B.class_name($.sep)+\"'\")}\nvar len=$.sep.source.length,src=$.self.source,i=bytes.find($.self,$.sep)\nreturn _b_.tuple.$factory([bytes.$factory(src.slice(0,i)),bytes.$factory(src.slice(i,i+len)),bytes.$factory(src.slice(i+len))\n])}\nbytes.removeprefix=function(){var $=$B.args(\"removeprefix\",2,{self:null,prefix:null},[\"self\",\"prefix\"],arguments,{},null,null)\nif(!_b_.isinstance($.prefix,[bytes,bytearray])){throw _b_.ValueError.$factory(\"prefix should be bytes, not \"+\n`'${$B.class_name($.prefix)}'`)}\nif(bytes.startswith($.self,$.prefix)){return bytes.__getitem__($.self,_b_.slice.$factory($.prefix.source.length,_b_.None))}\nreturn bytes.__getitem__($.self,_b_.slice.$factory(0,_b_.None))}\nbytes.removesuffix=function(){var $=$B.args(\"removesuffix\",2,{self:null,prefix:null},[\"self\",\"suffix\"],arguments,{},null,null)\nif(!_b_.isinstance($.suffix,[bytes,bytearray])){throw _b_.ValueError.$factory(\"suffix should be bytes, not \"+\n`'${$B.class_name($.suffix)}'`)}\nif(bytes.endswith($.self,$.suffix)){return bytes.__getitem__($.self,_b_.slice.$factory(0,$.suffix.source.length+1))}\nreturn bytes.__getitem__($.self,_b_.slice.$factory(0,_b_.None))}\nbytes.replace=function(){var $=$B.args('replace',4,{self:null,old:null,new:null,count:null},['self','old','new','count'],arguments,{count:-1},null,null),res=[]\nvar self=$.self,src=self.source,len=src.length,old=$.old,$new=$.new\nvar count=$.count >=0 ? $.count :src.length\nif(! $.old.__class__){throw _b_.TypeError.$factory(\"first argument must be a bytes-like \"+\n\"object, not '\"+$B.class_name($.old)+\"'\")}else if(! $.old.__class__.$buffer_protocol){throw _b_.TypeError.$factory(\"first argument must be a bytes-like \"+\n\"object, not '\"+$B.class_name($.sep)+\"'\")}\nif(! $.new.__class__){throw _b_.TypeError.$factory(\"second argument must be a bytes-like \"+\n\"object, not '\"+$B.class_name($.old)+\"'\")}else if(! $.new.__class__.$buffer_protocol){throw _b_.TypeError.$factory(\"second argument must be a bytes-like \"+\n\"object, not '\"+$B.class_name($.sep)+\"'\")}\nfor(var i=0;i < len;i++){if(bytes.startswith(self,old,i)&& count){for(var j=0;j < $new.source.length;j++){res.push($new.source[j])}\ni+=(old.source.length-1)\ncount--}else{res.push(src[i])}}\nreturn bytes.$factory(res)}\nbytes.rfind=function(self,subbytes){if(arguments.length==2 && subbytes.__class__===bytes){var sub=subbytes,start=0,end=-1}else{var $=$B.args('rfind',4,{self:null,sub:null,start:null,end:null},['self','sub','start','end'],arguments,{start:0,end:-1},null,null),self=$.self,sub=$.sub,start=$.start,end=$.end}\nif(typeof sub==\"number\"){if(sub < 0 ||sub > 255){throw _b_.ValueError.$factory(\"byte must be in range(0, 256)\")}\nreturn $.self.source.slice(start,$.end==-1 ? undefined :$.end).\nlastIndexOf(sub)+start}else if(! sub.__class__){throw _b_.TypeError.$factory(\"first argument must be a bytes-like \"+\n\"object, not '\"+$B.class_name($.sub)+\"'\")}else if(! sub.__class__.$buffer_protocol){throw _b_.TypeError.$factory(\"first argument must be a bytes-like \"+\n\"object, not '\"+$B.class_name(sub)+\"'\")}\nend=end==-1 ? self.source.length :Math.min(self.source.length,end)\nvar len=sub.source.length\nfor(var i=end-len;i >=start;--i){var chunk=self.source.slice(i,i+len),found=true\nfor(var j=0;j < len;j++){if(chunk[j]!=sub.source[j]){found=false\nbreak}}\nif(found){return i}}\nreturn-1}\nbytes.rindex=function(){var $=$B.args('rfind',4,{self:null,sub:null,start:null,end:null},['self','sub','start','end'],arguments,{start:0,end:-1},null,null)\nvar index=bytes.rfind($.self,$.sub,$.start,$.end)\nif(index==-1){throw _b_.ValueError.$factory(\"subsection not found\")}\nreturn index}\nbytes.rjust=function(){var $=$B.args('rjust',3,{self:null,width:null,fillbyte:null},['self','width','fillbyte'],arguments,{fillbyte:bytes.$factory([32])},null,null)\nif(!$.fillbyte.__class__){throw _b_.TypeError.$factory(\"argument 2 must be a byte string of length 1, \"+\n\"not '\"+$B.class_name($.fillbyte)+\"'\")}else if(!$.fillbyte.__class__.$buffer_protocol){throw _b_.TypeError.$factory(\"argument 2 must be a byte string of length 1, \"+\n\"not '\"+$B.class_name($.fillbyte)+\"'\")}\nvar padding=[],count=$.width-$.self.source.length\nfor(var i=0;i < count;++i){padding.push($.fillbyte.source[0])}\nreturn bytes.$factory(padding.concat($.self.source))}\nbytes.rpartition=function(){var $=$B.args('rpartition',2,{self:null,sep:null},['self','sep'],arguments,{},null,null)\nif(!$.sep.__class__){throw _b_.TypeError.$factory(\"a bytes-like object is required, \"+\n\"not '\"+$B.class_name($.sep)+\"'\")}else if(!$.sep.__class__.$buffer_protocol){throw _b_.TypeError.$factory(\"a bytes-like object is required, \"+\n\"not '\"+$B.class_name($.sep)+\"'\")}\nvar len=$.sep.source.length,src=$.self.source,i=bytes.rfind($.self,$.sep)\nreturn _b_.tuple.$factory([bytes.$factory(src.slice(0,i)),bytes.$factory(src.slice(i,i+len)),bytes.$factory(src.slice(i+len))\n])}\nbytes.rstrip=function(self,cars){return _strip(self,cars,'r')}\nbytes.split=function(){var $=$B.args('split',2,{self:null,sep:null},['self','sep'],arguments,{sep:bytes.$factory([32])},null,null),res=[],start=0,stop=0\nif(! $.sep.__class__ ){throw _b_.TypeError.$factory(\"a bytes-like object is required, \"+\n\"not '\"+$B.class_name($.sep)+\"'\")}else if(! $.sep.__class__.$buffer_protocol){throw _b_.TypeError.$factory(\"a bytes-like object is required, \"+\n\"not '\"+$B.class_name($.sep)+\"'\")}\nvar seps=$.sep.source,len=seps.length,src=$.self.source,blen=src.length\nwhile(stop < blen){var match=true\nfor(var i=0;i < len && match;i++){if(src[stop+i]!=seps[i]){match=false}}\nif(match){res.push(bytes.$factory(src.slice(start,stop)))\nstart=stop+len\nstop=start}else{stop++}}\nif(match ||(stop > start)){res.push(bytes.$factory(src.slice(start,stop)))}\nreturn res}\nbytes.splitlines=function(self){var $=$B.args('splitlines',2,{self:null,keepends:null},['self','keepends'],arguments,{keepends:false},null,null)\nif(!_b_.isinstance($.keepends,[_b_.bool,_b_.int])){throw _b_.TypeError('integer argument expected, got '+\n$B.get_class($.keepends).__name)}\nvar keepends=_b_.int.$factory($.keepends),res=[],source=$.self.source,start=0,pos=0\nif(! source.length){return res}\nwhile(pos < source.length){if(pos < source.length-1 && source[pos]==0x0d &&\nsource[pos+1]==0x0a){res.push(bytes.$factory(source.slice(start,keepends ? pos+2 :pos)))\nstart=pos=pos+2}else if(source[pos]==0x0d ||source[pos]==0x0a){res.push(bytes.$factory(source.slice(start,keepends ? pos+1 :pos)))\nstart=pos=pos+1}else{pos++}}\nif(start < source.length){res.push(bytes.$factory(source.slice(start)))}\nreturn res}\nbytes.startswith=function(){var $=$B.args('startswith',3,{self:null,prefix:null,start:null},['self','prefix','start'],arguments,{start:0},null,null),start=$.start\nif(_b_.isinstance($.prefix,bytes)){var res=true\nfor(var i=0;i < $.prefix.source.length && res;i++){res=$.self.source[start+i]==$.prefix.source[i]}\nreturn res}else if(_b_.isinstance($.prefix,_b_.tuple)){var items=[]\nfor(var i=0;i < $.prefix.length;i++){if(_b_.isinstance($.prefix[i],bytes)){items=items.concat($.prefix[i].source)}else{throw _b_.TypeError.$factory(\"startswith first arg must be \"+\n\"bytes or a tuple of bytes, not \"+\n$B.class_name($.prefix))}}\nvar prefix=bytes.$factory(items)\nreturn bytes.startswith($.self,prefix,start)}else{throw _b_.TypeError.$factory(\"startswith first arg must be bytes \"+\n\"or a tuple of bytes, not \"+$B.class_name($.prefix))}}\nbytes.strip=function(self,cars){var res=bytes.lstrip(self,cars)\nreturn bytes.rstrip(res,cars)}\nbytes.swapcase=function(self){var src=self.source,len=src.length,buffer=src.slice()\nfor(var i=0;i < len;++i){if(buffer[i]> 96 && buffer[i]< 123){buffer[i]-=32}else if(buffer[i]> 64 && buffer[i]< 91){buffer[i]+=32}}\nreturn bytes.$factory(buffer)}\nbytes.title=function(self){var src=self.source,len=src.length\nbuffer=src.slice(),current_char_is_letter=false,prev_char_was_letter=false,is_uppercase=false,is_lowercase=false\nfor(var i=0;i < len;++i){is_lowercase=buffer[i]> 96 && buffer[i]< 123\nis_uppercase=buffer[i]> 64 && buffer[i]< 91\ncurrent_char_is_letter=is_lowercase ||is_uppercase\nif(current_char_is_letter){if(prev_char_was_letter && is_uppercase){buffer[i]+=32}else if(! prev_char_was_letter && is_lowercase){buffer[i]-=32}}\nprev_char_was_letter=current_char_is_letter}\nreturn bytes.$factory(buffer)}\nbytes.translate=function(self,table,_delete){if(_delete===undefined){_delete=[]}else if(_b_.isinstance(_delete,bytes)){_delete=_delete.source}else{throw _b_.TypeError.$factory(\"Type \"+\n$B.get_class(_delete).__name+\" doesn't support the buffer API\")}\nvar res=[],pos=0\nif(_b_.isinstance(table,bytes)&& table.source.length==256){for(var i=0,len=self.source.length;i < len;i++){if(_delete.indexOf(self.source[i])>-1){continue}\nres[pos++]=table.source[self.source[i]]}}\nreturn bytes.$factory(res)}\nvar _upper=function(char_code){if(char_code >=97 && char_code <=122){return char_code-32}else{return char_code}}\nbytes.upper=function(self){var _res=[],pos=0\nfor(var i=0,len=self.source.length;i < len;i++){if(self.source[i]){_res[pos++]=_upper(self.source[i])}}\nreturn bytes.$factory(_res)}\nbytes.zfill=function(self,width){var buffer=self.source.slice(),prefix_offset=(buffer[0]==43 ||buffer[0]==45)? 1 :0\nvar count=width-self.source.length\nvar padding=[]\nfor(var i=0;i < count;++i){padding.push(48)}\nbuffer.splice.apply(buffer,[prefix_offset,0].concat(padding))\nreturn bytes.$factory(buffer)}\nfunction $UnicodeEncodeError(encoding,code_point,position){throw _b_.UnicodeEncodeError.$factory(\"'\"+encoding+\n\"' codec can't encode character \"+_b_.hex(code_point)+\n\" in position \"+position)}\nfunction $UnicodeDecodeError(encoding,position){throw _b_.UnicodeDecodeError.$factory(\"'\"+encoding+\n\"' codec can't decode bytes in position \"+position)}\nfunction _hex(_int){return _int.toString(16)}\nfunction _int(hex){return parseInt(hex,16)}\nfunction normalise(encoding){var enc=encoding.toLowerCase()\nif(enc.substr(0,7)==\"windows\"){enc=\"cp\"+enc.substr(7)}\nif(enc.startsWith(\"cp\")||enc.startsWith(\"iso\")){enc=enc.replace(\"-\",\"\")}\nenc=enc.replace(/-/g,\"_\")\nreturn enc}\nfunction load_decoder(enc){\nif(to_unicode[enc]===undefined){var mod=_b_.__import__(\"encodings.\"+enc)\nif(mod[enc].getregentry){to_unicode[enc]=$B.$getattr(mod[enc].getregentry(),\"decode\")}}}\nfunction load_encoder(enc){\nif(from_unicode[enc]===undefined){var mod=_b_.__import__(\"encodings.\"+enc)\nif(mod[enc].getregentry){from_unicode[enc]=$B.$getattr(mod[enc].getregentry(),\"encode\")}}}\nvar decode=$B.decode=function(obj,encoding,errors){var s=\"\",b=obj.source,enc=normalise(encoding)\nswitch(enc){case \"utf_8\":\ncase \"utf-8\":\ncase \"utf8\":\ncase \"U8\":\ncase \"UTF\":\nvar pos=0,s=\"\",err_info\nwhile(pos < b.length){var byte=b[pos]\nerr_info=null\nif(!(byte & 0x80)){\ns+=String.fromCodePoint(byte)\npos++}else if((byte >> 5)==6){\nif(b[pos+1]===undefined){err_info=[byte,pos,\"end\"]}else if((b[pos+1]& 0xc0)!=0x80){err_info=[byte,pos,\"continuation\"]}\nif(err_info !==null){if(errors==\"ignore\"){pos++}else{throw _b_.UnicodeDecodeError.$factory(\n\"'utf-8' codec can't decode byte 0x\"+\nerr_info[0].toString(16)+\"  in position \"+\nerr_info[1]+\n(err_info[2]==\"end\" ? \": unexpected end of data\" :\n\": invalid continuation byte\"))}}else{var cp=byte & 0x1f\ncp <<=6\ncp+=b[pos+1]& 0x3f\ns+=String.fromCodePoint(cp)\npos+=2}}else if((byte >> 4)==14){\nif(b[pos+1]===undefined){err_info=[byte,pos,\"end\",pos+1]}else if((b[pos+1]& 0xc0)!=0x80){err_info=[byte,pos,\"continuation\",pos+2]}else if(b[pos+2]===undefined){err_info=[byte,pos+'-'+(pos+1),\"end\",pos+2]}else if((b[pos+2]& 0xc0)!=0x80){err_info=[byte,pos,\"continuation\",pos+3]}\nif(err_info !==null){if(errors==\"ignore\"){pos=err_info[3]}else if(errors==\"surrogateescape\"){for(var i=pos;i < err_info[3];i++){s+=String.fromCodePoint(0xdc80+b[i]-0x80)}\npos=err_info[3]}else{throw _b_.UnicodeDecodeError.$factory(\n\"'utf-8' codec can't decode byte 0x\"+\nerr_info[0].toString(16)+\"  in position \"+\nerr_info[1]+\n(err_info[2]==\"end\" ? \": unexpected end of data\" :\n\": invalid continuation byte\"))}}else{var cp=byte & 0xf\ncp=cp << 12\ncp+=(b[pos+1]& 0x3f)<< 6\ncp+=b[pos+2]& 0x3f\ns+=String.fromCodePoint(cp)\npos+=3}}else if((byte >> 3)==30){\nif(b[pos+1]===undefined){err_info=[byte,pos,\"end\",pos+1]}else if((b[pos+1]& 0xc0)!=0x80){err_info=[byte,pos,\"continuation\",pos+2]}else if(b[pos+2]===undefined){err_info=[byte,pos+'-'+(pos+1),\"end\",pos+2]}else if((b[pos+2]& 0xc0)!=0x80){err_info=[byte,pos,\"continuation\",pos+3]}else if(b[pos+3]===undefined){err_info=[byte,pos+'-'+(pos+1)+'-'+(pos+2),\"end\",pos+3]}else if((b[pos+2]& 0xc0)!=0x80){err_info=[byte,pos,\"continuation\",pos+3]}\nif(err_info !==null){if(errors==\"ignore\"){pos=err_info[3]}else if(errors==\"surrogateescape\"){for(var i=pos;i < err_info[3];i++){s+=String.fromCodePoint(0xdc80+b[i]-0x80)}\npos=err_info[3]}else{throw _b_.UnicodeDecodeError.$factory(\n\"'utf-8' codec can't decode byte 0x\"+\nerr_info[0].toString(16)+\"  in position \"+\nerr_info[1]+\n(err_info[2]==\"end\" ? \": unexpected end of data\" :\n\": invalid continuation byte\"))}}else{var cp=byte & 0xf\ncp=cp << 18\ncp+=(b[pos+1]& 0x3f)<< 12\ncp+=(b[pos+2]& 0x3f)<< 6\ncp+=(b[pos+3]& 0x3f)\ns+=String.fromCodePoint(cp)\npos+=4}}else{if(errors==\"ignore\"){pos++}else if(errors==\"surrogateescape\"){s+=String.fromCodePoint(0xdc80+b[pos]-0x80)\npos++}else{throw _b_.UnicodeDecodeError.$factory(\n\"'utf-8' codec can't decode byte 0x\"+\nbyte.toString(16)+\" in position \"+pos+\n\": invalid start byte\")}}}\nreturn s\ncase \"latin_1\":\ncase \"windows1252\":\ncase \"iso-8859-1\":\ncase \"iso8859-1\":\ncase \"8859\":\ncase \"cp819\":\ncase \"latin\":\ncase \"latin1\":\ncase \"L1\":\nb.forEach(function(item){s+=String.fromCharCode(item)})\nbreak\ncase \"unicode_escape\":\nif(obj.__class__===bytes ||obj.__class__===bytearray){obj=decode(obj,\"latin-1\",\"strict\")}\nreturn obj.replace(/\\\\n/g,\"\\n\").\nreplace(/\\\\a/g,\"\\u0007\").\nreplace(/\\\\b/g,\"\\b\").\nreplace(/\\\\f/g,\"\\f\").\nreplace(/\\\\t/g,\"\\t\").\nreplace(/\\\\'/g,\"'\").\nreplace(/\\\\\"/g,'\"')\ncase \"raw_unicode_escape\":\nif(obj.__class__===bytes ||obj.__class__===bytearray){obj=decode(obj,\"latin-1\",\"strict\")}\nreturn obj.replace(/\\\\u([a-fA-F0-9]{4})/g,function(mo){var cp=parseInt(mo.substr(2),16)\nreturn String.fromCharCode(cp)})\ncase \"ascii\":\nfor(var i=0,len=b.length;i < len;i++){var cp=b[i]\nif(cp <=127){s+=String.fromCharCode(cp)}else{if(errors==\"ignore\"){}else{var msg=\"'ascii' codec can't decode byte 0x\"+\ncp.toString(16)+\" in position \"+i+\n\": ordinal not in range(128)\"\nthrow _b_.UnicodeDecodeError.$factory(msg)}}}\nbreak\ndefault:\ntry{load_decoder(enc)}catch(err){console.log(b,encoding,\"error load_decoder\",err)\nthrow _b_.LookupError.$factory(\"unknown encoding: \"+enc)}\nreturn to_unicode[enc](obj)[0]}\nreturn s}\nvar encode=$B.encode=function(){var $=$B.args(\"encode\",3,{s:null,encoding:null,errors:null},[\"s\",\"encoding\",\"errors\"],arguments,{encoding:\"utf-8\",errors:\"strict\"},null,null),s=$.s,encoding=$.encoding,errors=$.errors\nvar t=[],pos=0,enc=normalise(encoding)\nswitch(enc){case \"utf-8\":\ncase \"utf_8\":\ncase \"utf8\":\nvar res=[]\nfor(var i=0,len=s.length;i < len;i++){var cp=s.charCodeAt(i)\nif(cp < 0x7f){res.push(cp)}else if(cp < 0x7ff){res.push(0xc0+(cp >> 6),0x80+(cp & 0x3f))}else if(cp < 0xffff){res.push(0xe0+(cp >> 12),0x80+((cp & 0xfff)>> 6),0x80+(cp & 0x3f))}else{console.log(\"4 bytes\")}}\nreturn res\ncase \"latin\":\ncase \"latin1\":\ncase \"latin-1\":\ncase \"latin_1\":\ncase \"L1\":\ncase \"iso8859_1\":\ncase \"iso_8859_1\":\ncase \"8859\":\ncase \"cp819\":\ncase \"windows1252\":\nfor(var i=0,len=s.length;i < len;i++){var cp=s.charCodeAt(i)\nif(cp <=255){t[pos++]=cp}\nelse if(errors !=\"ignore\"){$UnicodeEncodeError(encoding,i)}}\nbreak\ncase \"ascii\":\nfor(var i=0,len=s.length;i < len;i++){var cp=s.charCodeAt(i)\nif(cp <=127){t[pos++]=cp}\nelse if(errors !=\"ignore\"){$UnicodeEncodeError(encoding,i)}}\nbreak\ncase \"raw_unicode_escape\":\nfor(var i=0,len=s.length;i < len;i++){var cp=s.charCodeAt(i)\nif(cp < 256){t[pos++]=cp}else{var us=cp.toString(16)\nif(us.length % 2){us=\"0\"+us}\nus=\"\\\\u\"+us\nfor(var j=0;j < us.length;j++){t[pos++]=us.charCodeAt(j)}}}\nbreak\ndefault:\ntry{load_encoder(enc)}catch(err){throw _b_.LookupError.$factory(\"unknown encoding: \"+encoding)}\nt=from_unicode[enc](s)[0].source}\nreturn t}\nbytes.$factory=function(source,encoding,errors){var $=$B.args(\"bytes\",3,{source:null,encoding:null,errors:null},[\"source\",\"encoding\",\"errors\"],arguments,{source:[],encoding:\"utf-8\",errors:\"strict\"},null,null)\nreturn bytes.$new(bytes,$.source,$.encoding,$.errors)}\nbytes.__class__=_b_.type\nbytes.$is_class=true\nfor(var attr in bytes){if(bytearray[attr]===undefined && typeof bytes[attr]==\"function\"){bytearray[attr]=(function(_attr){return function(){return bytes[_attr].apply(null,arguments)}})(attr)}}\n$B.set_func_names(bytes,\"builtins\")\nbytes.fromhex=_b_.classmethod.$factory(bytes.fromhex)\n$B.set_func_names(bytearray,\"builtins\")\nbytearray.fromhex=_b_.classmethod.$factory(bytearray.fromhex)\n_b_.bytes=bytes\n_b_.bytearray=bytearray})(__BRYTHON__)\n;\n;(function($B){var _b_=$B.builtins,object=_b_.object,$N=_b_.None\nfunction create_type(obj){return $B.get_class(obj).$factory()}\nfunction clone(obj){var res=create_type(obj)\nres.$items=obj.$items.slice()\nfor(key in obj.$hashes){res.$hashes[key]=obj.$hashes[key]}\nreturn res}\nvar set={__class__:_b_.type,$infos:{__module__:\"builtins\",__name__:\"set\"},$is_class:true,$native:true}\nset.__and__=function(self,other,accept_iter){try{$test(accept_iter,other)}catch(err){return _b_.NotImplemented}\nvar res=create_type(self)\nfor(var i=0,len=self.$items.length;i < len;i++){if(_b_.getattr(other,\"__contains__\")(self.$items[i])){set.add(res,self.$items[i])}}\nreturn res}\nset.__class_getitem__=function(cls,item){\nif(! Array.isArray(item)){item=[item]}\nreturn $B.GenericAlias.$factory(cls,item)}\nset.__contains__=function(self,item){if(typeof item==\"number\" ||item instanceof Number){if(isNaN(item)){\nfor(var i=self.$items.length-1;i >=0;i--){if(isNaN(self.$items[i])){return true}}\nreturn false}else if(item instanceof Number){return self.$numbers.indexOf(item.valueOf())>-1}else{return self.$items.indexOf(item)>-1}}else if(typeof item==\"string\"){return self.$items.indexOf(item)>-1}\nvar hash=_b_.hash(item),\nis_tuple=item.__class__===_b_.tuple\nif(self.$hashes[hash]){for(var i=0,len=self.$hashes[hash].length;i < len;i++){if(is_tuple && self.$hashes[hash][i].__class__===_b_.tuple){return true}else if($B.rich_comp(\"__eq__\",self.$hashes[hash][i],item)){return true}}}\nreturn false}\nset.__eq__=function(self,other){\nif(other===undefined){return self===set}\nif(_b_.isinstance(other,[_b_.set,_b_.frozenset])){if(other.$items.length==self.$items.length){for(var i=0,len=self.$items.length;i < len;i++){if(set.__contains__(self,other.$items[i])===false){return false}}\nreturn true}\nreturn false}\nreturn _b_.NotImplemented}\nset.__format__=function(self,format_string){return set.__str__(self)}\nset.__ge__=function(self,other){if(_b_.isinstance(other,[set,frozenset])){return set.__le__(other,self)}\nreturn _b_.NotImplemented}\nset.__gt__=function(self,other){if(_b_.isinstance(other,[set,frozenset])){return set.__lt__(other,self)}\nreturn _b_.NotImplemented}\nset.__hash__=_b_.None\nset.__init__=function(self,iterable,second){if(second===undefined){if(Array.isArray(iterable)){for(var i=0,len=iterable.length;i < len;i++){$add(self,iterable[i])}\nreturn $N}}\nvar $=$B.args(\"__init__\",2,{self:null,iterable:null},[\"self\",\"iterable\"],arguments,{iterable:[]},null,null),self=$.self,iterable=$.iterable\nif(_b_.isinstance(iterable,[set,frozenset])){self.$items=iterable.$items.slice()\nself.$hashes={}\nfor(var key in iterable.$hashes){self.$hashes[key]=iterable.$hashes[key]}\nreturn $N}\nvar it=$B.$iter(iterable)\nwhile(1){try{var item=_b_.next(it)\n$add(self,item)}catch(err){if(_b_.isinstance(err,_b_.StopIteration)){break}\nthrow err}}\nreturn $N}\nvar set_iterator=$B.make_iterator_class(\"set iterator\")\nset.__iter__=function(self){\nself.$items.sort(function(x,y){var hx=_b_.hash(x),hy=_b_.hash(y)\nreturn hx==hy ? 0 :\nhx < hy ?-1 :1})\nreturn set_iterator.$factory(self.$items)}\nset.__le__=function(self,other){\nif(_b_.isinstance(other,[set,frozenset])){var cfunc=_b_.getattr(other,\"__contains__\")\nfor(var i=0,len=self.$items.length;i < len;i++){if(! cfunc(self.$items[i])){return false}}\nreturn true}else{return _b_.NotImplemented}}\nset.__len__=function(self){return self.$items.length}\nset.__lt__=function(self,other){if(_b_.isinstance(other,[set,frozenset])){return set.__le__(self,other)&&\nset.__len__(self)< _b_.getattr(other,\"__len__\")()}else{return _b_.NotImplemented}}\nset.__mro__=[_b_.object]\nset.__new__=function(cls){if(cls===undefined){throw _b_.TypeError.$factory(\"set.__new__(): not enough arguments\")}\nreturn{\n__class__:cls,$items:[],$numbers:[],\n$hashes:{}}}\nset.__or__=function(self,other,accept_iter){\nvar res=clone(self),func=_b_.getattr($B.$iter(other),\"__next__\")\nwhile(1){try{set.add(res,func())}\ncatch(err){if(_b_.isinstance(err,_b_.StopIteration)){break}\nthrow err}}\nres.__class__=self.__class__\nreturn res}\nset.__rand__=function(self,other){\nreturn set.__and__(self,other)}\nset.__reduce__=function(self){return _b_.tuple.$factory([self.__class__,_b_.tuple.$factory([self.$items]),$N])}\nset.__reduce_ex__=function(self,protocol){return set.__reduce__(self)}\nset.__repr__=function(self){$B.builtins_repr_check(set,arguments)\nreturn set_repr(self)}\nfunction set_repr(self){\nklass_name=$B.class_name(self)\nif(self.$items.length===0){return klass_name+\"()\"}\nvar head=klass_name+\"({\",tail=\"})\"\nif(head==\"set({\"){head=\"{\";tail=\"}\"}\nvar res=[]\nif($B.repr.enter(self)){return klass_name+\"(...)\"}\nself.$items.sort()\nfor(var i=0,len=self.$items.length;i < len;i++){var r=_b_.repr(self.$items[i])\nif(r===self ||r===self.$items[i]){res.push(\"{...}\")}\nelse{res.push(r)}}\nres=res.join(\", \")\n$B.repr.leave(self)\nreturn head+res+tail}\nset.__rsub__=function(self,other){\nreturn set.__sub__(other,self)}\nset.__rxor__=function(self,other){\nreturn set.__xor__(self,other)}\nset.__sub__=function(self,other,accept_iter){\ntry{$test(accept_iter,other,\"-\")}\ncatch(err){return _b_.NotImplemented}\nvar res=create_type(self),cfunc=_b_.getattr(other,\"__contains__\"),items=[]\nfor(var i=0,len=self.$items.length;i < len;i++){if(! cfunc(self.$items[i])){items.push(self.$items[i])}}\nset.__init__.call(null,res,items)\nreturn res}\nset.__xor__=function(self,other,accept_iter){\ntry{$test(accept_iter,other,\"^\")}\ncatch(err){return _b_.NotImplemented}\nvar res=create_type(self),cfunc=_b_.getattr(other,\"__contains__\")\nfor(var i=0,len=self.$items.length;i < len;i++){if(! cfunc(self.$items[i])){set.add(res,self.$items[i])}}\nfor(var i=0,len=other.$items.length;i < len;i++){if(! set.__contains__(self,other.$items[i])){set.add(res,other.$items[i])}}\nreturn res}\nfunction $test(accept_iter,other,op){if(accept_iter===undefined &&\n! _b_.isinstance(other,[set,frozenset])){throw _b_.TypeError.$factory(\"unsupported operand type(s) for \"+op+\n\": 'set' and '\"+$B.class_name(other)+\"'\")}}\n$B.make_rmethods(set)\nfunction $add(self,item){var $simple=false\nif(typeof item===\"string\" ||typeof item===\"number\" ||\nitem instanceof Number){$simple=true}\nif($simple){var ix=self.$items.indexOf(item)\nif(ix==-1){if(item instanceof Number &&\nself.$numbers.indexOf(item.valueOf())>-1){}else if(typeof item==\"number\" &&\nself.$numbers.indexOf(item)>-1){}else{self.$items.push(item)\nvar value=item.valueOf()\nif(typeof value==\"number\"){self.$numbers.push(value)}}}else{\nif(item !==self.$items[ix]){self.$items.push(item)}}}else{\nvar hashvalue=_b_.hash(item)\nvar items=self.$hashes[hashvalue]\nif(items===undefined){self.$hashes[hashvalue]=[item]\nself.$items.push(item)}else{var items=self.$hashes[hashvalue],cfunc=function(other){return $B.rich_comp(\"__eq__\",item,other)}\nfor(var i=0,len=items.length;i < len;i++){if(cfunc(items[i])){\nreturn $N}}\nself.$hashes[hashvalue].push(item)\nself.$items.push(item)}}\nreturn $N}\nset.add=function(){var $=$B.args(\"add\",2,{self:null,item:null},[\"self\",\"item\"],arguments,{},null,null),self=$.self,item=$.item\nreturn $add(self,item)}\nset.clear=function(){var $=$B.args(\"clear\",1,{self:null},[\"self\"],arguments,{},null,null)\n$.self.$items=[]\n$.self.$numbers=[]\n$.self.$hashes={}\nreturn $N}\nset.copy=function(){var $=$B.args(\"copy\",1,{self:null},[\"self\"],arguments,{},null,null)\nif(_b_.isinstance($.self,frozenset)){return $.self}\nvar res=set.$factory()\n$.self.$items.forEach(function(item){res.$items.push(item)})\n$.self.$numbers.forEach(function(item){res.$numbers.push(item)})\nfor(key in self.$hashes){res.$hashes[key]=self.$hashes[key]}\nreturn res}\nset.difference_update=function(self){var $=$B.args(\"difference_update\",1,{self:null},[\"self\"],arguments,{},\"args\",null)\nfor(var i=0;i < $.args.length;i++){var s=set.$factory($.args[i]),_next=_b_.getattr($B.$iter(s),\"__next__\"),item\nwhile(true){try{item=_next()\nvar _type=typeof item\nif(_type==\"string\" ||_type==\"number\"){var _index=self.$items.indexOf(item)\nif(_index >-1){self.$items.splice(_index,1)}}else{for(var j=0;j < self.$items.length;j++){if($B.rich_comp(\"__eq__\",self.$items[j],item)){self.$items.splice(j,1)\nvar hash=_b_.hash(item)\nif(self.$hashes[hash]){for(var k=0;k < self.$hashes[hash].length;k++){if($B.rich_comp(\"__eq__\",self.$hashes[hash][k],item)){self.$hashes[hash].splice(k,1)\nbreak}}}}}}}catch(err){if(_b_.isinstance(err,_b_.StopIteration)){break}\nthrow err}}}\nreturn $N}\nset.discard=function(){var $=$B.args(\"discard\",2,{self:null,item:null},[\"self\",\"item\"],arguments,{},null,null)\ntry{set.remove($.self,$.item)}\ncatch(err){if(!_b_.isinstance(err,[_b_.KeyError,_b_.LookupError])){throw err}}\nreturn $N}\nset.intersection_update=function(){\nvar $=$B.args(\"intersection_update\",1,{self:null},[\"self\"],arguments,{},\"args\",null),self=$.self\nfor(var i=0;i < $.args.length;i++){var remove=[],s=set.$factory($.args[i])\nfor(var j=0;j < self.$items.length;j++){var _item=self.$items[j],_type=typeof _item\nif(_type==\"string\" ||_type==\"number\"){if(s.$items.indexOf(_item)==-1){remove.push(j)}}else{var found=false,hash=_b_.hash(_item)\nif(s.$hashes[hash]){var hashes=s.$hashes[hash]\nfor(var k=0;! found && k < hashes.length;k++){if($B.rich_comp(\"__eq__\",hashes[k],_item)){found=true}}\nif(! found){remove.push(j)\nhashes=self.$hashes[hash]\nfor(var k=0;! found && k < hashes.length;k++){if($B.rich_comp(\"__eq__\",hashes[k],_item)){self.$hashes.splice(k,1)}}}}}}\nremove.sort(function(x,y){return x-y}).reverse()\nfor(var j=0;j < remove.length;j++){self.$items.splice(remove[j],1)}}\nreturn $N}\nset.isdisjoint=function(){var $=$B.args(\"is_disjoint\",2,{self:null,other:null},[\"self\",\"other\"],arguments,{},null,null)\nfor(var i=0,len=$.self.$items.length;i < len;i++){if(_b_.getattr($.other,\"__contains__\")($.self.$items[i])){return false}}\nreturn true}\nset.pop=function(self){if(self.$items.length===0){throw _b_.KeyError.$factory('pop from an empty set')}\nvar item=self.$items.pop()\nif(typeof item !=\"string\" && typeof item !=\"number\"){\nvar hash=_b_.hash(item),items=self.$hashes[hash]\nfor(var k=0;k < items.length;k++){if($B.rich_comp(\"__eq__\",items[k],item)){self.$hashes[hash].splice(k,1)\nbreak}}}\nreturn item}\nset.remove=function(self,item){\nvar $=$B.args(\"remove\",2,{self:null,item:null},[\"self\",\"item\"],arguments,{},null,null),self=$.self,item=$.item\nif(! _b_.isinstance(item,set)){_b_.hash(item)}\nif(typeof item==\"string\" ||typeof item==\"number\"){var _i=self.$items.indexOf(item)\nif(_i==-1){throw _b_.KeyError.$factory(item)}\nself.$items.splice(_i,1)\nif(typeof item==\"number\"){self.$numbers.splice(self.$numbers.indexOf(item),1)}\nreturn $N}\nvar hash=_b_.hash(item)\nif(self.$hashes[hash]){\nfor(var i=0,len=self.$items.length;i < len;i++){if($B.rich_comp(\"__eq__\",self.$items[i],item)){self.$items.splice(i,1)\nif(item instanceof Number){self.$numbers.splice(self.$numbers.indexOf(item.valueOf()),1)}\nbreak}}\nfor(var i=0,len=self.$hashes[hash].length;i < len;i++){if($B.rich_comp(\"__eq__\",self.$hashes[hash][i],item)){self.$hashes[hash].splice(i,1)\nbreak}}\nreturn $N}\nthrow _b_.KeyError.$factory(item)}\nset.symmetric_difference_update=function(self,s){\nvar $=$B.args(\"symmetric_difference_update\",2,{self:null,s:null},[\"self\",\"s\"],arguments,{},null,null),self=$.self,s=$.s\nvar _next=_b_.getattr($B.$iter(s),\"__next__\"),item,remove=[],add=[]\nwhile(true){try{item=_next()\nvar _type=typeof item\nif(_type==\"string\" ||_type==\"number\"){var _index=self.$items.indexOf(item)\nif(_index >-1){remove.push(_index)}else{add.push(item)}}else{var found=false\nfor(var j=0;! found && j < self.$items.length;j++){if($B.rich_comp(\"__eq__\",self.$items[j],item)){remove.push(j)\nfound=true}}\nif(! found){add.push(item)}}}catch(err){if(_b_.isinstance(err,_b_.StopIteration)){break}\nthrow err}}\nremove.sort(function(x,y){return x-y}).reverse()\nfor(var i=0;i < remove.length;i++){if(remove[i]!=remove[i-1]){self.$items.splice(remove[i],1)}}\nfor(var i=0;i < add.length;i++){set.add(self,add[i])}\nreturn $N}\nset.update=function(self){\nvar $=$B.args(\"update\",1,{self:null},[\"self\"],arguments,{},\"args\",null)\nfor(var i=0;i < $.args.length;i++){var other=set.$factory($.args[i])\nfor(var j=0,_len=other.$items.length;j < _len;j++){$add(self,other.$items[j])}}\nreturn $N}\nset.difference=function(){var $=$B.args(\"difference\",1,{self:null},[\"self\"],arguments,{},\"args\",null)\nif($.args.length==0){return set.copy($.self)}\nvar res=clone($.self)\nfor(var i=0;i < $.args.length;i++){res=set.__sub__(res,set.$factory($.args[i]),true)}\nreturn res}\nvar fc=set.difference+\"\" \neval(\"set.intersection = \"+\nfc.replace(/difference/g,\"intersection\").replace(\"__sub__\",\"__and__\"))\neval(\"set.symmetric_difference = \"+\nfc.replace(/difference/g,\"symmetric_difference\").replace(\"__sub__\",\"__xor__\"))\neval(\"set.union = \"+\nfc.replace(/difference/g,\"union\").replace(\"__sub__\",\"__or__\"))\nset.issubset=function(){var $=$B.args(\"issubset\",2,{self:null,other:null},[\"self\",\"other\"],arguments,{},\"args\",null),func=_b_.getattr($.other,\"__contains__\")\nfor(var i=0,len=$.self.$items.length;i < len;i++){if(! func($.self.$items[i])){return false}}\nreturn true}\nset.issuperset=function(){var $=$B.args(\"issuperset\",2,{self:null,other:null},[\"self\",\"other\"],arguments,{},\"args\",null)\nvar func=_b_.getattr($.self,\"__contains__\"),it=$B.$iter($.other)\nwhile(true){try{var item=_b_.next(it)\nif(! func(item)){return false}}catch(err){if(_b_.isinstance(err,_b_.StopIteration)){return true}\nthrow err}}\nreturn true}\nfunction $accept_only_set(f,op){return function(self,other,accept_iter){$test(accept_iter,other,op)\nf(self,other)\nreturn self}}\nset.__iand__=$accept_only_set(set.intersection_update,\"&=\")\nset.__isub__=$accept_only_set(set.difference_update,\"-=\")\nset.__ixor__=$accept_only_set(set.symmetric_difference_update,\"^=\")\nset.__ior__=$accept_only_set(set.update,\"|=\")\nset.$factory=function(){\nvar res={__class__:set,$simple:true,$items:[],$numbers:[],$hashes:{}}\nvar args=[res].concat(Array.prototype.slice.call(arguments))\nset.__init__.apply(null,args)\nreturn res}\n$B.set_func_names(set,\"builtins\")\nset.__class_getitem__=_b_.classmethod.$factory(set.__class_getitem__)\nvar frozenset={__class__:_b_.type,__mro__:[object],$infos:{__module__:\"builtins\",__name__:\"frozenset\"},$is_class:true,$native:true}\nfor(var attr in set){switch(attr){case \"add\":\ncase \"clear\":\ncase \"discard\":\ncase \"pop\":\ncase \"remove\":\ncase \"update\":\nbreak\ndefault:\nif(frozenset[attr]==undefined){if(typeof set[attr]==\"function\"){frozenset[attr]=(function(x){return function(){return set[x].apply(null,arguments)}})(attr)}else{frozenset[attr]=set[attr]}}}}\nfrozenset.__hash__=function(self){if(self===undefined){return frozenset.__hashvalue__ ||$B.$py_next_hash--}\nif(self.__hashvalue__ !==undefined){return self.__hashvalue__}\nvar _hash=1927868237\n_hash*=self.$items.length\nfor(var i=0,len=self.$items.length;i < len;i++){var _h=_b_.hash(self.$items[i])\n_hash ^=((_h ^ 89869747)^(_h << 16))*3644798167}\n_hash=_hash*69069+907133923\nif(_hash==-1){_hash=590923713}\nreturn self.__hashvalue__=_hash}\nfrozenset.__new__=function(cls){if(cls===undefined){throw _b_.TypeError.$factory(\n\"frozenset.__new__(): not enough arguments\")}\nreturn{\n__class__:cls,$simple:true,$items:[],$numbers:[],$hashes:{}}}\nfrozenset.__repr__=function(self){$B.builtins_repr_check(frozenset,arguments)\nreturn set_repr(self)}\nvar singleton_id=Math.floor(Math.random()*Math.pow(2,40))\nfunction empty_frozenset(){var res=frozenset.__new__(frozenset)\nres.$id=singleton_id\nreturn res}\nfrozenset.$factory=function(){var $=$B.args(\"frozenset\",1,{iterable:null},[\"iterable\"],arguments,{iterable:null},null,null)\nif($.iterable===null){return empty_frozenset()}\nelse if($.iterable.__class__==frozenset){return $.iterable}\nvar res=set.$factory($.iterable)\nif(res.$items.length==0){return empty_frozenset()}\nres.__class__=frozenset\nreturn res}\n$B.set_func_names(frozenset,\"builtins\")\n_b_.set=set\n_b_.frozenset=frozenset})(__BRYTHON__)\n;\n;(function($B){var _b_=$B.builtins\nvar object=_b_.object\nvar _window=self;\nfunction to_simple(value){switch(typeof value){case 'string':\ncase 'number':\nreturn value\ncase 'boolean':\nreturn value ? \"true\" :\"false\"\ncase 'object':\nif(value===_b_.None){return 'null'}else if(value instanceof Number){return value.valueOf()}else if(value instanceof String){return value.valueOf()}\ndefault:\nconsole.log(\"erreur\",value)\nthrow _b_.TypeError.$factory(\"keys must be str, int, \"+\n\"float, bool or None, not \"+$B.class_name(value))}}\n$B.pyobj2structuredclone=function(obj,strict){\nstrict=strict===undefined ? true :strict\nif(typeof obj==\"boolean\" ||typeof obj==\"number\" ||\ntypeof obj==\"string\" ||obj instanceof String){return obj}else if(obj instanceof Number){return obj.valueOf()}else if(obj===_b_.None){return null }else if(Array.isArray(obj)||obj.__class__===_b_.list ||\nobj.__class__===_b_.tuple){var res=[]\nfor(var i=0,len=obj.length;i < len;i++){res.push($B.pyobj2structuredclone(obj[i]))}\nreturn res}else if(_b_.isinstance(obj,_b_.dict)){if(strict){if(Object.keys(obj.$numeric_dict).length > 0 ||\nObject.keys(obj.$object_dict).length > 0){throw _b_.TypeError.$factory(\"a dictionary with non-string \"+\n\"keys does not support structured clone\")}}\nvar items=$B.dict_to_list(obj),res={}\nfor(var i=0,len=items.length;i < len;i++){res[to_simple(items[i][0])]=$B.pyobj2structuredclone(items[i][1])}\nreturn res}else{return obj}}\n$B.structuredclone2pyobj=function(obj){if(obj===null){return _b_.None}else if(obj===undefined){return $B.Undefined}else if(typeof obj==\"boolean\" ||typeof obj==\"number\" ||\ntypeof obj==\"string\"){return obj}else if(obj instanceof Number ||obj instanceof String){return obj.valueOf()}else if(Array.isArray(obj)||obj.__class__===_b_.list ||\nobj.__class__===_b_.tuple){var res=_b_.list.$factory()\nfor(var i=0,len=obj.length;i < len;i++){res.push($B.structuredclone2pyobj(obj[i]))}\nreturn res}else if(typeof obj==\"object\"){var res=$B.empty_dict()\nfor(var key in obj){_b_.dict.$setitem(res,key,$B.structuredclone2pyobj(obj[key]))}\nreturn res}else{console.log(obj,Array.isArray(obj),obj.__class__,_b_.list,obj.__class__===_b_.list)\nthrow _b_.TypeError.$factory(_b_.str.$factory(obj)+\n\" does not support the structured clone algorithm\")}}\nvar JSConstructor={__class__:_b_.type,__mro__:[object],$infos:{__module__:\"<javascript>\",__name__:'JSConstructor'},$is_class:true}\nJSConstructor.__call__=function(self){\nreturn function(){var args=[null]\nfor(var i=0,len=arguments.length;i < len;i++){args.push(pyobj2jsobj(arguments[i]))}\nvar factory=self.func.bind.apply(self.func,args)\nvar res=new factory()\nreturn $B.$JS2Py(res)}}\nJSConstructor.__getattribute__=function(self,attr){\nif(attr==\"__call__\"){return function(){var args=[null]\nfor(var i=0,len=arguments.length;i < len;i++){args.push(pyobj2jsobj(arguments[i]))}\nvar factory=self.func.bind.apply(self.func,args)\nvar res=new factory()\nreturn $B.$JS2Py(res)}}\nreturn JSObject.__getattribute__(self,attr)}\nJSConstructor.$factory=function(obj){return{\n__class__:JSConstructor,js:obj,func:obj.js_func}}\nvar jsobj2pyobj=$B.jsobj2pyobj=function(jsobj){switch(jsobj){case true:\ncase false:\nreturn jsobj}\nif(jsobj===undefined){return $B.Undefined}else if(jsobj===null){return _b_.None}\nif(Array.isArray(jsobj)){return _b_.list.$factory(jsobj.map(jsobj2pyobj))}else if(typeof jsobj==='number'){if(jsobj.toString().indexOf('.')==-1){return _b_.int.$factory(jsobj)}\nreturn _b_.float.$factory(jsobj)}else if(typeof jsobj==\"string\"){return $B.String(jsobj)}else if(typeof jsobj==\"function\"){\nreturn function(){var args=[]\nfor(var i=0,len=arguments.length;i < len;i++){args.push(pyobj2jsobj(arguments[i]))}\nreturn jsobj2pyobj(jsobj.apply(null,args))}}\nif(jsobj.$nat==='kw'){return jsobj}\nif($B.$isNode(jsobj)){return $B.DOMNode.$factory(jsobj)}\nreturn $B.JSObj.$factory(jsobj)}\nvar pyobj2jsobj=$B.pyobj2jsobj=function(pyobj){\nif(pyobj===true ||pyobj===false){return pyobj}\nif(pyobj===_b_.None){return null}\nif(pyobj===$B.Undefined){return undefined}\nvar klass=$B.get_class(pyobj)\nif(klass===undefined){\nreturn pyobj;}\nif(klass===JSConstructor){\nif(pyobj.js_func !==undefined){return pyobj.js_func}\nreturn pyobj.js}else if(klass===$B.DOMNode ||\nklass.__mro__.indexOf($B.DOMNode)>-1){\nreturn pyobj}else if([_b_.list,_b_.tuple].indexOf(klass)>-1){\nvar res=[]\npyobj.forEach(function(item){res.push(pyobj2jsobj(item))})\nreturn res}else if(klass===_b_.dict ||_b_.issubclass(klass,_b_.dict)){\nvar jsobj={}\nvar items=_b_.list.$factory(_b_.dict.items(pyobj))\nitems.forEach(function(item){if(typeof item[1]=='function'){\nitem[1].bind(jsobj)}\njsobj[item[0]]=pyobj2jsobj(item[1])})\nreturn jsobj}else if(klass===_b_.float ||klass===_b_.str){\nreturn pyobj.valueOf()}else if(klass===$B.Function ||klass===$B.method){\nif(pyobj.prototype &&\npyobj.prototype.constructor===pyobj &&\n! pyobj.$is_func){\nreturn pyobj}\nreturn function(){try{var args=[]\nfor(var i=0;i < arguments.length;i++){if(arguments[i]===undefined){args.push(_b_.None)}\nelse{args.push(jsobj2pyobj(arguments[i]))}}\nif(pyobj.prototype.constructor===pyobj && ! pyobj.$is_func){var res=new pyobj(...args)}else{var res=pyobj.apply(this,args)}\nreturn pyobj2jsobj(res)}catch(err){console.log(err)\nconsole.log($B.$getattr(err,'info'))\nconsole.log($B.class_name(err)+':',err.args.length > 0 ? err.args[0]:'' )\nthrow err}}}else{\nreturn pyobj}}\n$B.JSConstructor=JSConstructor\nfunction pyargs2jsargs(pyargs){var args=[]\nfor(var i=0,len=pyargs.length;i < len;i++){var arg=pyargs[i]\nif(arg !==undefined && arg !==null &&\narg.$nat !==undefined){var kw=arg.kw\nif(Array.isArray(kw)){kw=$B.extend(js_attr.name,...kw)}\nif(Object.keys(kw).length > 0){\nthrow _b_.TypeError.$factory(\n\"A Javascript function can't take \"+\n\"keyword arguments\")}}else{args.push($B.pyobj2jsobj(arg))}}\nreturn args}\n$B.JSObj=$B.make_class(\"JSObj\",function(jsobj){if(Array.isArray(jsobj)){}else if(typeof jsobj==\"function\"){jsobj.$is_js_func=true\njsobj.__new__=function(){return new jsobj.$js_func(...arguments)}}else if(typeof jsobj==\"number\" && ! Number.isInteger(jsobj)){return new Number(jsobj)}\nreturn jsobj}\n)\n$B.JSObj.__sub__=function(self,other){\nif(typeof self==\"bigint\" && typeof other==\"bigint\"){return self-other}\nthrow _b_.TypeError.$factory(\"unsupported operand type(s) for - : '\"+\n$B.class_name(self)+\"' and '\"+$B.class_name(other)+\"'\")}\nvar ops={'+':'__add__','*':'__mul__','**':'__pow__','%' :'__mod__'}\nfor(var op in ops){eval('$B.JSObj.'+ops[op]+' = '+\n($B.JSObj.__sub__+'').replace(/-/g,op))}\n$B.JSObj.__eq__=function(self,other){switch(typeof self){case \"object\":\nif(self.__eq__ !==undefined){return self.__eq__(other)}\nif(Object.keys(self).length !==Object.keys(other).length){return false}\nfor(var key in self){if(! $B.JSObj.__eq__(self[key],other[key])){return false}}\ndefault:\nreturn self===other}}\n$B.JSObj.__ne__=function(self,other){return ! $B.JSObj.__eq__(self,other)}\n$B.JSObj.__getattribute__=function(self,attr){var test=false \nif(test){console.log(\"__ga__\",self,attr)}\nif(attr==\"new\" && typeof self==\"function\"){\nif(self.$js_func){return function(){var args=pyargs2jsargs(arguments)\nreturn $B.JSObj.$factory(new self.$js_func(...args))}}else{return function(){var args=pyargs2jsargs(arguments)\nreturn $B.JSObj.$factory(new self(...args))}}}\nvar js_attr=self[attr]\nif(js_attr==undefined && typeof self==\"function\" && self.$js_func){js_attr=self.$js_func[attr]}\nif(js_attr===undefined){if(typeof self.getNamedItem=='function'){var res=self.getNamedItem(attr)\nif(res !==undefined){return $B.JSObj.$factory(res)}}\nvar klass=$B.get_class(self)\nif(klass && klass[attr]){var class_attr=klass[attr]\nif(typeof class_attr==\"function\"){return function(){var args=[self]\nfor(var i=0,len=arguments.length;i < len;i++){args.push(arguments[i])}\nreturn $B.JSObj.$factory(class_attr.apply(null,args))}}else{return class_attr}}\nif(attr==\"bind\" && typeof self.addEventListener==\"function\"){return function(event,callback){return self.addEventListener(event,callback)}}\nthrow $B.attr_error(attr,self)}\nif(typeof js_attr==='function'){var res=function(){var args=pyargs2jsargs(arguments),target=self.$js_func ||self\ntry{var result=js_attr.apply(target,args)}catch(err){console.log(\"error\",err)\nconsole.log(\"attribute\",attr,\"of self\",self,js_attr,args,arguments)\nthrow err}\nif(result===undefined){return $B.Undefined}else if(result===null){return _b_.None}\nreturn $B.JSObj.$factory(result)}\nres.prototype=js_attr.prototype\nres.$js_func=js_attr\nres.__mro__=[_b_.object]\nres.$infos={__name__:js_attr.name,__qualname__:js_attr.name}\nif($B.frames_stack.length > 0){res.$infos.__module__=$B.last($B.frames_stack)[3].__name__}\nreturn $B.JSObj.$factory(res)}else{return $B.JSObj.$factory(js_attr)}}\n$B.JSObj.__setattr__=function(self,attr,value){self[attr]=$B.pyobj2structuredclone(value)\nreturn _b_.None}\n$B.JSObj.__getitem__=function(self,key){if(typeof key==\"string\"){return $B.JSObj.__getattribute__(self,key)}else if(typeof key==\"number\"){if(self[key]!==undefined){return $B.JSObj.$factory(self[key])}\nif(typeof self.length=='number'){if((typeof key==\"number\" ||typeof key==\"boolean\")&&\ntypeof self.item=='function'){var rank=_b_.int.$factory(key)\nif(rank < 0){rank+=self.length}\nvar res=self.item(rank)\nif(res===null){throw _b_.IndexError.$factory(rank)}\nreturn $B.JSObj.$factory(res)}}}else if(key.__class__===_b_.slice &&\ntypeof self.item=='function'){var _slice=_b_.slice.$conv_for_seq(key,self.length)\nvar res=[]\nfor(var i=_slice.start;i < _slice.stop;i+=_slice.step){res.push(self.item(i))}\nreturn res}\nthrow _b_.KeyError.$factory(rank)}\n$B.JSObj.__setitem__=$B.JSObj.__setattr__\nvar JSObj_iterator=$B.make_iterator_class('JS object iterator')\n$B.JSObj.__iter__=function(self){var items=[]\nif(_window.Symbol && self[Symbol.iterator]!==undefined){\nvar items=[]\nif(self.next !==undefined){while(true){var nxt=self.next()\nif(nxt.done){break}\nitems.push($B.JSObj.$factory(nxt.value))}}else if(self.length !==undefined && self.item !==undefined){for(var i=0;i < self.length;i++){items.push($B.JSObj.$factory(self.item(i)))}}\nreturn JSObj_iterator.$factory(items)}else if(self.length !==undefined && self.item !==undefined){\nfor(var i=0;i < self.length;i++){items.push($B.JSObj.$factory(self.js.item(i)))}\nreturn JSObj_iterator.$factory(items)}\nreturn JSObj_iterator.$factory(Object.keys(self))}\n$B.JSObj.__len__=function(self){if(typeof self.length=='number'){return self.length}\nthrow $B.attr_error('__len__',self)}\n$B.JSObj.__repr__=$B.JSObj.__str__=function(self){return '<Javascript '+self.constructor.name+' object: '+\nself.toString()+'>'}\n$B.JSObj.bind=function(self,evt,func){\nvar js_func=function(ev){return func(jsobj2pyobj(ev))}\nself.addEventListener(evt,js_func)\nreturn _b_.None}\n$B.JSObj.to_dict=function(self){\nreturn $B.structuredclone2pyobj(self)}\n$B.set_func_names($B.JSObj,\"builtins\")\n$B.JSMeta=$B.make_class(\"JSMeta\")\n$B.JSMeta.__call__=function(cls){\nvar extra_args=[],klass=arguments[0]\nfor(var i=1,len=arguments.length;i < len;i++){extra_args.push(arguments[i])}\nvar new_func=_b_.type.__getattribute__(klass,\"__new__\")\nvar instance=new_func.apply(null,arguments)\nif(instance instanceof cls.__mro__[0].$js_func){\nvar init_func=_b_.type.__getattribute__(klass,\"__init__\")\nif(init_func !==_b_.object.__init__){\nvar args=[instance].concat(extra_args)\ninit_func.apply(null,args)}}\nreturn instance}\n$B.JSMeta.__mro__=[_b_.type,_b_.object]\n$B.JSMeta.__getattribute__=function(cls,attr){if(cls[attr]!==undefined){return cls[attr]}else if($B.JSMeta[attr]!==undefined){return $B.JSMeta[attr]}else{\nreturn _b_.type.__getattribute__(cls,attr)}}\n$B.JSMeta.__init_subclass__=function(){}\n$B.JSMeta.__new__=function(metaclass,class_name,bases,cl_dict){\neval(\"var \"+class_name+` = function(){\n        if(cl_dict.$string_dict.__init__){\n            var args = [this]\n            for(var i = 0, len = arguments.length; i < len; i++){\n                args.push(arguments[i])\n            }\n            cl_dict.$string_dict.__init__[0].apply(this, args)\n        }else{\n            return new bases[0].$js_func(...arguments)\n        }\n    }`)\nvar new_js_class=eval(class_name)\nnew_js_class.prototype=Object.create(bases[0].$js_func.prototype)\nnew_js_class.prototype.constructor=new_js_class\nnew_js_class.__mro__=[bases[0],_b_.type]\nnew_js_class.$is_js_class=true\nreturn new_js_class}\n$B.set_func_names($B.JSMeta,\"builtins\")})(__BRYTHON__)\n;\n;(function($B){$B.stdlib={}\nvar pylist=['VFS_import','__future__','_codecs','_codecs_jp','_collections','_collections_abc','_compat_pickle','_compression','_contextvars','_csv','_dummy_thread','_frozen_importlib','_functools','_imp','_io','_markupbase','_multibytecodec','_operator','_py_abc','_pydecimal','_queue','_random','_signal','_socket','_sre','_struct','_sysconfigdata','_sysconfigdata_0_brython_','_testcapi','_thread','_threading_local','_weakref','_weakrefset','abc','antigravity','argparse','ast','atexit','base64','bdb','binascii','bisect','browser.aio','browser.ajax','browser.highlight','browser.html','browser.idbcache','browser.indexed_db','browser.local_storage','browser.markdown','browser.object_storage','browser.session_storage','browser.svg','browser.template','browser.timer','browser.ui','browser.webcomponent','browser.websocket','browser.webworker','browser.worker','calendar','cmath','cmd','code','codecs','codeop','colorsys','configparser','contextlib','contextvars','copy','copyreg','csv','dataclasses','datetime','decimal','difflib','doctest','enum','errno','external_import','faulthandler','fnmatch','formatter','fractions','functools','gc','genericpath','getopt','getpass','gettext','glob','gzip','heapq','hmac','imp','inspect','interpreter','io','ipaddress','itertools','json','keyword','linecache','locale','mimetypes','nntplib','ntpath','numbers','opcode','operator','optparse','os','pathlib','pdb','pickle','pkgutil','platform','posixpath','pprint','profile','pwd','py_compile','pydoc','queue','quopri','re','reprlib','select','selectors','shlex','shutil','signal','site','site-packages.__future__','site-packages.docs','site-packages.header','site-packages.test_sp','socket','sre_compile','sre_constants','sre_parse','stat','statistics','string','stringprep','struct','subprocess','sys','sysconfig','tabnanny','tarfile','tb','tempfile','test.namespace_pkgs.module_and_namespace_package.a_test','textwrap','this','threading','time','timeit','token','tokenize','traceback','turtle','types','typing','uu','uuid','warnings','weakref','webbrowser','zipfile','zipimport','zlib']\nfor(var i=0;i < pylist.length;i++){$B.stdlib[pylist[i]]=['py']}\nvar js=['_aio','_ajax','_ast','_base64','_binascii','_io_classes','_json','_jsre','_locale','_multiprocessing','_posixsubprocess','_profile','_sre_utils','_string','_strptime','_svg','_webcomponent','_webworker','_zlib_utils','aes','array','bry_re','builtins','dis','encoding_cp932','hashlib','hmac-md5','hmac-ripemd160','hmac-sha1','hmac-sha224','hmac-sha256','hmac-sha3','hmac-sha384','hmac-sha512','html_parser','long_int','marshal','math','md5','modulefinder','pbkdf2','posix','python_re','rabbit','rabbit-legacy','random','rc4','ripemd160','sha1','sha224','sha256','sha3','sha384','sha512','tripledes','unicodedata']\nfor(var i=0;i < js.length;i++){$B.stdlib[js[i]]=['js']}\nvar pkglist=['browser.widgets','collections','concurrent','concurrent.futures','email','email.mime','encodings','html','http','importlib','logging','multiprocessing','multiprocessing.dummy','pydoc_data','site-packages.foobar','site-packages.simpleaio','site-packages.ui','test','test.encoded_modules','test.leakers','test.namespace_pkgs.not_a_namespace_pkg.foo','test.support','test.test_email','test.test_importlib','test.test_importlib.builtin','test.test_importlib.extension','test.test_importlib.frozen','test.test_importlib.import_','test.test_importlib.source','test.test_json','test.tracedmodules','unittest','unittest.test','unittest.test.testmock','urllib']\nfor(var i=0;i < pkglist.length;i++){$B.stdlib[pkglist[i]]=['py',true]}})(__BRYTHON__)\n;\n\n;(function($B){var _b_=$B.builtins,_window=self\nvar Module=$B.module=$B.make_class(\"module\",function(name,doc,$package){var obj=Object.create(null)\nobj.__class__=Module\nobj.__name__=name\nobj.__doc__=doc ||_b_.None\nobj. __package__=$package ||_b_.None\nreturn obj}\n)\nModule.__new__=function(cls,name,doc,$package){return{\n__class__:cls,__name__:name,__doc__:doc ||_b_.None,__package__:$package ||_b_.None}}\nModule.__repr__=Module.__str__=function(self){var res=\"<module \"+self.__name__\nif(self.__file__===undefined){res+=\" (built-in)\"}\nreturn res+\">\"}\nModule.__setattr__=function(self,attr,value){if(self.__name__==\"__builtins__\"){\n$B.builtins[attr]=value}else{self[attr]=value}}\n$B.set_func_names(Module,\"builtins\")\nfunction $download_module(mod,url,$package){var xhr=new XMLHttpRequest(),fake_qs=\"?v=\"+(new Date().getTime()),res=null,mod_name=mod.__name__\nvar timer=_window.setTimeout(function(){xhr.abort()},5000)\nif($B.$options.cache){xhr.open(\"GET\",url,false)}else{xhr.open(\"GET\",url+fake_qs,false)}\nxhr.send()\nif($B.$CORS){if(xhr.status==200 ||xhr.status==0){res=xhr.responseText}else{res=_b_.ModuleNotFoundError.$factory(\"No module named '\"+\nmod_name+\"'\")}}else{if(xhr.readyState==4){if(xhr.status==200){res=xhr.responseText\nmod.$last_modified=\nxhr.getResponseHeader(\"Last-Modified\")}else{\nconsole.info(\"Error \"+xhr.status+\n\" means that Python module \"+mod_name+\n\" was not found at url \"+url)\nres=_b_.ModuleNotFoundError.$factory(\"No module named '\"+\nmod_name+\"'\")}}}\n_window.clearTimeout(timer)\nif(res==null){throw _b_.ModuleNotFoundError.$factory(\"No module named '\"+\nmod_name+\"' (res is null)\")}\nif(res.constructor===Error){throw res}\nreturn res}\n$B.$download_module=$download_module\nfunction import_js(mod,path){try{var module_contents=$download_module(mod,path,undefined)}catch(err){return null}\nrun_js(module_contents,path,mod)\nreturn true}\nfunction run_js(module_contents,path,_module){\nvar module_id=\"$locals_\"+_module.__name__.replace(/\\./g,'_')\ntry{var $module=new Function(module_id,module_contents+\";\\nreturn $module\")(_module)\nif($B.$options.store){_module.$js=module_contents}}catch(err){console.log(err)\nconsole.log(path,_module)\nthrow err}\ntry{$module}\ncatch(err){console.log(\"no $module\")\nthrow _b_.ImportError.$factory(\"name '$module' not defined in module\")}\n$module.__name__=_module.__name__\nfor(var attr in $module){if(typeof $module[attr]==\"function\"){$module[attr].$infos={__module__:_module.__name__,__name__:attr,__qualname__:attr}\n$module[attr].$in_js_module=true}}\nif(_module !==undefined){\nfor(var attr in $module){_module[attr]=$module[attr]}\n$module=_module\n$module.__class__=Module }else{\n$module.__class__=Module\n$module.__name__=_module.__name__\n$module.__repr__=$module.__str__=function(){if($B.builtin_module_names.indexOf(_module.name)>-1){return \"<module '\"+_module.__name__+\"' (built-in)>\"}\nreturn \"<module '\"+_module.__name__+\"' from \"+path+\" >\"}\nif(_module.name !=\"builtins\"){\n$module.__file__=path}}\n$B.imported[_module.__name__]=$module\nreturn true}\nfunction show_ns(){var kk=Object.keys(_window)\nfor(var i=0,len=kk.length;i < len;i++){console.log(kk[i])\nif(kk[i].charAt(0)==\"$\"){console.log(eval(kk[i]))}}\nconsole.log(\"---\")}\nfunction run_py(module_contents,path,module,compiled){\n$B.file_cache[path]=module_contents\nvar root,js,mod_name=module.__name__ \nif(! compiled){var $Node=$B.$Node,$NodeJSCtx=$B.$NodeJSCtx\nvar src={src:module_contents,has_annotations:false}\nroot=$B.py2js(src,module,module.__name__,$B.builtins_scope)\nif(module.__package__ !==undefined){root.binding[\"__package__\"]=true}}\ntry{js=compiled ? module_contents :root.to_js()\nif($B.$options.debug==10){console.log(\"code for module \"+module.__name__)\nconsole.log(js)}\nvar src=js\njs=\"var $module = (function(){\\n\"+js+\"return $locals_\"+\nmodule.__name__.replace(/\\./g,\"_\")+\"})(__BRYTHON__)\\n\"+\n\"return $module\"\nvar module_id=\"$locals_\"+module.__name__.replace(/\\./g,'_')\nvar $module=(new Function(module_id,js))(module)}catch(err){if($B.debug > 1){console.log(err+\" for module \"+module.__name__)\nconsole.log(\"module\",module)\nconsole.log(root)\nif($B.debug > 1){console.log(js)}\nfor(var attr in err){console.log(attr,err[attr])}\nconsole.log($B.$getattr(err,\"info\",\"[no info]\"))\nconsole.log(\"message: \"+err.$message)\nconsole.log(\"filename: \"+err.fileName)\nconsole.log(\"linenum: \"+err.lineNumber)}\nif($B.debug > 0){console.log(\"line info \"+$B.line_info)}\nthrow err}finally{$B.clear_ns(module.__name__)}\ntry{\nvar mod=eval(\"$module\")\nfor(var attr in mod){module[attr]=mod[attr]}\nmodule.__initializing__=false\n$B.imported[module.__name__]=module\nreturn{\ncontent:src,name:mod_name,imports:Object.keys(root.imports).join(\",\")}}catch(err){console.log(\"\"+err+\" \"+\" for module \"+module.__name__)\nfor(var attr in err){console.log(attr+\" \"+err[attr])}\nif($B.debug > 0){console.log(\"line info \"+__BRYTHON__.line_info)}\nthrow err}}\n$B.run_py=run_py \n$B.run_js=run_js\nvar ModuleSpec=$B.make_class(\"ModuleSpec\",function(fields){fields.__class__=ModuleSpec\nreturn fields}\n)\nModuleSpec.__str__=ModuleSpec.__repr__=function(self){var res=`ModuleSpec(name='${self.name}', `+\n`loader=${_b_.str.$factory(self.loader)}, `+\n`origin='${self.origin}'`\nif(self.submodule_search_locations !==_b_.None){res+=`, submodule_search_locations=`+\n`${_b_.str.$factory(self.submodule_search_locations)}`}\nreturn res+')'}\n$B.set_func_names(ModuleSpec,\"builtins\")\nfunction parent_package(mod_name){\nvar parts=mod_name.split(\".\")\nparts.pop()\nreturn parts.join(\".\")}\nvar VFSFinder=$B.make_class(\"VFSFinder\",function(){return{\n__class__:VFSFinder}}\n)\nVFSFinder.find_spec=function(cls,fullname,path){var stored,is_package,timestamp\nif(!$B.use_VFS){return _b_.None}\nstored=$B.VFS[fullname]\nif(stored===undefined){return _b_.None}\nis_package=stored[3]||false\ntimestamp=stored.timestamp\nif(stored){var is_builtin=$B.builtin_module_names.indexOf(fullname)>-1\nreturn ModuleSpec.$factory({name :fullname,loader:VFSLoader.$factory(),\norigin :is_builtin? \"built-in\" :\"brython_stdlib\",\nsubmodule_search_locations:is_package?[]:_b_.None,loader_state:{stored:stored,timestamp:timestamp},\ncached:_b_.None,parent:is_package? fullname :parent_package(fullname),has_location:_b_.False})}}\n$B.set_func_names(VFSFinder,\"<import>\")\nfor(var method in VFSFinder){if(typeof VFSFinder[method]==\"function\"){VFSFinder[method]=_b_.classmethod.$factory(\nVFSFinder[method])}}\nVFSLoader=$B.make_class(\"VFSLoader\",function(){return{\n__class__:VFSLoader}}\n)\nVFSLoader.create_module=function(self,spec){\nreturn _b_.None}\nVFSLoader.exec_module=function(self,modobj){\nvar stored=modobj.__spec__.loader_state.stored,timestamp=modobj.__spec__.loader_state.timestamp\ndelete modobj.__spec__[\"loader_state\"]\nvar ext=stored[0],module_contents=stored[1],imports=stored[2]\nmodobj.$is_package=stored[3]||false\nvar path=\"VFS.\"+modobj.__name__\npath+=modobj.$is_package ? \"/__init__.py\" :ext\nmodobj.__file__=path\n$B.file_cache[modobj.__file__]=$B.VFS[modobj.__name__][1]\nif(ext=='.js'){run_js(module_contents,modobj.__path__,modobj)}else if($B.precompiled.hasOwnProperty(modobj.__name__)){if($B.debug > 1){console.info(\"load\",modobj.__name__,\"from precompiled\")}\nvar parts=modobj.__name__.split(\".\")\nfor(var i=0;i < parts.length;i++){var parent=parts.slice(0,i+1).join(\".\")\nif($B.imported.hasOwnProperty(parent)&&\n$B.imported[parent].__initialized__){continue}\nvar mod_js=$B.precompiled[parent],is_package=modobj.$is_package\nif(mod_js===undefined){\ncontinue}\nif(Array.isArray(mod_js)){mod_js=mod_js[0]}\nvar mod=$B.imported[parent]=Module.$factory(parent,undefined,is_package)\nmod.__initialized__=true\nif(is_package){mod.__path__=\"<stdlib>\"\nmod.__package__=parent}else{var elts=parent.split(\".\")\nelts.pop()\nmod.__package__=elts.join(\".\")}\nmod.__file__=path\ntry{var parent_id=parent.replace(/\\./g,\"_\")\nmod_js+=\"return $locals_\"+parent_id\nvar $module=new Function(\"$locals_\"+parent_id,mod_js)(\nmod)}catch(err){if($B.debug > 1){console.log('error in module',mod)\nconsole.log(err)\nfor(var k in err){console.log(k,err[k])}\nconsole.log(Object.keys($B.imported))\nif($B.debug > 2){console.log(modobj,\"mod_js\",mod_js)}}\nthrow err}\nfor(var attr in $module){mod[attr]=$module[attr]}\n$module.__file__=path\nif(i > 0){\n$B.builtins.setattr(\n$B.imported[parts.slice(0,i).join(\".\")],parts[i],$module)}}\nreturn $module}else{var mod_name=modobj.__name__\nif($B.debug > 1){console.log(\"run Python code from VFS\",mod_name)}\nvar record=run_py(module_contents,modobj.__path__,modobj)\nrecord.imports=imports.join(',')\nrecord.is_package=modobj.$is_package\nrecord.timestamp=$B.timestamp\nrecord.source_ts=timestamp\n$B.precompiled[mod_name]=record.is_package ?[record.content]:\nrecord.content\nvar elts=mod_name.split(\".\")\nif(elts.length > 1){elts.pop()}\nif($B.$options.indexedDB && $B.indexedDB &&\n$B.idb_name){\nvar idb_cx=indexedDB.open($B.idb_name)\nidb_cx.onsuccess=function(evt){var db=evt.target.result,tx=db.transaction(\"modules\",\"readwrite\"),store=tx.objectStore(\"modules\"),cursor=store.openCursor(),request=store.put(record)\nrequest.onsuccess=function(){if($B.debug > 1){console.info(modobj.__name__,\"stored in db\")}}\nrequest.onerror=function(){console.info(\"could not store \"+modobj.__name__)}}}}}\n$B.set_func_names(VFSLoader,\"builtins\")\nvar finder_cpython={__class__:_b_.type,__mro__:[_b_.object],$infos:{__module__:\"builtins\",__name__:\"CPythonFinder\"},create_module :function(cls,spec){\nreturn _b_.None},exec_module :function(cls,modobj){console.log(\"exec PYthon module\",modobj)\nvar loader_state=modobj.__spec__.loader_state\nvar content=loader_state.content\ndelete modobj.__spec__[\"loader_state\"]\nmodobj.$is_package=loader_state.is_package\nmodobj.__file__=loader_state.__file__\n$B.file_cache[modobj.__file__]=content\nvar mod_name=modobj.__name__\nif($B.debug > 1){console.log(\"run Python code from CPython\",mod_name)}\nrun_py(content,modobj.__path__,modobj)},find_module:function(cls,name,path){return{\n__class__:Loader,load_module:function(name,path){var spec=cls.find_spec(cls,name,path)\nvar mod=Module.$factory(name)\n$B.imported[name]=mod\nmod.__spec__=spec\ncls.exec_module(cls,mod)}}},find_spec :function(cls,fullname,path){console.log(\"finder cpython\",fullname)\nvar xhr=new XMLHttpRequest(),url=\"/cpython_import?module=\"+fullname,result\nxhr.open(\"GET\",url,false)\nxhr.onreadystatechange=function(){if(this.readyState==4 && this.status==200){var data=JSON.parse(this.responseText)\nresult=ModuleSpec.$factory({name :fullname,loader:cls,\norigin :\"CPython\",\nsubmodule_search_locations:data.is_package?[]:_b_.None,loader_state:{content:data.content},\ncached:_b_.None,parent:data.is_package? fullname :parent_package(fullname),has_location:_b_.False})}}\nxhr.send()\nreturn result}}\n$B.set_func_names(finder_cpython,\"<import>\")\nfor(var method in finder_cpython){if(typeof finder_cpython[method]==\"function\"){finder_cpython[method]=_b_.classmethod.$factory(\nfinder_cpython[method])}}\nfinder_cpython.$factory=function(){return{__class__:finder_cpython}}\nvar StdlibStaticFinder=$B.make_class(\"StdlibStaticFinder\",function(){return{\n__class__:StdlibStaticFinder}}\n)\nStdlibStaticFinder.find_spec=function(self,fullname,path){\nif($B.stdlib && $B.$options.static_stdlib_import){var address=$B.stdlib[fullname]\nif(address===undefined){var elts=fullname.split(\".\")\nif(elts.length > 1){elts.pop()\nvar $package=$B.stdlib[elts.join(\".\")]\nif($package && $package[1]){address=[\"py\"]}}}\nif(address !==undefined){var ext=address[0],is_pkg=address[1]!==undefined,path=$B.brython_path+\n((ext==\"py\")? \"Lib/\" :\"libs/\")+\nfullname.replace(/\\./g,\"/\"),metadata={ext:ext,is_package:is_pkg,path:path+(is_pkg? \"/__init__.py\" :\n((ext==\"py\")? \".py\" :\".js\")),address:address},_module=Module.$factory(fullname)\nmetadata.code=$download_module(_module,metadata.path)\nvar res=ModuleSpec.$factory({name :fullname,loader:PathLoader.$factory(),\norigin :metadata.path,submodule_search_locations:is_pkg?[path]:_b_.None,loader_state:metadata,\ncached:_b_.None,parent:is_pkg ? fullname :parent_package(fullname),has_location:_b_.True})\nreturn res}}\nreturn _b_.None}\n$B.set_func_names(StdlibStaticFinder,\"<import>\")\nfor(var method in StdlibStaticFinder){if(typeof StdlibStaticFinder[method]==\"function\"){StdlibStaticFinder[method]=_b_.classmethod.$factory(\nStdlibStaticFinder[method])}}\nStdlibStaticFinder.$factory=function(){return{__class__:StdlibStaticFinder}}\nvar PathFinder=$B.make_class(\"PathFinder\",function(){return{\n__class__:PathFinder}}\n)\nPathFinder.find_spec=function(cls,fullname,path){if($B.VFS && $B.VFS[fullname]){\nreturn _b_.None}\nif($B.is_none(path)){\npath=$B.path}\nfor(var i=0,li=path.length;i < li;++i){var path_entry=path[i]\nif(path_entry[path_entry.length-1]!=\"/\"){path_entry+=\"/\"}\nvar finder=$B.path_importer_cache[path_entry]\nif(finder===undefined){\nfor(var j=0,lj=$B.path_hooks.length;j < lj;++j){var hook=$B.path_hooks[j]\ntry{finder=$B.$call(hook)(path_entry)\n$B.path_importer_cache[path_entry]=finder\nbreak}catch(e){if(e.__class__ !==_b_.ImportError){throw e}}}}\nif($B.is_none(finder)){continue}\nvar find_spec=$B.$getattr(finder,\"find_spec\"),spec=$B.$call(find_spec)(fullname)\nif(!$B.is_none(spec)){return spec}}\nreturn _b_.None}\n$B.set_func_names(PathFinder,\"<import>\")\nfor(var method in PathFinder){if(typeof PathFinder[method]==\"function\"){PathFinder[method]=_b_.classmethod.$factory(\nPathFinder[method])}}\nvar PathEntryFinder=$B.make_class(\"PathEntryFinder\",function(path_entry,hint){return{\n__class__:PathEntryFinder,path_entry:path_entry,hint:hint}}\n)\nPathEntryFinder.find_spec=function(self,fullname){\nvar loader_data={},notfound=true,hint=self.hint,base_path=self.path_entry+fullname.match(/[^.]+$/g)[0],modpaths=[],py_ext=$B.$options.python_extension \nvar tryall=hint===undefined\nif(tryall ||hint=='py'){\nmodpaths=modpaths.concat([[base_path+py_ext,\"py\",false],[base_path+\"/__init__\"+py_ext,\"py\",true]])}\nfor(var j=0;notfound && j < modpaths.length;++j){try{var file_info=modpaths[j],module={__name__:fullname,$is_package:false}\nloader_data.code=$download_module(module,file_info[0],undefined)\nnotfound=false\nloader_data.ext=file_info[1]\nloader_data.is_package=file_info[2]\nif(hint===undefined){self.hint=file_info[1]\n$B.path_importer_cache[self.path_entry]=self}\nif(loader_data.is_package){\n$B.path_importer_cache[base_path+'/']=\n$B.$call(url_hook)(base_path+'/',self.hint)}\nloader_data.path=file_info[0]}catch(err){if(err.__class__ !==_b_.ModuleNotFoundError){throw err}}}\nif(!notfound){return ModuleSpec.$factory({name :fullname,loader:PathLoader.$factory(),origin :loader_data.path,\nsubmodule_search_locations:loader_data.is_package?\n[base_path]:_b_.None,loader_state:loader_data,\ncached:_b_.None,parent:loader_data.is_package? fullname :\nparent_package(fullname),has_location:_b_.True})}\nreturn _b_.None}\n$B.set_func_names(PathEntryFinder,\"builtins\")\nvar PathLoader=$B.make_class(\"PathLoader\",function(){return{\n__class__:PathLoader}}\n)\nPathLoader.create_module=function(self,spec){\nreturn _b_.None}\nPathLoader.exec_module=function(self,module){\nvar metadata=module.__spec__.loader_state\nmodule.$is_package=metadata.is_package\nif(metadata.ext==\"py\"){run_py(metadata.code,metadata.path,module)}else{run_js(metadata.code,metadata.path,module)}}\nvar url_hook=$B.url_hook=function(path_entry){\npath_entry=path_entry.endsWith(\"/\")? path_entry :path_entry+\"/\"\nreturn PathEntryFinder.$factory(path_entry)}\nfunction import_engine(mod_name,_path,from_stdlib){\nvar meta_path=$B.meta_path.slice(),_sys_modules=$B.imported,_loader,spec\nif(from_stdlib){\nvar path_ix=meta_path.indexOf($B.finders[\"path\"])\nif(path_ix >-1){meta_path.splice(path_ix,1)}}\nfor(var i=0,len=meta_path.length;i < len;i++){var _finder=meta_path[i],find_spec=$B.$getattr(_finder,\"find_spec\",_b_.None)\nif(find_spec==_b_.None){\nvar find_module=$B.$getattr(_finder,\"find_module\",_b_.None)\nif(find_module !==_b_.None){_loader=find_module(mod_name,_path)\nif(_loader !==_b_.None){\nvar load_module=$B.$getattr(_loader,\"load_module\"),module=$B.$call(load_module)(mod_name)\n_sys_modules[mod_name]=module\nreturn module}}}else{spec=find_spec(mod_name,_path)\nif(!$B.is_none(spec)){module=$B.imported[spec.name]\nif(module !==undefined){\nreturn _sys_modules[spec.name]=module}\n_loader=$B.$getattr(spec,\"loader\",_b_.None)\nbreak}}}\nif(_loader===undefined){\nmessage=mod_name\nif($B.protocol==\"file\"){message+=\" (warning: cannot import local files with protocol 'file')\"}\nvar exc=_b_.ModuleNotFoundError.$factory(message)\nexc.name=mod_name\nthrow exc}\nif($B.is_none(module)){if(spec===_b_.None){throw _b_.ModuleNotFoundError.$factory(mod_name)}\nvar _spec_name=$B.$getattr(spec,\"name\")\nif(!$B.is_none(_loader)){var create_module=$B.$getattr(_loader,\"create_module\",_b_.None)\nif(!$B.is_none(create_module)){module=$B.$call(create_module)(spec)}}\nif(module===undefined){throw _b_.ImportError.$factory(mod_name)}\nif($B.is_none(module)){\nmodule=$B.module.$factory(mod_name)\nvar mod_desc=$B.$getattr(spec,\"origin\")\nif($B.$getattr(spec,\"has_location\")){mod_desc=\"from '\"+mod_desc+\"'\"}else{mod_desc=\"(\"+mod_desc+\")\"}}}\nmodule.__name__=_spec_name\nmodule.__loader__=_loader\nmodule.__package__=$B.$getattr(spec,\"parent\",\"\")\nmodule.__spec__=spec\nvar locs=$B.$getattr(spec,\"submodule_search_locations\")\nif(module.$is_package=!$B.is_none(locs)){module.__path__=locs}\nif($B.$getattr(spec,\"has_location\")){module.__file__=$B.$getattr(spec,\"origin\")}\nvar cached=$B.$getattr(spec,\"cached\")\nif(! $B.is_none(cached)){module.__cached__=cached}\nif($B.is_none(_loader)){if(!$B.is_none(locs)){_sys_modules[_spec_name]=module}else{throw _b_.ImportError.$factory(mod_name)}}else{var exec_module=$B.$getattr(_loader,\"exec_module\",_b_.None)\nif($B.is_none(exec_module)){\nmodule=$B.$getattr(_loader,\"load_module\")(_spec_name)}else{_sys_modules[_spec_name]=module\ntry{exec_module(module)}catch(e){delete _sys_modules[_spec_name]\nthrow e}}}\nreturn _sys_modules[_spec_name]}\n$B.path_importer_cache={}\nfunction import_error(mod_name){var exc=_b_.ImportError.$factory(mod_name)\nexc.name=mod_name\nthrow exc}\n$B.$__import__=function(mod_name,globals,locals,fromlist,level){var $test=false \nif($test){console.log(\"__import__\",mod_name)}\nvar from_stdlib=false\nif(globals.$jsobj && globals.$jsobj.__file__){var file=globals.$jsobj.__file__\nif((file.startsWith($B.brython_path+\"Lib/\")&&\n! file.startsWith($B.brython_path+\"Lib/site-packages/\"))||\nfile.startsWith($B.brython_path+\"libs/\")||\nfile.startsWith(\"VFS.\")){from_stdlib=true}}\nvar modobj=$B.imported[mod_name],parsed_name=mod_name.split('.'),has_from=fromlist.length > 0\nif(modobj==_b_.None){\nimport_error(mod_name)}\nif(modobj===undefined){\nif($B.is_none(fromlist)){fromlist=[]}\nfor(var i=0,modsep=\"\",_mod_name=\"\",len=parsed_name.length-1,__path__=_b_.None;i <=len;++i){var _parent_name=_mod_name;\n_mod_name+=modsep+parsed_name[i]\nmodsep=\".\"\nvar modobj=$B.imported[_mod_name]\nif($test){console.log(\"iter\",i,_mod_name,\"modobj\",modobj,\"__path__\",__path__,Array.isArray(__path__))\nalert()}\nif(modobj==_b_.None){\nimport_error(_mod_name)}else if(modobj===undefined){try{import_engine(_mod_name,__path__,from_stdlib)}catch(err){delete $B.imported[_mod_name]\nthrow err}\nif($B.is_none($B.imported[_mod_name])){import_error(_mod_name)}else{\nif(_parent_name){_b_.setattr($B.imported[_parent_name],parsed_name[i],$B.imported[_mod_name])}}}else if($B.imported[_parent_name]&&\n$B.imported[_parent_name][parsed_name[i]]===undefined){\n_b_.setattr($B.imported[_parent_name],parsed_name[i],$B.imported[_mod_name])}\nif(i < len){try{__path__=$B.$getattr($B.imported[_mod_name],\"__path__\")}catch(e){\nif(i==len-1 &&\n$B.imported[_mod_name][parsed_name[len]]&&\n$B.imported[_mod_name][parsed_name[len]].__class__===\n$B.module){return $B.imported[_mod_name][parsed_name[len]]}\nif(has_from){\nimport_error(mod_name)}else{\nvar exc=_b_.ModuleNotFoundError.$factory()\nexc.msg=\"No module named '\"+mod_name+\"'; '\"+\n_mod_name+\"' is not a package\"\nexc.args=$B.fast_tuple([exc.msg])\nexc.name=mod_name\nexc.path=_b_.None\nthrow exc}}}}}else{if($B.imported[parsed_name[0]]&&\nparsed_name.length==2){try{if($B.imported[parsed_name[0]][parsed_name[1]]===undefined){$B.$setattr($B.imported[parsed_name[0]],parsed_name[1],modobj)}}catch(err){console.log(\"error\",parsed_name,modobj)\nthrow err}}}\nif(fromlist.length > 0){\nreturn $B.imported[mod_name]}else{\nreturn $B.imported[parsed_name[0]]}}\n$B.$import=function(mod_name,fromlist,aliases,locals){\nfromlist=fromlist===undefined ?[]:fromlist\naliases=aliases===undefined ?{}:aliases\nlocals=locals===undefined ?{}:locals\nvar parts=mod_name.split(\".\")\nif(mod_name[mod_name.length-1]==\".\"){parts.pop()}\nvar norm_parts=[],prefix=true\nfor(var i=0,len=parts.length;i < len;i++){var p=parts[i]\nif(prefix && p==\"\"){\nelt=norm_parts.pop()\nif(elt===undefined){throw _b_.ImportError.$factory(\"Parent module '' not loaded, \"+\n\"cannot perform relative import\")}}else{prefix=false;\nnorm_parts.push(p)}}\nvar mod_name=norm_parts.join(\".\")\nif($B.$options.debug==10){console.log(\"$import \"+mod_name)\nconsole.log(\"use VFS ? \"+$B.use_VFS)\nconsole.log(\"use static stdlib paths ? \"+$B.static_stdlib_import)}\nvar current_frame=$B.frames_stack[$B.frames_stack.length-1],_globals=current_frame[3],__import__=_globals[\"__import__\"],globals=$B.obj_dict(_globals)\nif(__import__===undefined){\n__import__=$B.$__import__}\nvar importer=typeof __import__==\"function\" ?\n__import__ :\n$B.$getattr(__import__,\"__call__\"),modobj=importer(mod_name,globals,undefined,fromlist,0)\nif(! fromlist ||fromlist.length==0){\nvar alias=aliases[mod_name]\nif(alias){locals[alias]=$B.imported[mod_name]}else{locals[norm_parts[0]]=modobj}}else{var __all__=fromlist,thunk={}\nif(fromlist && fromlist[0]==\"*\"){__all__=$B.$getattr(modobj,\"__all__\",thunk);\nif(__all__ !==thunk){\naliases={}}}\nif(__all__===thunk){\nfor(var attr in modobj){if(attr[0]!==\"_\"){locals[attr]=modobj[attr]}}}else{\nfor(var i=0,l=__all__.length;i < l;++i){var name=__all__[i]\nvar alias=aliases[name]||name\ntry{\nlocals[alias]=$B.$getattr(modobj,name)}catch($err1){\ntry{$B.$getattr(__import__,'__call__')(mod_name+'.'+name,globals,undefined,[],0)\nlocals[alias]=$B.$getattr(modobj,name)}catch($err3){\nif(mod_name===\"__future__\"){\nvar frame=$B.last($B.frames_stack),line_info=frame[3].$line_info,line_elts=line_info.split(','),line_num=parseInt(line_elts[0])\n$B.$SyntaxError(frame[2],\"future feature \"+name+\" is not defined\",current_frame[3].src,undefined,line_num)}\nif($err3.$py_error){throw $err3}\nif($B.debug > 1){console.log($err3)\nconsole.log($B.last($B.frames_stack))}\nthrow _b_.ImportError.$factory(\n\"cannot import name '\"+name+\"'\")}}}}\nreturn locals}}\n$B.import_all=function(locals,module){\nfor(var attr in module){if('_$'.indexOf(attr.charAt(0))==-1){locals[attr]=module[attr]}}}\n$B.$path_hooks=[url_hook]\n$B.$meta_path=[VFSFinder,StdlibStaticFinder,PathFinder]\n$B.finders={VFS:VFSFinder,stdlib_static:StdlibStaticFinder,path:PathFinder,CPython:finder_cpython}\nfunction optimize_import_for_path(path,filetype){if(path.slice(-1)!=\"/\"){path=path+\"/\" }\nvar value=(filetype=='none')? _b_.None :\nurl_hook(path,filetype)\n$B.path_importer_cache[path]=value}\nvar Loader={__class__:$B.$type,__mro__:[_b_.object],__name__ :\"Loader\"}\nvar _importlib_module={__class__ :Module,__name__ :\"_importlib\",Loader:Loader,VFSFinder:VFSFinder,StdlibStatic:StdlibStaticFinder,ImporterPath:PathFinder,UrlPathFinder:url_hook,optimize_import_for_path :optimize_import_for_path}\n_importlib_module.__repr__=_importlib_module.__str__=function(){return \"<module '_importlib' (built-in)>\"}\n$B.imported[\"_importlib\"]=_importlib_module})(__BRYTHON__)\n;\n\nvar $B=__BRYTHON__\n$B.unicode={\"Cc\":[[0,32],[127,33]],\"Zs\":[32,160,5760,[8192,11],8239,8287,12288],\"Po\":[[33,3],[37,3],[42,3,2],47,58,59,63,64,92,161,167,182,183,191,894,903,[1370,6],1417,[1472,3,3],1523,1524,1545,1546,1548,1549,1563,1566,1567,[1642,4],1748,[1792,14],[2039,3],[2096,15],2142,2404,2405,2416,2557,2678,2800,3191,3204,3572,3663,3674,3675,[3844,15],3860,3973,[4048,5],4057,4058,[4170,6],4347,[4960,9],5742,[5867,3],5941,5942,[6100,3],[6104,3],[6144,6],[6151,4],6468,6469,6686,6687,[6816,7],[6824,6],[7002,7],[7164,4],[7227,5],7294,7295,[7360,8],7379,8214,8215,[8224,8],[8240,9],[8251,4],[8257,3],[8263,11],8275,[8277,10],[11513,4],11518,11519,11632,11776,11777,[11782,3],11787,[11790,9],11800,11801,11803,11806,11807,[11818,5],[11824,10],[11836,4],11841,[11843,13],11858,[12289,3],12349,12539,42238,42239,[42509,3],42611,42622,[42738,6],[43124,4],43214,43215,[43256,3],43260,43310,43311,43359,[43457,13],43486,43487,[43612,4],43742,43743,43760,43761,44011,[65040,7],65049,65072,65093,65094,[65097,4],[65104,3],[65108,4],[65119,3],65128,65130,65131,[65281,3],[65285,3],[65290,3,2],65295,65306,65307,65311,65312,65340,65377,65380,65381,[65792,3],66463,66512,66927,67671,67871,67903,[68176,9],68223,[68336,7],[68409,7],[68505,4],[69461,5],[69703,7],69819,69820,[69822,4],[69952,4],70004,70005,[70085,4],70093,70107,[70109,3],[70200,6],70313,[70731,5],70746,70747,70749,70854,[71105,23],[71233,3],[71264,13],[71484,3],71739,[72004,3],72162,[72255,8],[72346,3],[72350,5],[72769,5],72816,72817,73463,73464,73727,[74864,5],92782,92783,92917,[92983,5],92996,[93847,4],94178,113823,[121479,5],125278,125279],\"Sc\":[36,[162,4],1423,1547,2046,2047,2546,2547,2555,2801,3065,3647,6107,[8352,32],43064,65020,65129,65284,65504,65505,65509,65510,[73693,4],123647,126128],\"Ps\":[40,91,123,3898,3900,5787,8218,8222,8261,8317,8333,8968,8970,9001,[10088,7,2],10181,[10214,5,2],[10627,11,2],10712,10714,10748,[11810,4,2],11842,[12296,5,2],[12308,4,2],12317,64831,65047,[65077,8,2],65095,[65113,3,2],65288,65339,65371,65375,65378],\"Pe\":[41,93,125,3899,3901,5788,8262,8318,8334,8969,8971,9002,[10089,7,2],10182,[10215,5,2],[10628,11,2],10713,10715,10749,[11811,4,2],[12297,5,2],[12309,4,2],12318,12319,64830,65048,[65078,8,2],65096,[65114,3,2],65289,65341,[65373,3,3]],\"Sm\":[43,[60,3],124,126,172,177,215,247,1014,[1542,3],8260,8274,[8314,3],[8330,3],8472,[8512,5],8523,[8592,5],8602,8603,[8608,3,3],8622,8654,8655,8658,8660,[8692,268],8992,8993,9084,[9115,25],[9180,6],9655,9665,[9720,8],9839,[10176,5],[10183,31],[10224,16],[10496,131],[10649,63],[10716,32],[10750,258],[11056,21],[11079,6],64297,65122,[65124,3],65291,[65308,3],65372,65374,65506,[65513,4],120513,120539,120571,120597,120629,120655,120687,120713,120745,120771,126704,126705],\"Pd\":[45,1418,1470,5120,6150,[8208,6],11799,11802,11834,11835,11840,12316,12336,12448,65073,65074,65112,65123,65293,69293],\"Nd\":[[48,10],[1632,10],[1776,10],[1984,10],[2406,10],[2534,10],[2662,10],[2790,10],[2918,10],[3046,10],[3174,10],[3302,10],[3430,10],[3558,10],[3664,10],[3792,10],[3872,10],[4160,10],[4240,10],[6112,10],[6160,10],[6470,10],[6608,10],[6784,10],[6800,10],[6992,10],[7088,10],[7232,10],[7248,10],[42528,10],[43216,10],[43264,10],[43472,10],[43504,10],[43600,10],[44016,10],[65296,10],[66720,10],[68912,10],[69734,10],[69872,10],[69942,10],[70096,10],[70384,10],[70736,10],[70864,10],[71248,10],[71360,10],[71472,10],[71904,10],[72016,10],[72784,10],[73040,10],[73120,10],[92768,10],[93008,10],[120782,50],[123200,10],[123632,10],[125264,10],[130032,10]],\"Lu\":[[65,26],[192,23],[216,7],[256,28,2],[313,8,2],[330,24,2],[377,3,2],385,[386,3,2],391,[393,3],[398,4],403,404,[406,3],412,413,415,[416,4,2],423,425,428,430,431,[433,3],437,439,440,444,[452,4,3],[463,7,2],[478,9,2],497,500,[502,3],[506,29,2],570,571,573,574,577,[579,4],[584,4,2],880,882,886,895,902,[904,3],908,910,911,[913,17],[931,9],975,[978,3],[984,12,2],1012,1015,1017,1018,[1021,51],[1120,17,2],[1162,28,2],[1217,7,2],[1232,48,2],[1329,38],[4256,38],4295,4301,[5024,86],[7312,43],[7357,3],[7680,75,2],[7838,49,2],[7944,8],[7960,6],[7976,8],[7992,8],[8008,6],[8025,4,2],[8040,8],[8120,4],[8136,4],[8152,4],[8168,5],[8184,4],8450,8455,[8459,3],[8464,3],8469,[8473,5],[8484,4,2],[8491,3],[8496,4],8510,8511,8517,8579,[11264,47],11360,[11362,3],[11367,4,2],[11374,3],11378,11381,[11390,3],[11394,49,2],11499,11501,11506,[42560,23,2],[42624,14,2],[42786,7,2],[42802,31,2],[42873,3,2],[42878,5,2],42891,42893,42896,42898,[42902,11,2],[42923,4],[42928,5],[42934,5,2],42946,[42948,4],42953,42997,[65313,26],[66560,40],[66736,36],[68736,51],[71840,32],[93760,32],[119808,26],[119860,26],[119912,26],119964,119966,[119967,3,3],119974,[119977,4],[119982,8],[120016,26],120068,120069,[120071,4],[120077,8],[120086,7],120120,120121,[120123,4],[120128,5],120134,[120138,7],[120172,26],[120224,26],[120276,26],[120328,26],[120380,26],[120432,26],[120488,25],[120546,25],[120604,25],[120662,25],[120720,25],120778,[125184,34]],\"Sk\":[94,96,168,175,180,184,[706,4],[722,14],[741,7],749,[751,17],885,900,901,8125,[8127,3],[8141,3],[8157,3],[8173,3],8189,8190,12443,12444,[42752,23],42784,42785,42889,42890,43867,43882,43883,[64434,16],65342,65344,65507,[127995,5]],\"Pc\":[95,8255,8256,8276,65075,65076,[65101,3],65343],\"Ll\":[[97,26],181,[223,24],[248,8],[257,28,2],[312,9,2],[329,24,2],[378,3,2],383,384,387,389,392,396,397,402,405,[409,3],414,[417,3,2],424,426,427,429,432,436,438,441,442,[445,3],[454,3,3],[462,8,2],[477,10,2],496,499,501,[505,30,2],[564,6],572,575,576,578,[583,5,2],[592,68],[661,27],881,[883,3,4],892,893,912,[940,35],976,977,[981,3],[985,12,2],[1008,4],[1013,3,3],1020,[1072,48],[1121,17,2],[1163,27,2],[1218,7,2],[1231,49,2],[1376,41],[4304,43],[4349,3],[5112,6],[7296,9],[7424,44],[7531,13],[7545,34],[7681,75,2],[7830,8],[7839,49,2],[7936,8],[7952,6],[7968,8],[7984,8],[8000,6],[8016,8],[8032,8],[8048,14],[8064,8],[8080,8],[8096,8],[8112,5],8118,8119,8126,[8130,3],8134,8135,[8144,4],8150,8151,[8160,8],[8178,3],8182,8183,8458,8462,8463,8467,[8495,3,5],8508,8509,[8518,4],8526,8580,[11312,47],11361,11365,[11366,4,2],11377,11379,11380,[11382,6],[11393,50,2],11492,11500,11502,11507,[11520,38],11559,11565,[42561,23,2],[42625,14,2],[42787,7,2],42800,[42801,33,2],[42866,7],42874,42876,[42879,5,2],42892,42894,42897,[42899,3],[42903,10,2],42927,[42933,6,2],42947,42952,42954,42998,43002,[43824,43],[43872,9],[43888,80],[64256,7],[64275,5],[65345,26],[66600,40],[66776,36],[68800,51],[71872,32],[93792,32],[119834,26],[119886,7],[119894,18],[119938,26],[119990,4],119995,[119997,7],[120005,11],[120042,26],[120094,26],[120146,26],[120198,26],[120250,26],[120302,26],[120354,26],[120406,26],[120458,28],[120514,25],[120540,6],[120572,25],[120598,6],[120630,25],[120656,6],[120688,25],[120714,6],[120746,25],[120772,6],120779,[125218,34]],\"So\":[166,169,174,176,1154,1421,1422,1550,1551,1758,1769,1789,1790,2038,2554,2928,[3059,6],3066,3199,3407,3449,[3841,3],3859,[3861,3],[3866,6],[3892,3,2],[4030,8],[4039,6],4046,4047,[4053,4],4254,4255,[5008,10],5741,6464,[6622,34],[7009,10],[7028,9],8448,8449,[8451,4],8456,8457,8468,8470,8471,[8478,6],[8485,3,2],8494,8506,8507,8522,8524,8525,8527,8586,8587,[8597,5],[8604,4],8609,8610,8612,8613,[8615,7],[8623,31],8656,[8657,3,2],[8662,30],[8960,8],[8972,20],[8994,7],[9003,81],[9085,30],[9140,40],[9186,69],[9280,11],[9372,78],[9472,183],[9656,9],[9666,54],[9728,111],[9840,248],[10132,44],[10240,256],[11008,48],11077,11078,[11085,39],[11126,32],[11159,105],[11493,6],11856,11857,[11904,26],[11931,89],[12032,214],[12272,12],12292,12306,12307,12320,12342,12343,12350,12351,12688,12689,[12694,10],[12736,36],[12800,31],[12842,30],12880,[12896,32],[12938,39],[12992,320],[19904,64],[42128,55],[43048,4],43062,43063,43065,[43639,3],65021,65508,65512,65517,65518,65532,65533,[65847,9],[65913,17],[65932,3],[65936,13],65952,[66000,45],67703,67704,68296,71487,[73685,8],[73697,17],[92988,4],92997,113820,[118784,246],[119040,39],[119081,60],[119146,3],119171,119172,[119180,30],[119214,59],[119296,66],119365,[119552,87],[120832,512],[121399,4],[121453,8],[121462,14],121477,121478,123215,126124,126254,[126976,44],[127024,100],[127136,15],[127153,15],[127169,15],[127185,37],[127245,161],[127462,29],[127504,44],[127552,9],127568,127569,[127584,6],[127744,251],[128000,728],[128736,13],[128752,13],[128768,116],[128896,89],[128992,12],[129024,12],[129040,56],[129104,10],[129120,40],[129168,30],129200,129201,[129280,121],[129402,82],[129485,135],[129632,14],[129648,5],[129656,3],[129664,7],[129680,25],[129712,7],[129728,3],[129744,7],[129792,147],[129940,55]],\"Lo\":[170,186,443,[448,4],660,[1488,27],[1519,4],[1568,32],[1601,10],1646,1647,[1649,99],1749,1774,1775,[1786,3],1791,1808,[1810,30],[1869,89],1969,[1994,33],[2048,22],[2112,25],[2144,11],[2208,21],[2230,18],[2308,54],2365,2384,[2392,10],[2418,15],[2437,8],2447,2448,[2451,22],[2474,7],2482,[2486,4],2493,2510,2524,2525,[2527,3],2544,2545,2556,[2565,6],2575,2576,[2579,22],[2602,7],2610,2611,2613,2614,2616,2617,[2649,4],2654,[2674,3],[2693,9],[2703,3],[2707,22],[2730,7],2738,2739,[2741,5],2749,2768,2784,2785,2809,[2821,8],2831,2832,[2835,22],[2858,7],2866,2867,[2869,5],2877,2908,2909,[2911,3],2929,2947,[2949,6],[2958,3],[2962,4],2969,[2970,3,2],2975,2979,2980,[2984,3],[2990,12],3024,[3077,8],[3086,3],[3090,23],[3114,16],3133,[3160,3],3168,3169,3200,[3205,8],[3214,3],[3218,23],[3242,10],[3253,5],3261,3294,3296,3297,3313,3314,[3332,9],[3342,3],[3346,41],3389,3406,[3412,3],[3423,3],[3450,6],[3461,18],[3482,24],[3507,9],3517,[3520,7],[3585,48],3634,3635,[3648,6],3713,[3714,3,2],[3719,4],[3724,24],3749,[3751,10],3762,3763,3773,[3776,5],[3804,4],3840,[3904,8],[3913,36],[3976,5],[4096,43],4159,[4176,6],[4186,4],4193,4197,4198,[4206,3],[4213,13],4238,[4352,329],[4682,4],[4688,7],4696,[4698,4],[4704,41],[4746,4],[4752,33],[4786,4],[4792,7],4800,[4802,4],[4808,15],[4824,57],[4882,4],[4888,67],[4992,16],[5121,620],[5743,17],[5761,26],[5792,75],[5873,8],[5888,13],[5902,4],[5920,18],[5952,18],[5984,13],[5998,3],[6016,52],6108,[6176,35],[6212,53],[6272,5],[6279,34],6314,[6320,70],[6400,31],[6480,30],[6512,5],[6528,44],[6576,26],[6656,23],[6688,53],[6917,47],[6981,7],[7043,30],7086,7087,[7098,44],[7168,36],[7245,3],[7258,30],[7401,4],[7406,6],7413,7414,7418,[8501,4],[11568,56],[11648,23],[11680,7],[11688,7],[11696,7],[11704,7],[11712,7],[11720,7],[11728,7],[11736,7],12294,12348,[12353,86],12447,[12449,90],12543,[12549,43],[12593,94],[12704,32],[12784,16],13312,19903,19968,40956,[40960,21],[40982,1143],[42192,40],[42240,268],[42512,16],42538,42539,42606,[42656,70],42895,42999,[43003,7],[43011,3],[43015,4],[43020,23],[43072,52],[43138,50],[43250,6],43259,43261,43262,[43274,28],[43312,23],[43360,29],[43396,47],[43488,5],[43495,9],[43514,5],[43520,41],[43584,3],[43588,8],[43616,16],[43633,6],43642,[43646,50],43697,43701,43702,[43705,5],43712,43714,43739,43740,[43744,11],43762,[43777,6],[43785,6],[43793,6],[43808,7],[43816,7],[43968,35],44032,55203,[55216,23],[55243,49],[63744,366],[64112,106],64285,[64287,10],[64298,13],[64312,5],64318,64320,64321,64323,64324,[64326,108],[64467,363],[64848,64],[64914,54],[65008,12],[65136,5],[65142,135],[65382,10],[65393,45],[65440,31],[65474,6],[65482,6],[65490,6],[65498,3],[65536,12],[65549,26],[65576,19],65596,65597,[65599,15],[65616,14],[65664,123],[66176,29],[66208,49],[66304,32],[66349,20],[66370,8],[66384,38],[66432,30],[66464,36],[66504,8],[66640,78],[66816,40],[66864,52],[67072,311],[67392,22],[67424,8],[67584,6],67592,[67594,44],67639,67640,67644,[67647,23],[67680,23],[67712,31],[67808,19],67828,67829,[67840,22],[67872,26],[67968,56],68030,68031,68096,[68112,4],[68117,3],[68121,29],[68192,29],[68224,29],[68288,8],[68297,28],[68352,54],[68416,22],[68448,19],[68480,18],[68608,73],[68864,36],[69248,42],69296,69297,[69376,29],69415,[69424,22],[69552,21],[69600,23],[69635,53],[69763,45],[69840,25],[69891,36],69956,69959,[69968,35],70006,[70019,48],[70081,4],70106,70108,[70144,18],[70163,25],[70272,7],70280,[70282,4],[70287,15],[70303,10],[70320,47],[70405,8],70415,70416,[70419,22],[70442,7],70450,70451,[70453,5],70461,70480,[70493,5],[70656,53],[70727,4],[70751,3],[70784,48],70852,70853,70855,[71040,47],[71128,4],[71168,48],71236,[71296,43],71352,[71424,27],[71680,44],[71935,8],71945,[71948,8],71957,71958,[71960,24],71999,72001,[72096,8],[72106,39],72161,72163,72192,[72203,40],72250,72272,[72284,46],72349,[72384,57],[72704,9],[72714,37],72768,[72818,30],[72960,7],72968,72969,[72971,38],73030,[73056,6],73063,73064,[73066,32],73112,[73440,19],73648,[73728,922],[74880,196],[77824,1071],[82944,583],[92160,569],[92736,31],[92880,30],[92928,48],[93027,21],[93053,19],[93952,75],94032,94208,100343,[100352,1238],101632,101640,[110592,287],[110928,3],[110948,4],[110960,396],[113664,107],[113776,13],[113792,9],[113808,10],[123136,45],123214,[123584,44],[124928,197],[126464,4],[126469,27],126497,126498,126500,126503,[126505,10],[126516,4],126521,126523,126530,[126535,4,2],126542,126543,126545,126546,126548,[126551,6,2],126562,126564,[126567,4],[126572,7],[126580,4],[126585,4],126590,[126592,10],[126603,17],[126625,3],[126629,5],[126635,17],131072,173789,173824,177972,177984,178205,178208,183969,183984,191456,[194560,542],196608,201546],\"Pi\":[171,8216,8219,8220,8223,8249,11778,11780,11785,11788,11804,11808],\"Cf\":[173,[1536,6],1564,1757,1807,2274,6158,[8203,5],[8234,5],[8288,5],[8294,10],65279,[65529,3],69821,69837,[78896,9],[113824,4],[119155,8],917505,[917536,96]],\"No\":[178,179,185,[188,3],[2548,6],[2930,6],[3056,3],[3192,7],[3416,7],[3440,9],[3882,10],[4969,20],[6128,10],6618,8304,[8308,6],[8320,10],[8528,16],8585,[9312,60],[9450,22],[10102,30],11517,[12690,4],[12832,10],[12872,8],[12881,15],[12928,10],[12977,15],[43056,6],[65799,45],[65909,4],65930,65931,[66273,27],[66336,4],[67672,8],[67705,7],[67751,9],[67835,5],[67862,6],68028,68029,[68032,16],[68050,46],[68160,9],68221,68222,[68253,3],[68331,5],[68440,8],[68472,8],[68521,7],[68858,6],[69216,31],[69405,10],[69457,4],[69573,7],[69714,20],[70113,20],71482,71483,[71914,9],[72794,19],[73664,21],[93019,7],[93824,23],[119520,20],[119648,25],[125127,9],[126065,59],[126125,3],[126129,4],[126209,45],[126255,15],[127232,13]],\"Pf\":[187,8217,8221,8250,11779,11781,11786,11789,11805,11809],\"Lt\":[[453,3,3],498,[8072,8],[8088,8],[8104,8],8124,8140,8188],\"Lm\":[[688,18],[710,12],[736,5],748,750,884,890,1369,1600,1765,1766,2036,2037,2042,2074,2084,2088,2417,3654,3782,4348,6103,6211,6823,[7288,6],[7468,63],7544,[7579,37],8305,8319,[8336,13],11388,11389,11631,11823,12293,[12337,5],12347,12445,12446,[12540,3],40981,[42232,6],42508,42623,42652,42653,[42775,9],42864,42888,43000,43001,43471,43494,43632,43741,43763,43764,[43868,4],43881,65392,65438,65439,[92992,4],[94099,13],94176,94177,94179,[123191,7],125259],\"Mn\":[[768,112],[1155,5],[1425,45],1471,1473,1474,1476,1477,1479,[1552,11],[1611,21],1648,[1750,7],[1759,6],1767,1768,[1770,4],1809,[1840,27],[1958,11],[2027,9],2045,[2070,4],[2075,9],[2085,3],[2089,5],[2137,3],[2259,15],[2275,32],2362,2364,[2369,8],2381,[2385,7],2402,2403,2433,2492,[2497,4],2509,2530,2531,2558,2561,2562,2620,2625,2626,2631,2632,[2635,3],2641,2672,2673,2677,2689,2690,2748,[2753,5],2759,2760,2765,2786,2787,[2810,6],2817,2876,2879,[2881,4],2893,2901,2902,2914,2915,2946,3008,3021,3072,3076,[3134,3],[3142,3],[3146,4],3157,3158,3170,3171,3201,3260,3263,3270,3276,3277,3298,3299,3328,3329,3387,3388,[3393,4],3405,3426,3427,3457,3530,[3538,3],3542,3633,[3636,7],[3655,8],3761,[3764,9],[3784,6],3864,3865,[3893,3,2],[3953,14],[3968,5],3974,3975,[3981,11],[3993,36],4038,[4141,4],[4146,6],4153,4154,4157,4158,4184,4185,[4190,3],[4209,4],4226,4229,4230,4237,4253,[4957,3],[5906,3],[5938,3],5970,5971,6002,6003,6068,6069,[6071,7],6086,[6089,11],6109,[6155,3],6277,6278,6313,[6432,3],6439,6440,6450,[6457,3],6679,6680,6683,6742,[6744,7],6752,6754,[6757,8],[6771,10],6783,[6832,14],6847,6848,[6912,4],6964,[6966,5],6972,6978,[7019,9],7040,7041,[7074,4],7080,7081,[7083,3],7142,7144,7145,7149,[7151,3],[7212,8],7222,7223,[7376,3],[7380,13],[7394,7],7405,7412,7416,7417,[7616,58],[7675,5],[8400,13],8417,[8421,12],[11503,3],11647,[11744,32],[12330,4],12441,12442,42607,[42612,10],42654,42655,42736,42737,43010,43014,43019,43045,43046,43052,43204,43205,[43232,18],43263,[43302,8],[43335,11],[43392,3],43443,[43446,4],43452,43453,43493,[43561,6],43569,43570,43573,43574,43587,43596,43644,43696,[43698,3],43703,43704,43710,43711,43713,43756,43757,43766,44005,44008,44013,64286,[65024,16],[65056,16],66045,66272,[66422,5],[68097,3],68101,68102,[68108,4],[68152,3],68159,68325,68326,[68900,4],69291,69292,[69446,11],69633,[69688,15],[69759,3],[69811,4],69817,69818,[69888,3],[69927,5],[69933,8],70003,70016,70017,[70070,9],[70089,4],70095,[70191,3],70196,70198,70199,70206,70367,[70371,8],70400,70401,70459,70460,70464,[70502,7],[70512,5],[70712,8],[70722,3],70726,70750,[70835,6],70842,70847,70848,70850,70851,[71090,4],71100,71101,71103,71104,71132,71133,[71219,8],71229,71231,71232,71339,71341,[71344,6],71351,[71453,3],[71458,4],[71463,5],[71727,9],71737,71738,71995,71996,71998,72003,[72148,4],72154,72155,72160,[72193,10],[72243,6],[72251,4],72263,[72273,6],[72281,3],[72330,13],72344,72345,[72752,7],[72760,6],72767,[72850,22],[72874,7],72882,72883,72885,72886,[73009,6],73018,73020,73021,[73023,7],73031,73104,73105,73109,73111,73459,73460,[92912,5],[92976,7],94031,[94095,4],94180,113821,113822,[119143,3],[119163,8],[119173,7],[119210,4],[119362,3],[121344,55],[121403,50],121461,121476,[121499,5],[121505,15],[122880,7],[122888,17],[122907,7],122915,122916,[122918,5],[123184,7],[123628,4],[125136,7],[125252,7],[917760,240]],\"Me\":[1160,1161,6846,[8413,4],[8418,3],[42608,3]],\"Mc\":[2307,2363,[2366,3],[2377,4],2382,2383,2434,2435,[2494,3],2503,2504,2507,2508,2519,2563,[2622,3],2691,[2750,3],2761,2763,2764,2818,2819,2878,2880,2887,2888,2891,2892,2903,3006,3007,3009,3010,[3014,3],[3018,3],3031,[3073,3],[3137,4],3202,3203,3262,[3264,5],3271,3272,3274,3275,3285,3286,3330,3331,[3390,3],[3398,3],[3402,3],3415,3458,3459,[3535,3],[3544,8],3570,3571,3902,3903,3967,4139,4140,4145,4152,4155,4156,4182,4183,[4194,3],[4199,7],4227,4228,[4231,6],4239,[4250,3],6070,[6078,8],6087,6088,[6435,4],[6441,3],6448,6449,[6451,6],6681,6682,6741,6743,6753,6755,6756,[6765,6],6916,6965,6971,[6973,5],6979,6980,7042,7073,7078,7079,7082,7143,[7146,3],7150,7154,7155,[7204,8],7220,7221,7393,7415,12334,12335,43043,43044,43047,43136,43137,[43188,16],43346,43347,43395,43444,43445,43450,43451,[43454,3],43567,43568,43571,43572,43597,43643,43645,43755,43758,43759,43765,44003,44004,44006,44007,44009,44010,44012,69632,69634,69762,[69808,3],69815,69816,69932,69957,69958,70018,[70067,3],70079,70080,70094,[70188,3],70194,70195,70197,[70368,3],70402,70403,70462,70463,[70465,4],70471,70472,[70475,3],70487,70498,70499,[70709,3],70720,70721,70725,[70832,3],70841,[70843,4],70849,[71087,3],[71096,4],71102,[71216,3],71227,71228,71230,71340,71342,71343,71350,71456,71457,71462,[71724,3],71736,[71984,6],71991,71992,71997,72000,72002,[72145,3],[72156,4],72164,72249,72279,72280,72343,72751,72766,72873,72881,72884,[73098,5],73107,73108,73110,73461,73462,[94033,55],94192,94193,119141,119142,[119149,6]],\"Nl\":[[5870,3],[8544,35],[8581,4],12295,[12321,9],[12344,3],[42726,10],[65856,53],66369,66378,[66513,5],[74752,111]],\"Zl\":[8232],\"Zp\":[8233],\"Cs\":[55296,56191,56192,56319,56320,57343],\"Co\":[57344,63743,983040,1048573,1048576,1114109],\"digits\":[[48,10],178,179,185,[1632,10],[1776,10],[1984,10],[2406,10],[2534,10],[2662,10],[2790,10],[2918,10],[3046,10],[3174,10],[3302,10],[3430,10],[3558,10],[3664,10],[3792,10],[3872,10],[4160,10],[4240,10],[4969,9],[6112,10],[6160,10],[6470,10],[6608,11],[6784,10],[6800,10],[6992,10],[7088,10],[7232,10],[7248,10],8304,[8308,6],[8320,10],[9312,9],[9332,9],[9352,9],9450,[9461,9],9471,[10102,9],[10112,9],[10122,9],[42528,10],[43216,10],[43264,10],[43472,10],[43504,10],[43600,10],[44016,10],[65296,10],[66720,10],[68160,4],[68912,10],[69216,9],[69714,9],[69734,10],[69872,10],[69942,10],[70096,10],[70384,10],[70736,10],[70864,10],[71248,10],[71360,10],[71472,10],[71904,10],[72016,10],[72784,10],[73040,10],[73120,10],[92768,10],[93008,10],[120782,50],[123200,10],[123632,10],[125264,10],[127232,11],[130032,10]],\"numeric\":[[48,10],178,179,185,[188,3],[1632,10],[1776,10],[1984,10],[2406,10],[2534,10],[2548,6],[2662,10],[2790,10],[2918,10],[2930,6],[3046,13],[3174,10],[3192,7],[3302,10],[3416,7],[3430,19],[3558,10],[3664,10],[3792,10],[3872,20],[4160,10],[4240,10],[4969,20],[5870,3],[6112,10],[6128,10],[6160,10],[6470,10],[6608,11],[6784,10],[6800,10],[6992,10],[7088,10],[7232,10],[7248,10],8304,[8308,6],[8320,10],[8528,51],[8581,5],[9312,60],[9450,22],[10102,30],11517,12295,[12321,9],[12344,3],[12690,4],[12832,10],[12872,8],[12881,15],[12928,10],[12977,15],13317,13443,14378,15181,19968,19971,19975,19977,20061,20108,20116,20118,20159,20160,20191,20200,20237,20336,20740,20806,[20841,3,2],21313,[21315,3],21324,[21441,4],22235,22769,22777,24186,24318,24319,[24332,3],24336,25342,25420,26578,28422,29590,30334,32902,33836,36014,36019,36144,38433,38470,38476,38520,38646,[42528,10],[42726,10],[43056,6],[43216,10],[43264,10],[43472,10],[43504,10],[43600,10],[44016,10],63851,63859,63864,63922,63953,63955,63997,[65296,10],[65799,45],[65856,57],65930,65931,[66273,27],[66336,4],66369,66378,[66513,5],[66720,10],[67672,8],[67705,7],[67751,9],[67835,5],[67862,6],68028,68029,[68032,16],[68050,46],[68160,9],68221,68222,[68253,3],[68331,5],[68440,8],[68472,8],[68521,7],[68858,6],[68912,10],[69216,31],[69405,10],[69457,4],[69573,7],[69714,30],[69872,10],[69942,10],[70096,10],[70113,20],[70384,10],[70736,10],[70864,10],[71248,10],[71360,10],[71472,12],[71904,19],[72016,10],[72784,29],[73040,10],[73120,10],[73664,21],[74752,111],[92768,10],[93008,10],[93019,7],[93824,23],[119520,20],[119648,25],[120782,50],[123200,10],[123632,10],[125127,9],[125264,10],[126065,59],[126125,3],[126129,4],[126209,45],[126255,15],[127232,13],[130032,10],131073,131172,131298,131361,133418,133507,133516,133532,133866,133885,133913,140176,141720,146203,156269,194704],\"Cn\":[[888,2],[896,4],[907,1],[909,1],[930,1],[1328,1],[1367,2],[1419,2],[1424,1],[1480,8],[1515,4],[1525,11],[1565,1],[1806,1],[1867,2],[1970,14],[2043,2],[2094,2],[2111,1],[2140,2],[2143,1],[2155,53],[2229,1],[2248,11],[2436,1],[2445,2],[2449,2],[2473,1],[2481,1],[2483,3],[2490,2],[2501,2],[2505,2],[2511,8],[2520,4],[2526,1],[2532,2],[2559,2],[2564,1],[2571,4],[2577,2],[2601,1],[2609,1],[2612,1],[2615,1],[2618,2],[2621,1],[2627,4],[2633,2],[2638,3],[2642,7],[2653,1],[2655,7],[2679,10],[2692,1],[2702,1],[2706,1],[2729,1],[2737,1],[2740,1],[2746,2],[2758,1],[2762,1],[2766,2],[2769,15],[2788,2],[2802,7],[2816,1],[2820,1],[2829,2],[2833,2],[2857,1],[2865,1],[2868,1],[2874,2],[2885,2],[2889,2],[2894,7],[2904,4],[2910,1],[2916,2],[2936,10],[2948,1],[2955,3],[2961,1],[2966,3],[2971,1],[2973,1],[2976,3],[2981,3],[2987,3],[3002,4],[3011,3],[3017,1],[3022,2],[3025,6],[3032,14],[3067,5],[3085,1],[3089,1],[3113,1],[3130,3],[3141,1],[3145,1],[3150,7],[3159,1],[3163,5],[3172,2],[3184,7],[3213,1],[3217,1],[3241,1],[3252,1],[3258,2],[3269,1],[3273,1],[3278,7],[3287,7],[3295,1],[3300,2],[3312,1],[3315,13],[3341,1],[3345,1],[3397,1],[3401,1],[3408,4],[3428,2],[3456,1],[3460,1],[3479,3],[3506,1],[3516,1],[3518,2],[3527,3],[3531,4],[3541,1],[3543,1],[3552,6],[3568,2],[3573,12],[3643,4],[3676,37],[3715,1],[3717,1],[3723,1],[3748,1],[3750,1],[3774,2],[3781,1],[3783,1],[3790,2],[3802,2],[3808,32],[3912,1],[3949,4],[3992,1],[4029,1],[4045,1],[4059,37],[4294,1],[4296,5],[4302,2],[4681,1],[4686,2],[4695,1],[4697,1],[4702,2],[4745,1],[4750,2],[4785,1],[4790,2],[4799,1],[4801,1],[4806,2],[4823,1],[4881,1],[4886,2],[4955,2],[4989,3],[5018,6],[5110,2],[5118,2],[5789,3],[5881,7],[5901,1],[5909,11],[5943,9],[5972,12],[5997,1],[6001,1],[6004,12],[6110,2],[6122,6],[6138,6],[6159,1],[6170,6],[6265,7],[6315,5],[6390,10],[6431,1],[6444,4],[6460,4],[6465,3],[6510,2],[6517,11],[6572,4],[6602,6],[6619,3],[6684,2],[6751,1],[6781,2],[6794,6],[6810,6],[6830,2],[6849,63],[6988,4],[7037,3],[7156,8],[7224,3],[7242,3],[7305,7],[7355,2],[7368,8],[7419,5],[7674,1],[7958,2],[7966,2],[8006,2],[8014,2],[8024,1],[8026,1],[8028,1],[8030,1],[8062,2],[8117,1],[8133,1],[8148,2],[8156,1],[8176,2],[8181,1],[8191,1],[8293,1],[8306,2],[8335,1],[8349,3],[8384,16],[8433,15],[8588,4],[9255,25],[9291,21],[11124,2],[11158,1],[11311,1],[11359,1],[11508,5],[11558,1],[11560,5],[11566,2],[11624,7],[11633,14],[11671,9],[11687,1],[11695,1],[11703,1],[11711,1],[11719,1],[11727,1],[11735,1],[11743,1],[11859,45],[11930,1],[12020,12],[12246,26],[12284,4],[12352,1],[12439,2],[12544,5],[12592,1],[12687,1],[12772,12],[12831,1],[40957,3],[42125,3],[42183,9],[42540,20],[42744,8],[42944,2],[42955,42],[43053,3],[43066,6],[43128,8],[43206,8],[43226,6],[43348,11],[43389,3],[43470,1],[43482,4],[43519,1],[43575,9],[43598,2],[43610,2],[43715,24],[43767,10],[43783,2],[43791,2],[43799,9],[43815,1],[43823,1],[43884,4],[44014,2],[44026,6],[55204,12],[55239,4],[55292,4],[64110,2],[64218,38],[64263,12],[64280,5],[64311,1],[64317,1],[64319,1],[64322,1],[64325,1],[64450,17],[64832,16],[64912,2],[64968,40],[65022,2],[65050,6],[65107,1],[65127,1],[65132,4],[65141,1],[65277,2],[65280,1],[65471,3],[65480,2],[65488,2],[65496,2],[65501,3],[65511,1],[65519,10],[65534,2],[65548,1],[65575,1],[65595,1],[65598,1],[65614,2],[65630,34],[65787,5],[65795,4],[65844,3],[65935,1],[65949,3],[65953,47],[66046,130],[66205,3],[66257,15],[66300,4],[66340,9],[66379,5],[66427,5],[66462,1],[66500,4],[66518,42],[66718,2],[66730,6],[66772,4],[66812,4],[66856,8],[66916,11],[66928,144],[67383,9],[67414,10],[67432,152],[67590,2],[67593,1],[67638,1],[67641,3],[67645,2],[67670,1],[67743,8],[67760,48],[67827,1],[67830,5],[67868,3],[67898,5],[67904,64],[68024,4],[68048,2],[68100,1],[68103,5],[68116,1],[68120,1],[68150,2],[68155,4],[68169,7],[68185,7],[68256,32],[68327,4],[68343,9],[68406,3],[68438,2],[68467,5],[68498,7],[68509,12],[68528,80],[68681,55],[68787,13],[68851,7],[68904,8],[68922,294],[69247,1],[69290,1],[69294,2],[69298,78],[69416,8],[69466,86],[69580,20],[69623,9],[69710,4],[69744,15],[69826,11],[69838,2],[69865,7],[69882,6],[69941,1],[69960,8],[70007,9],[70112,1],[70133,11],[70162,1],[70207,65],[70279,1],[70281,1],[70286,1],[70302,1],[70314,6],[70379,5],[70394,6],[70404,1],[70413,2],[70417,2],[70441,1],[70449,1],[70452,1],[70458,1],[70469,2],[70473,2],[70478,2],[70481,6],[70488,5],[70500,2],[70509,3],[70517,139],[70748,1],[70754,30],[70856,8],[70874,166],[71094,2],[71134,34],[71237,11],[71258,6],[71277,19],[71353,7],[71370,54],[71451,2],[71468,4],[71488,192],[71740,100],[71923,12],[71943,2],[71946,2],[71956,1],[71959,1],[71990,1],[71993,2],[72007,9],[72026,70],[72104,2],[72152,2],[72165,27],[72264,8],[72355,29],[72441,263],[72713,1],[72759,1],[72774,10],[72813,3],[72848,2],[72872,1],[72887,73],[72967,1],[72970,1],[73015,3],[73019,1],[73022,1],[73032,8],[73050,6],[73062,1],[73065,1],[73103,1],[73106,1],[73113,7],[73130,310],[73465,183],[73649,15],[73714,13],[74650,102],[74863,1],[74869,11],[75076,2748],[78895,1],[78905,4039],[83527,8633],[92729,7],[92767,1],[92778,4],[92784,96],[92910,2],[92918,10],[92998,10],[93018,1],[93026,1],[93048,5],[93072,688],[93851,101],[94027,4],[94088,7],[94112,64],[94181,11],[94194,14],[100344,8],[101590,42],[101641,8951],[110879,49],[110931,17],[110952,8],[111356,2308],[113771,5],[113789,3],[113801,7],[113818,2],[113828,4956],[119030,10],[119079,2],[119273,23],[119366,154],[119540,12],[119639,9],[119673,135],[119893,1],[119965,1],[119968,2],[119971,2],[119975,2],[119981,1],[119994,1],[119996,1],[120004,1],[120070,1],[120075,2],[120085,1],[120093,1],[120122,1],[120127,1],[120133,1],[120135,3],[120145,1],[120486,2],[120780,2],[121484,15],[121504,1],[121520,1360],[122887,1],[122905,2],[122914,1],[122917,1],[122923,213],[123181,3],[123198,2],[123210,4],[123216,368],[123642,5],[123648,1280],[125125,2],[125143,41],[125260,4],[125274,4],[125280,785],[126133,76],[126270,194],[126468,1],[126496,1],[126499,1],[126501,2],[126504,1],[126515,1],[126520,1],[126522,1],[126524,6],[126531,4],[126536,1],[126538,1],[126540,1],[126544,1],[126547,1],[126549,2],[126552,1],[126554,1],[126556,1],[126558,1],[126560,1],[126563,1],[126565,2],[126571,1],[126579,1],[126584,1],[126589,1],[126591,1],[126602,1],[126620,5],[126628,1],[126634,1],[126652,52],[126706,270],[127020,4],[127124,12],[127151,2],[127168,1],[127184,1],[127222,10],[127406,56],[127491,13],[127548,4],[127561,7],[127570,14],[127590,154],[128728,8],[128749,3],[128765,3],[128884,12],[128985,7],[129004,20],[129036,4],[129096,8],[129114,6],[129160,8],[129198,2],[129202,78],[129401,1],[129484,1],[129620,12],[129646,2],[129653,3],[129659,5],[129671,9],[129705,7],[129719,9],[129731,13],[129751,41],[129939,1],[129995,37],[130042,1030],[173790,34],[177973,11],[178206,2],[183970,14],[191457,3103],[195102,1506],[201547,715958],[917506,30],[917632,128],[918000,65040],[1048574,2]]}\n$B.unicode_casefold={223:[115,115],304:[105,775],329:[700,110],496:[106,780],912:[953,776,769],944:[965,776,769],1415:[1381,1410],7830:[104,817],7831:[116,776],7832:[119,778],7833:[121,778],7834:[97,702],7838:[223],8016:[965,787],8018:[965,787,768],8020:[965,787,769],8022:[965,787,834],8064:[7936,953],8065:[7937,953],8066:[7938,953],8067:[7939,953],8068:[7940,953],8069:[7941,953],8070:[7942,953],8071:[7943,953],8072:[8064],8073:[8065],8074:[8066],8075:[8067],8076:[8068],8077:[8069],8078:[8070],8079:[8071],8080:[7968,953],8081:[7969,953],8082:[7970,953],8083:[7971,953],8084:[7972,953],8085:[7973,953],8086:[7974,953],8087:[7975,953],8088:[8080],8089:[8081],8090:[8082],8091:[8083],8092:[8084],8093:[8085],8094:[8086],8095:[8087],8096:[8032,953],8097:[8033,953],8098:[8034,953],8099:[8035,953],8100:[8036,953],8101:[8037,953],8102:[8038,953],8103:[8039,953],8104:[8096],8105:[8097],8106:[8098],8107:[8099],8108:[8100],8109:[8101],8110:[8102],8111:[8103],8114:[8048,953],8115:[945,953],8116:[940,953],8118:[945,834],8119:[945,834,953],8124:[8115],8130:[8052,953],8131:[951,953],8132:[942,953],8134:[951,834],8135:[951,834,953],8140:[8131],8146:[953,776,768],8147:[953,776,769],8150:[953,834],8151:[953,776,834],8162:[965,776,768],8163:[965,776,769],8164:[961,787],8166:[965,834],8167:[965,776,834],8178:[8060,953],8179:[969,953],8180:[974,953],8182:[969,834],8183:[969,834,953],8188:[8179],64256:[102,102],64257:[102,105],64258:[102,108],64259:[102,102,105],64260:[102,102,108],64261:[115,116],64262:[115,116],64275:[1396,1398],64276:[1396,1381],64277:[1396,1387],64278:[1406,1398],64279:[1396,1389]}\n$B.unicode_bidi_whitespace=[9,10,11,12,13,28,29,30,31,32,133,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8287,12288]\n$B.unicode_identifiers={\"XID_Start\":[95,[65,26],[97,26],170,181,186,[192,23],[216,31],[248,458],[710,12],[736,5],748,750,[880,5],[886,2],[891,3],895,902,[904,3],908,[910,20],[931,83],[1015,139],[1162,166],[1329,38],1369,[1376,41],[1488,27],[1519,4],[1568,43],[1646,2],[1649,99],1749,[1765,2],[1774,2],[1786,3],1791,1808,[1810,30],[1869,89],1969,[1994,33],[2036,2],2042,[2048,22],2074,2084,2088,[2112,25],[2144,11],[2208,21],[2230,18],[2308,54],2365,2384,[2392,10],2417,[2418,15],[2437,8],[2447,2],[2451,22],[2474,7],2482,[2486,4],2493,2510,[2524,2],[2527,3],[2544,2],2556,[2565,6],[2575,2],[2579,22],[2602,7],[2610,2],[2613,2],[2616,2],[2649,4],2654,[2674,3],[2693,9],[2703,3],[2707,22],[2730,7],[2738,2],[2741,5],2749,2768,[2784,2],2809,[2821,8],[2831,2],[2835,22],[2858,7],[2866,2],[2869,5],2877,[2908,2],[2911,3],2929,2947,[2949,6],[2958,3],[2962,4],[2969,2],2972,[2974,2],[2979,2],[2984,3],[2990,12],3024,[3077,8],[3086,3],[3090,23],[3114,16],3133,[3160,3],[3168,2],3200,[3205,8],[3214,3],[3218,23],[3242,10],[3253,5],3261,3294,[3296,2],[3313,2],[3332,9],[3342,3],[3346,41],3389,3406,[3412,3],[3423,3],[3450,6],[3461,18],[3482,24],[3507,9],3517,[3520,7],[3585,48],3634,[3648,7],[3713,2],3716,[3718,5],[3724,24],3749,[3751,10],3762,3773,[3776,5],3782,[3804,4],3840,[3904,8],[3913,36],[3976,5],[4096,43],4159,[4176,6],[4186,4],4193,[4197,2],[4206,3],[4213,13],4238,[4256,38],4295,4301,[4304,43],4348,[4349,332],[4682,4],[4688,7],4696,[4698,4],[4704,41],[4746,4],[4752,33],[4786,4],[4792,7],4800,[4802,4],[4808,15],[4824,57],[4882,4],[4888,67],[4992,16],[5024,86],[5112,6],[5121,620],[5743,17],[5761,26],[5792,75],[5870,11],[5888,13],[5902,4],[5920,18],[5952,18],[5984,13],[5998,3],[6016,52],6103,6108,[6176,89],[6272,41],6314,[6320,70],[6400,31],[6480,30],[6512,5],[6528,44],[6576,26],[6656,23],[6688,53],6823,[6917,47],[6981,7],[7043,30],[7086,2],[7098,44],[7168,36],[7245,3],[7258,36],[7296,9],[7312,43],[7357,3],[7401,4],[7406,6],[7413,2],7418,[7424,192],[7680,278],[7960,6],[7968,38],[8008,6],[8016,8],8025,8027,8029,[8031,31],[8064,53],[8118,7],8126,[8130,3],[8134,7],[8144,4],[8150,6],[8160,13],[8178,3],[8182,7],8305,8319,[8336,13],8450,8455,[8458,10],8469,8472,[8473,5],8484,8486,8488,[8490,16],[8508,4],[8517,5],8526,[8544,41],[11264,47],[11312,47],[11360,133],[11499,4],[11506,2],[11520,38],11559,11565,[11568,56],11631,[11648,23],[11680,7],[11688,7],[11696,7],[11704,7],[11712,7],[11720,7],[11728,7],[11736,7],12293,12294,12295,[12321,9],[12337,5],[12344,5],[12353,86],[12445,3],[12449,90],[12540,4],[12549,43],[12593,94],[12704,32],[12784,16],[13312,6592],[19968,20989],[40960,1165],[42192,46],[42240,269],[42512,16],[42538,2],[42560,47],42623,[42624,30],[42656,80],[42775,9],[42786,103],[42891,53],[42946,9],[42997,13],[43011,3],[43015,4],[43020,23],[43072,52],[43138,50],[43250,6],43259,[43261,2],[43274,28],[43312,23],[43360,29],[43396,47],43471,[43488,5],43494,[43495,9],[43514,5],[43520,41],[43584,3],[43588,8],[43616,23],43642,[43646,50],43697,[43701,2],[43705,5],43712,43714,[43739,3],[43744,11],43762,[43763,2],[43777,6],[43785,6],[43793,6],[43808,7],[43816,7],[43824,43],[43868,14],[43888,115],[44032,11172],[55216,23],[55243,49],[63744,366],[64112,106],[64256,7],[64275,5],64285,[64287,10],[64298,13],[64312,5],64318,[64320,2],[64323,2],[64326,108],[64467,139],[64612,218],[64848,64],[64914,54],[65008,10],65137,65139,65143,65145,65147,65149,[65151,126],[65313,26],[65345,26],[65382,56],[65440,31],[65474,6],[65482,6],[65490,6],[65498,3],[65536,12],[65549,26],[65576,19],[65596,2],[65599,15],[65616,14],[65664,123],[65856,53],[66176,29],[66208,49],[66304,32],[66349,30],[66384,38],[66432,30],[66464,36],[66504,8],[66513,5],[66560,158],[66736,36],[66776,36],[66816,40],[66864,52],[67072,311],[67392,22],[67424,8],[67584,6],67592,[67594,44],[67639,2],67644,[67647,23],[67680,23],[67712,31],[67808,19],[67828,2],[67840,22],[67872,26],[67968,56],[68030,2],68096,[68112,4],[68117,3],[68121,29],[68192,29],[68224,29],[68288,8],[68297,28],[68352,54],[68416,22],[68448,19],[68480,18],[68608,73],[68736,51],[68800,51],[68864,36],[69248,42],[69296,2],[69376,29],69415,[69424,22],[69552,21],[69600,23],[69635,53],[69763,45],[69840,25],[69891,36],69956,69959,[69968,35],70006,[70019,48],[70081,4],70106,70108,[70144,18],[70163,25],[70272,7],70280,[70282,4],[70287,15],[70303,10],[70320,47],[70405,8],[70415,2],[70419,22],[70442,7],[70450,2],[70453,5],70461,70480,[70493,5],[70656,53],[70727,4],[70751,3],[70784,48],[70852,2],70855,[71040,47],[71128,4],[71168,48],71236,[71296,43],71352,[71424,27],[71680,44],[71840,64],[71935,8],71945,[71948,8],[71957,2],[71960,24],71999,72001,[72096,8],[72106,39],72161,72163,72192,[72203,40],72250,72272,[72284,46],72349,[72384,57],[72704,9],[72714,37],72768,[72818,30],[72960,7],[72968,2],[72971,38],73030,[73056,6],[73063,2],[73066,32],73112,[73440,19],73648,[73728,922],[74752,111],[74880,196],[77824,1071],[82944,583],[92160,569],[92736,31],[92880,30],[92928,48],[92992,4],[93027,21],[93053,19],[93760,64],[93952,75],94032,[94099,13],[94176,2],94179,[94208,6136],[100352,1238],[101632,9],[110592,287],[110928,3],[110948,4],[110960,396],[113664,107],[113776,13],[113792,9],[113808,10],[119808,85],[119894,71],[119966,2],119970,[119973,2],[119977,4],[119982,12],119995,[119997,7],[120005,65],[120071,4],[120077,8],[120086,7],[120094,28],[120123,4],[120128,5],120134,[120138,7],[120146,340],[120488,25],[120514,25],[120540,31],[120572,25],[120598,31],[120630,25],[120656,31],[120688,25],[120714,31],[120746,25],[120772,8],[123136,45],[123191,7],123214,[123584,44],[124928,197],[125184,68],125259,[126464,4],[126469,27],[126497,2],126500,126503,[126505,10],[126516,4],126521,126523,126530,126535,126537,126539,[126541,3],[126545,2],126548,126551,126553,126555,126557,126559,[126561,2],126564,[126567,4],[126572,7],[126580,4],[126585,4],126590,[126592,10],[126603,17],[126625,3],[126629,5],[126635,17],[131072,42718],[173824,4149],[177984,222],[178208,5762],[183984,7473],[194560,542],[196608,4939]],\"XID_Continue\":[[48,10],[65,26],95,[97,26],170,181,183,186,[192,23],[216,31],[248,458],[710,12],[736,5],748,750,[768,117],[886,2],[891,3],895,902,903,[904,3],908,[910,20],[931,83],[1015,139],[1155,5],[1162,166],[1329,38],1369,[1376,41],[1425,45],1471,[1473,2],[1476,2],1479,[1488,27],[1519,4],[1552,11],[1568,74],[1646,102],1749,[1750,7],[1759,10],[1770,19],1791,1808,1809,[1810,57],[1869,101],[1984,54],2042,2045,[2048,46],[2112,28],[2144,11],[2208,21],[2230,18],[2259,15],[2275,129],[2406,10],2417,[2418,18],[2437,8],[2447,2],[2451,22],[2474,7],2482,[2486,4],2492,2493,[2494,7],[2503,2],[2507,4],2519,[2524,2],[2527,5],[2534,12],2556,2558,[2561,3],[2565,6],[2575,2],[2579,22],[2602,7],[2610,2],[2613,2],[2616,2],2620,[2622,5],[2631,2],[2635,3],2641,[2649,4],2654,[2662,16],[2689,3],[2693,9],[2703,3],[2707,22],[2730,7],[2738,2],[2741,5],2748,2749,[2750,8],[2759,3],[2763,3],2768,[2784,4],[2790,10],2809,[2810,6],2817,[2818,2],[2821,8],[2831,2],[2835,22],[2858,7],[2866,2],[2869,5],2876,2877,2878,2879,2880,[2881,4],[2887,2],[2891,3],[2901,3],[2908,2],[2911,5],[2918,10],2929,2946,2947,[2949,6],[2958,3],[2962,4],[2969,2],2972,[2974,2],[2979,2],[2984,3],[2990,12],[3006,5],[3014,3],[3018,4],3024,3031,[3046,10],3072,[3073,12],[3086,3],[3090,23],[3114,16],3133,[3134,7],[3142,3],[3146,4],[3157,2],[3160,3],[3168,4],[3174,10],3200,3201,[3202,2],[3205,8],[3214,3],[3218,23],[3242,10],[3253,5],3260,3261,3262,3263,[3264,5],3270,[3271,2],[3274,4],[3285,2],3294,[3296,4],[3302,10],[3313,2],[3328,13],[3342,3],[3346,51],[3398,3],[3402,5],[3412,4],[3423,5],[3430,10],[3450,6],3457,[3458,2],[3461,18],[3482,24],[3507,9],3517,[3520,7],3530,[3535,6],3542,[3544,8],[3558,10],[3570,2],[3585,58],[3648,15],[3664,10],[3713,2],3716,[3718,5],[3724,24],3749,[3751,23],[3776,5],3782,[3784,6],[3792,10],[3804,4],3840,[3864,2],[3872,10],3893,3895,3897,[3902,10],[3913,36],[3953,20],[3974,18],[3993,36],4038,[4096,74],[4176,78],[4256,38],4295,4301,[4304,43],4348,[4349,332],[4682,4],[4688,7],4696,[4698,4],[4704,41],[4746,4],[4752,33],[4786,4],[4792,7],4800,[4802,4],[4808,15],[4824,57],[4882,4],[4888,67],[4957,3],[4969,9],[4992,16],[5024,86],[5112,6],[5121,620],[5743,17],[5761,26],[5792,75],[5870,11],[5888,13],[5902,7],[5920,21],[5952,20],[5984,13],[5998,3],[6002,2],[6016,84],6103,6108,6109,[6112,10],[6155,3],[6160,10],[6176,89],[6272,43],[6320,70],[6400,31],[6432,12],[6448,12],[6470,40],[6512,5],[6528,44],[6576,26],[6608,11],[6656,28],[6688,63],6752,6753,6754,[6755,26],6783,[6784,10],[6800,10],6823,[6832,14],[6847,2],[6912,76],[6992,10],[7019,9],[7040,116],[7168,56],[7232,10],[7245,49],[7296,9],[7312,43],[7357,3],[7376,3],[7380,39],[7424,250],[7675,283],[7960,6],[7968,38],[8008,6],[8016,8],8025,8027,8029,[8031,31],[8064,53],[8118,7],8126,[8130,3],[8134,7],[8144,4],[8150,6],[8160,13],[8178,3],[8182,7],[8255,2],8276,8305,8319,[8336,13],[8400,13],8417,[8421,12],8450,8455,[8458,10],8469,8472,[8473,5],8484,8486,8488,[8490,16],[8508,4],[8517,5],8526,[8544,41],[11264,47],[11312,47],[11360,133],[11499,9],[11520,38],11559,11565,[11568,56],11631,11647,[11648,23],[11680,7],[11688,7],[11696,7],[11704,7],[11712,7],[11720,7],[11728,7],[11736,7],[11744,32],12293,12294,12295,[12321,15],[12337,5],[12344,5],[12353,86],[12441,2],[12445,3],[12449,90],[12540,4],[12549,43],[12593,94],[12704,32],[12784,16],[13312,6592],[19968,20989],[40960,1165],[42192,46],[42240,269],[42512,28],[42560,48],[42612,10],42623,[42624,114],[42775,9],[42786,103],[42891,53],[42946,9],[42997,51],43052,[43072,52],[43136,70],[43216,10],[43232,24],43259,[43261,49],[43312,36],[43360,29],[43392,65],43471,[43472,10],[43488,31],[43520,55],[43584,14],[43600,10],[43616,23],43642,43643,43644,43645,[43646,69],[43739,3],[43744,16],43762,[43763,4],[43777,6],[43785,6],[43793,6],[43808,7],[43816,7],[43824,43],[43868,14],[43888,123],44012,44013,[44016,10],[44032,11172],[55216,23],[55243,49],[63744,366],[64112,106],[64256,7],[64275,5],64285,64286,[64287,10],[64298,13],[64312,5],64318,[64320,2],[64323,2],[64326,108],[64467,139],[64612,218],[64848,64],[64914,54],[65008,10],[65024,16],[65056,16],[65075,2],[65101,3],65137,65139,65143,65145,65147,65149,[65151,126],[65296,10],[65313,26],65343,[65345,26],[65382,89],[65474,6],[65482,6],[65490,6],[65498,3],[65536,12],[65549,26],[65576,19],[65596,2],[65599,15],[65616,14],[65664,123],[65856,53],66045,[66176,29],[66208,49],66272,[66304,32],[66349,30],[66384,43],[66432,30],[66464,36],[66504,8],[66513,5],[66560,158],[66720,10],[66736,36],[66776,36],[66816,40],[66864,52],[67072,311],[67392,22],[67424,8],[67584,6],67592,[67594,44],[67639,2],67644,[67647,23],[67680,23],[67712,31],[67808,19],[67828,2],[67840,22],[67872,26],[67968,56],[68030,2],68096,[68097,3],[68101,2],[68108,8],[68117,3],[68121,29],[68152,3],68159,[68192,29],[68224,29],[68288,8],[68297,30],[68352,54],[68416,22],[68448,19],[68480,18],[68608,73],[68736,51],[68800,51],[68864,40],[68912,10],[69248,42],[69291,2],[69296,2],[69376,29],69415,[69424,33],[69552,21],[69600,23],69632,69633,69634,[69635,68],[69734,10],[69759,60],[69840,25],[69872,10],[69888,53],[69942,10],69956,[69957,3],[69968,36],70006,[70016,69],[70089,4],70094,70095,[70096,11],70108,[70144,18],[70163,37],70206,[70272,7],70280,[70282,4],[70287,15],[70303,10],[70320,59],[70384,10],[70400,4],[70405,8],[70415,2],[70419,22],[70442,7],[70450,2],[70453,5],[70459,10],[70471,2],[70475,3],70480,70487,[70493,7],[70502,7],[70512,5],[70656,75],[70736,10],70750,[70751,3],[70784,70],70855,[70864,10],[71040,54],[71096,9],[71128,6],[71168,65],71236,[71248,10],[71296,57],[71360,10],[71424,27],[71453,15],[71472,10],[71680,59],[71840,74],[71935,8],71945,[71948,8],[71957,2],[71960,30],[71991,2],[71995,9],[72016,10],[72096,8],[72106,46],[72154,8],72163,72164,72192,[72193,62],72263,72272,[72273,73],72349,[72384,57],[72704,9],[72714,45],[72760,9],[72784,10],[72818,30],[72850,22],72873,[72874,13],[72960,7],[72968,2],[72971,44],73018,[73020,2],[73023,9],[73040,10],[73056,6],[73063,2],[73066,37],[73104,2],[73107,6],[73120,10],[73440,23],73648,[73728,922],[74752,111],[74880,196],[77824,1071],[82944,583],[92160,569],[92736,31],[92768,10],[92880,30],[92912,5],[92928,55],[92992,4],[93008,10],[93027,21],[93053,19],[93760,64],[93952,75],94031,94032,[94033,55],[94095,17],[94176,2],94179,94180,[94192,2],[94208,6136],[100352,1238],[101632,9],[110592,287],[110928,3],[110948,4],[110960,396],[113664,107],[113776,13],[113792,9],[113808,10],[113821,2],[119141,5],[119149,6],[119163,8],[119173,7],[119210,4],[119362,3],[119808,85],[119894,71],[119966,2],119970,[119973,2],[119977,4],[119982,12],119995,[119997,7],[120005,65],[120071,4],[120077,8],[120086,7],[120094,28],[120123,4],[120128,5],120134,[120138,7],[120146,340],[120488,25],[120514,25],[120540,31],[120572,25],[120598,31],[120630,25],[120656,31],[120688,25],[120714,31],[120746,25],[120772,8],[120782,50],[121344,55],[121403,50],121461,121476,[121499,5],[121505,15],[122880,7],[122888,17],[122907,7],[122915,2],[122918,5],[123136,45],[123184,14],[123200,10],123214,[123584,58],[124928,197],[125136,7],[125184,76],[125264,10],[126464,4],[126469,27],[126497,2],126500,126503,[126505,10],[126516,4],126521,126523,126530,126535,126537,126539,[126541,3],[126545,2],126548,126551,126553,126555,126557,126559,[126561,2],126564,[126567,4],[126572,7],[126580,4],[126585,4],126590,[126592,10],[126603,17],[126625,3],[126629,5],[126635,17],[130032,10],[131072,42718],[173824,4149],[177984,222],[178208,5762],[183984,7473],[194560,542],[196608,4939],[917760,240]]}\n$B.unicode_tables={}\nfor(var gc in $B.unicode){$B.unicode_tables[gc]={}\n$B.unicode[gc].forEach(function(item){if(Array.isArray(item)){var step=item[2]||1\nfor(var i=0,nb=item[1];i < nb;i+=1){$B.unicode_tables[gc][item[0]+i*step]=true}}else{$B.unicode_tables[gc][item]=true}})}\nfor(var key in $B.unicode_identifiers){$B.unicode_tables[key]={}\nfor(const item of $B.unicode_identifiers[key]){if(Array.isArray(item)){for(var i=0;i < item[1];i++){$B.unicode_tables[key][item[0]+i]=true}}else{$B.unicode_tables[key][item]=true}}}\n$B.is_unicode_cn=function(i){\nvar cn=$B.unicode.Cn\nfor(var j=0,len=cn.length;j < len;j++){if(i >=cn[j][0]){if(i < cn[j][0]+cn[j][1]){return true}}\nreturn false}\nreturn false}\n;\n;(function($B){var _b_=$B.builtins\nvar unicode_tables=$B.unicode_tables\n$B.has_surrogate=function(s){\nfor(var i=0;i < s.length;i++){code=s.charCodeAt(i)\nif(code >=0xD800 && code <=0xDBFF){return true}}\nreturn false}\n$B.String=function(s){var codepoints=[],surrogates=[],j=0\nfor(var i=0,len=s.length;i < len;i++){var cp=s.codePointAt(i)\nif(cp >=0x10000){surrogates.push(j)\ni++}\nj++}\nif(surrogates.length==0){return s}\nvar res=new String(s)\nres.__class__=str\nres.surrogates=surrogates\nreturn res}\nfunction pypos2jspos(s,pypos){\nif(s.surrogates===undefined){return pypos}\nvar nb=0\nwhile(s.surrogates[nb]< pypos){nb++}\nreturn pypos+nb}\nfunction jspos2pypos(s,jspos){\nif(s.surrogates===undefined){return jspos}\nvar nb=0\nwhile(s.surrogates[nb]+nb < jspos){nb++}\nreturn jspos-nb}\nvar str={__class__:_b_.type,__dir__:_b_.object.__dir__,$infos:{__module__:\"builtins\",__name__:\"str\"},$is_class:true,$native:true}\nfunction normalize_start_end($){var len\nif(typeof $.self==\"string\"){len=$.self.length}else{len=str.__len__($.self)}\nif($.start===null ||$.start===_b_.None){$.start=0}else if($.start < 0){$.start+=len\n$.start=Math.max(0,$.start)}\nif($.end===null ||$.end===_b_.None){$.end=len}else if($.end < 0){$.end+=len\n$.end=Math.max(0,$.end)}\nif(! _b_.isinstance($.start,_b_.int)||! _b_.isinstance($.end,_b_.int)){throw _b_.TypeError.$factory(\"slice indices must be integers \"+\n\"or None or have an __index__ method\")}\nif($.self.surrogates){$.js_start=pypos2jspos($.self,$.start)\n$.js_end=pypos2jspos($.self,$.end)}}\nfunction reverse(s){\nreturn s.split(\"\").reverse().join(\"\")}\nfunction check_str(obj,prefix){if(obj instanceof String ||typeof obj==\"string\"){return}\nif(! _b_.isinstance(obj,str)){throw _b_.TypeError.$factory((prefix ||'')+\n\"must be str, not \"+$B.class_name(obj))}}\nfunction to_chars(s){\nvar chars=[]\nfor(var i=0,len=s.length;i < len;i++){var code=s.charCodeAt(i)\nif(code >=0xD800 && code <=0xDBFF){chars.push(s.substr(i,2))\ni++}else{chars.push(s.charAt(i))}}\nreturn chars}\nfunction to_codepoints(s){\nif(s.codepoints){return s.codepoints}\nvar cps=[]\nfor(var i=0,len=s.length;i < len;i++){var code=s.charCodeAt(i)\nif(code >=0xD800 && code <=0xDBFF){var v=0x10000\nv+=(code & 0x03FF)<< 10\nv+=(s.charCodeAt(i+1)& 0x03FF)\ncps.push(v)\ni++}else{cps.push(code)}}\nreturn s.codepoints=cps}\nstr.__add__=function(self,other){if(! _b_.isinstance(other,str)){try{return $B.$getattr(other,\"__radd__\")(self)}catch(err){throw _b_.TypeError.$factory(\"Can't convert \"+\n$B.class_name(other)+\" to str implicitly\")}}\nreturn $B.String(self+other)}\nstr.__contains__=function(self,item){if(! _b_.isinstance(item,str)){throw _b_.TypeError.$factory(\"'in <string>' requires \"+\n\"string as left operand, not \"+item.__class__)}\nif(item.__class__===str ||_b_.isinstance(item,str)){var nbcar=item.length}else{var nbcar=_b_.len(item)}\nif(nbcar==0){\nreturn true}\nvar len=self.length\nif(len==0){return nbcar==0}\nfor(var i=0,len=self.length;i < len;i++){if(self.substr(i,nbcar)==item){return true}}\nreturn false}\nstr.__delitem__=function(){throw _b_.TypeError.$factory(\"'str' object doesn't support item deletion\")}\nstr.__dir__=_b_.object.__dir__\nstr.__eq__=function(self,other){if(_b_.isinstance(other,_b_.str)){return other.valueOf()==self.valueOf()}\nreturn _b_.NotImplemented}\nfunction preformat(self,fmt){if(fmt.empty){return _b_.str.$factory(self)}\nif(fmt.type && fmt.type !=\"s\"){throw _b_.ValueError.$factory(\"Unknown format code '\"+fmt.type+\n\"' for object of type 'str'\")}\nreturn self}\nstr.__format__=function(self,format_spec){var fmt=new $B.parse_format_spec(format_spec)\nif(fmt.sign !==undefined){throw _b_.ValueError.$factory(\n\"Sign not allowed in string format specifier\")}\nif(fmt.precision){self=self.substr(0,fmt.precision)}\nfmt.align=fmt.align ||\"<\"\nreturn $B.format_width(preformat(self,fmt),fmt)}\nstr.__getitem__=function(self,arg){var len=str.__len__(self)\nif(_b_.isinstance(arg,_b_.int)){var pos=arg\nif(arg < 0){pos+=len}\nif(pos >=0 && pos < len){var jspos=pypos2jspos(self,pos)\nif(self.codePointAt(jspos)>=0x10000){return $B.String(self.substr(jspos,2))}else{return self[jspos]}}\nthrow _b_.IndexError.$factory(\"string index out of range\")}\nif(_b_.isinstance(arg,_b_.slice)){var s=_b_.slice.$conv_for_seq(arg,len),start=pypos2jspos(self,s.start),stop=pypos2jspos(self,s.stop),step=s.step\nvar res=\"\",i=null\nif(step > 0){if(stop <=start){return \"\"}\nfor(var i=start;i < stop;i+=step){res+=self[i]}}else{if(stop >=start){return ''}\nfor(var i=start;i > stop;i+=step){res+=self[i]}}\nreturn $B.String(res)}\nif(_b_.isinstance(arg,_b_.bool)){return self.__getitem__(_b_.int.$factory(arg))}\nthrow _b_.TypeError.$factory(\"string indices must be integers\")}\nvar prefix=2,suffix=3,mask=(2**32-1),str_hash_cache={}\nstr.$nb_str_hash_cache=0\nfunction fnv(p){if(p.length==0){return 0}\nvar x=prefix\nx=(x ^(p[0]<< 7))& mask\nfor(var i=0,len=p.length;i < len;i++){x=((1000003*x)^ p[i])& mask}\nx=(x ^ p.length)& mask\nx=(x ^ suffix)& mask\nif(x==-1){x=-2}\nreturn x}\nstr.__hash__=function(self){if(str_hash_cache[self]!==undefined){return str_hash_cache[self]}\nstr.$nb_str_hash_cache++\nif(str.$nb_str_hash_cache > 100000){\nstr.$nb_str_hash_cache=0\nstr_hash_cache={}}\ntry{return str_hash_cache[self]=fnv(to_codepoints(self))}catch(err){console.log('error hash, cps',self,to_codepoints(self))\nthrow err}}\nstr.__init__=function(self,arg){self.valueOf=function(){return arg}\nself.toString=function(){return arg}\nreturn _b_.None}\nvar str_iterator=$B.make_iterator_class(\"str_iterator\")\nstr.__iter__=function(self){return str_iterator.$factory(to_chars(self))}\nstr.__len__=function(self){if(self.surrogates===undefined){return self.length}\nif(self.len !==undefined){return self.len}\nvar len=self.len=self.valueOf().length-self.surrogates.length\nreturn len}\nvar kwarg_key=new RegExp(\"([^\\\\)]*)\\\\)\")\nvar NotANumber=function(){this.name=\"NotANumber\"}\nvar number_check=function(s){if(! _b_.isinstance(s,[_b_.int,_b_.float])){throw new NotANumber()}}\nvar get_char_array=function(size,char){if(size <=0){return \"\"}\nreturn new Array(size+1).join(char)}\nvar format_padding=function(s,flags,minus_one){var padding=flags.padding\nif(! padding){\nreturn s}\ns=s.toString()\npadding=parseInt(padding,10)\nif(minus_one){\npadding-=1}\nif(! flags.left){return get_char_array(padding-s.length,flags.pad_char)+s}else{\nreturn s+get_char_array(padding-s.length,flags.pad_char)}}\nvar format_int_precision=function(val,flags){var precision=flags.precision\nif(!precision){return val.toString()}\nprecision=parseInt(precision,10)\nvar s\nif(val.__class__===$B.long_int){s=$B.long_int.to_base(val,10)}else{s=val.toString()}\nif(s[0]===\"-\"){return \"-\"+get_char_array(precision-s.length+1,\"0\")+s.slice(1)}\nreturn get_char_array(precision-s.length,\"0\")+s}\nvar format_float_precision=function(val,upper,flags,modifier){var precision=flags.precision\nif(isFinite(val)){return modifier(val,precision,flags,upper)}\nif(val===Infinity){val=\"inf\"}else if(val===-Infinity){val=\"-inf\"}else{val=\"nan\"}\nif(upper){return val.toUpperCase()}\nreturn val}\nvar format_sign=function(val,flags){if(flags.sign){if(val >=0){return \"+\"}}else if(flags.space){if(val >=0){return \" \"}}\nreturn \"\"}\nvar str_format=function(val,flags){\nflags.pad_char=\" \" \nreturn format_padding(str.$factory(val),flags)}\nvar num_format=function(val,flags){number_check(val)\nif(val.__class__===$B.long_int){val=$B.long_int.to_base(val,10)}else{val=parseInt(val)}\nvar s=format_int_precision(val,flags)\nif(flags.pad_char===\"0\"){if(val < 0){s=s.substring(1)\nreturn \"-\"+format_padding(s,flags,true)}\nvar sign=format_sign(val,flags)\nif(sign !==\"\"){return sign+format_padding(s,flags,true)}}\nreturn format_padding(format_sign(val,flags)+s,flags)}\nvar repr_format=function(val,flags){flags.pad_char=\" \" \nreturn format_padding(_b_.repr(val),flags)}\nvar ascii_format=function(val,flags){flags.pad_char=\" \" \nreturn format_padding(_b_.ascii(val),flags)}\nvar _float_helper=function(val,flags){number_check(val)\nif(! flags.precision){if(! flags.decimal_point){flags.precision=6}else{flags.precision=0}}else{flags.precision=parseInt(flags.precision,10)\nvalidate_precision(flags.precision)}\nreturn parseFloat(val)}\nvar trailing_zeros=/(.*?)(0+)([eE].*)/,leading_zeros=/\\.(0*)/,trailing_dot=/\\.$/\nvar validate_precision=function(precision){\nif(precision > 20){precision=20}}\nvar floating_point_format=function(val,upper,flags){val=_float_helper(val,flags),v=val.toString(),v_len=v.length,dot_idx=v.indexOf('.')\nif(dot_idx < 0){dot_idx=v_len}\nif(val < 1 && val >-1){var zeros=leading_zeros.exec(v),numzeros\nif(zeros){numzeros=zeros[1].length}else{numzeros=0}\nif(numzeros >=4){val=format_sign(val,flags)+format_float_precision(val,upper,flags,_floating_g_exp_helper)\nif(!flags.alternate){var trl=trailing_zeros.exec(val)\nif(trl){val=trl[1].replace(trailing_dot,\"\")+trl[3]}}else{if(flags.precision <=1){val=val[0]+\".\"+val.substring(1)}}\nreturn format_padding(val,flags)}\nflags.precision=(flags.precision ||0)+numzeros\nreturn format_padding(format_sign(val,flags)+\nformat_float_precision(val,upper,flags,function(val,precision){return val.toFixed(_b_.min(precision,v_len-dot_idx)+\nnumzeros)}),flags\n)}\nif(dot_idx > flags.precision){val=format_sign(val,flags)+format_float_precision(val,upper,flags,_floating_g_exp_helper)\nif(! flags.alternate){var trl=trailing_zeros.exec(val)\nif(trl){val=trl[1].replace(trailing_dot,\"\")+trl[3]}}else{if(flags.precision <=1){val=val[0]+\".\"+val.substring(1)}}\nreturn format_padding(val,flags)}\nreturn format_padding(format_sign(val,flags)+\nformat_float_precision(val,upper,flags,function(val,precision){if(!flags.decimal_point){precision=_b_.min(v_len-1,6)}else if(precision > v_len){if(! flags.alternate){precision=v_len}}\nif(precision < dot_idx){precision=dot_idx}\nreturn val.toFixed(precision-dot_idx)}),flags\n)}\nvar _floating_g_exp_helper=function(val,precision,flags,upper){if(precision){--precision}\nval=val.toExponential(precision)\nvar e_idx=val.lastIndexOf(\"e\")\nif(e_idx > val.length-4){val=val.substring(0,e_idx+2)+\"0\"+val.substring(e_idx+2)}\nif(upper){return val.toUpperCase()}\nreturn val}\nvar floating_point_decimal_format=function(val,upper,flags){val=_float_helper(val,flags)\nreturn format_padding(format_sign(val,flags)+\nformat_float_precision(val,upper,flags,function(val,precision,flags){val=val.toFixed(precision)\nif(precision===0 && flags.alternate){val+='.'}\nreturn val}),flags\n)}\nvar _floating_exp_helper=function(val,precision,flags,upper){val=val.toExponential(precision)\nvar e_idx=val.lastIndexOf(\"e\")\nif(e_idx > val.length-4){val=val.substring(0,e_idx+2)+\"0\"+val.substring(e_idx+2)}\nif(upper){return val.toUpperCase()}\nreturn val}\nvar floating_point_exponential_format=function(val,upper,flags){val=_float_helper(val,flags)\nreturn format_padding(format_sign(val,flags)+\nformat_float_precision(val,upper,flags,_floating_exp_helper),flags)}\nvar signed_hex_format=function(val,upper,flags){var ret\nnumber_check(val)\nif(val.__class__===$B.long_int){ret=$B.long_int.to_base(val,16)}else{ret=parseInt(val)\nret=ret.toString(16)}\nret=format_int_precision(ret,flags)\nif(upper){ret=ret.toUpperCase()}\nif(flags.pad_char===\"0\"){if(val < 0){ret=ret.substring(1)\nret=\"-\"+format_padding(ret,flags,true)}\nvar sign=format_sign(val,flags)\nif(sign !==\"\"){ret=sign+format_padding(ret,flags,true)}}\nif(flags.alternate){if(ret.charAt(0)===\"-\"){if(upper){ret=\"-0X\"+ret.slice(1)}\nelse{ret=\"-0x\"+ret.slice(1)}}else{if(upper){ret=\"0X\"+ret}\nelse{ret=\"0x\"+ret}}}\nreturn format_padding(format_sign(val,flags)+ret,flags)}\nvar octal_format=function(val,flags){number_check(val)\nvar ret\nif(val.__class__===$B.long_int){ret=$B.long_int.to_base(8)}else{ret=parseInt(val)\nret=ret.toString(8)}\nret=format_int_precision(ret,flags)\nif(flags.pad_char===\"0\"){if(val < 0){ret=ret.substring(1)\nret=\"-\"+format_padding(ret,flags,true)}\nvar sign=format_sign(val,flags)\nif(sign !==\"\"){ret=sign+format_padding(ret,flags,true)}}\nif(flags.alternate){if(ret.charAt(0)===\"-\"){ret=\"-0o\"+ret.slice(1)}\nelse{ret=\"0o\"+ret}}\nreturn format_padding(ret,flags)}\nfunction series_of_bytes(val,flags){if(val.__class__ && val.__class__.$buffer_protocol){var it=_b_.iter(val),ints=[]\nwhile(true){try{ints.push(_b_.next(it))}catch(err){if(err.__class__===_b_.StopIteration){var b=_b_.bytes.$factory(ints)\nreturn format_padding(_b_.bytes.decode(b,\"ascii\"),flags)}\nthrow err}}}else{try{bytes_obj=$B.$getattr(val,\"__bytes__\")\nreturn format_padding(_b_.bytes.decode(bytes_obj),flags)}catch(err){if(err.__class__===_b_.AttributeError){throw _b_.TypeError.$factory(\"%b does not accept '\"+\n$B.class_name(val)+\"'\")}\nthrow err}}}\nvar single_char_format=function(val,flags){if(_b_.isinstance(val,str)&& val.length==1){return val}else if(_b_.isinstance(val,_b_.bytes)&& val.source.length==1){val=val.source[0]}else{try{val=_b_.int.$factory(val)}catch(err){throw _b_.TypeError.$factory(\"%c requires int or char\")}}\nreturn format_padding(_b_.chr(val),flags)}\nvar num_flag=function(c,flags){if(c===\"0\" && ! flags.padding && ! flags.decimal_point && ! flags.left){flags.pad_char=\"0\"\nreturn}\nif(!flags.decimal_point){flags.padding=(flags.padding ||\"\")+c}else{flags.precision=(flags.precision ||\"\")+c}}\nvar decimal_point_flag=function(val,flags){if(flags.decimal_point){\nthrow new UnsupportedChar()}\nflags.decimal_point=true}\nvar neg_flag=function(val,flags){flags.pad_char=\" \" \nflags.left=true}\nvar space_flag=function(val,flags){flags.space=true}\nvar sign_flag=function(val,flags){flags.sign=true}\nvar alternate_flag=function(val,flags){flags.alternate=true}\nvar char_mapping={\"b\":series_of_bytes,\"s\":str_format,\"d\":num_format,\"i\":num_format,\"u\":num_format,\"o\":octal_format,\"r\":repr_format,\"a\":ascii_format,\"g\":function(val,flags){return floating_point_format(val,false,flags)},\"G\":function(val,flags){return floating_point_format(val,true,flags)},\"f\":function(val,flags){return floating_point_decimal_format(val,false,flags)},\"F\":function(val,flags){return floating_point_decimal_format(val,true,flags)},\"e\":function(val,flags){return floating_point_exponential_format(val,false,flags)},\"E\":function(val,flags){return floating_point_exponential_format(val,true,flags)},\"x\":function(val,flags){return signed_hex_format(val,false,flags)},\"X\":function(val,flags){return signed_hex_format(val,true,flags)},\"c\":single_char_format,\"0\":function(val,flags){return num_flag(\"0\",flags)},\"1\":function(val,flags){return num_flag(\"1\",flags)},\"2\":function(val,flags){return num_flag(\"2\",flags)},\"3\":function(val,flags){return num_flag(\"3\",flags)},\"4\":function(val,flags){return num_flag(\"4\",flags)},\"5\":function(val,flags){return num_flag(\"5\",flags)},\"6\":function(val,flags){return num_flag(\"6\",flags)},\"7\":function(val,flags){return num_flag(\"7\",flags)},\"8\":function(val,flags){return num_flag(\"8\",flags)},\"9\":function(val,flags){return num_flag(\"9\",flags)},\"-\":neg_flag,\" \":space_flag,\"+\":sign_flag,\".\":decimal_point_flag,\"#\":alternate_flag}\nvar UnsupportedChar=function(){this.name=\"UnsupportedChar\"}\nstr.__mod__=function(self,args){var length=self.length,pos=0 |0,argpos=null,getitem\nif(_b_.isinstance(args,_b_.tuple)){argpos=0 |0}else{getitem=$B.$getattr(args,\"__getitem__\",_b_.None)}\nvar ret=''\nvar $get_kwarg_string=function(s){\n++pos\nvar rslt=kwarg_key.exec(s.substring(newpos))\nif(! rslt){throw _b_.ValueError.$factory(\"incomplete format key\")}\nvar key=rslt[1]\nnewpos+=rslt[0].length\ntry{var self=getitem(key)}catch(err){if(err.__class__===_b_.KeyError){throw err}\nthrow _b_.TypeError.$factory(\"format requires a mapping\")}\nreturn get_string_value(s,self)}\nvar $get_arg_string=function(s){\nvar self\nif(argpos===null){\nself=args}else{self=args[argpos++]\nif(self===undefined){throw _b_.TypeError.$factory(\n\"not enough arguments for format string\")}}\nreturn get_string_value(s,self)}\nvar get_string_value=function(s,self){\nvar flags={\"pad_char\":\" \"}\ndo{var func=char_mapping[s[newpos]]\ntry{if(func===undefined){throw new UnsupportedChar()}else{var ret=func(self,flags)\nif(ret !==undefined){return ret}\n++newpos}}catch(err){if(err.name==\"UnsupportedChar\"){invalid_char=s[newpos]\nif(invalid_char===undefined){throw _b_.ValueError.$factory(\"incomplete format\")}\nthrow _b_.ValueError.$factory(\n\"unsupported format character '\"+invalid_char+\n\"' (0x\"+invalid_char.charCodeAt(0).toString(16)+\n\") at index \"+newpos)}else if(err.name===\"NotANumber\"){var try_char=s[newpos],cls=self.__class__\nif(!cls){if(typeof(self)===\"string\"){cls=\"str\"}else{cls=typeof(self)}}else{cls=cls.$infos.__name__}\nthrow _b_.TypeError.$factory(\"%\"+try_char+\n\" format: a number is required, not \"+cls)}else{throw err}}}while(true)}\nvar nbph=0 \ndo{var newpos=self.indexOf(\"%\",pos)\nif(newpos < 0){ret+=self.substring(pos)\nbreak}\nret+=self.substring(pos,newpos)\n++newpos\nif(newpos < length){if(self[newpos]===\"%\"){ret+=\"%\"}else{nbph++\nif(self[newpos]===\"(\"){++newpos\nret+=$get_kwarg_string(self)}else{ret+=$get_arg_string(self)}}}else{\nthrow _b_.ValueError.$factory(\"incomplete format\")}\npos=newpos+1}while(pos < length)\nif(argpos !==null){if(args.length > argpos){throw _b_.TypeError.$factory(\n\"not enough arguments for format string\")}else if(args.length < argpos){throw _b_.TypeError.$factory(\n\"not all arguments converted during string formatting\")}}else if(nbph==0){throw _b_.TypeError.$factory(\n\"not all arguments converted during string formatting\")}\nreturn ret}\nstr.__mro__=[_b_.object]\nstr.__mul__=function(){var $=$B.args(\"__mul__\",2,{self:null,other:null},[\"self\",\"other\"],arguments,{},null,null)\nif(! _b_.isinstance($.other,_b_.int)){throw _b_.TypeError.$factory(\n\"Can't multiply sequence by non-int of type '\"+\n$B.class_name($.other)+\"'\")}\nreturn $.self.valueOf().repeat($.other < 0 ? 0 :$.other)}\nstr.__ne__=function(self,other){return other.valueOf()!==self.valueOf()}\nfunction __newobj__(){\nvar $=$B.args('__newobj__',0,{},[],arguments,{},'args',null),args=$.args\nvar res=args[1]\nres.__class__=args[0]\nreturn res}\nstr.__reduce_ex__=function(self){return $B.fast_tuple([__newobj__,$B.fast_tuple([self.__class__ ||_b_.str,self]),_b_.None,_b_.None])}\nstr.__repr__=function(self){\nvar t=$B.special_string_repr,\nrepl='',chars=to_chars(self)\nfor(var i=0;i < chars.length;i++){var cp=_b_.ord(chars[i])\nif(t[cp]!==undefined){repl+=t[cp]}else if($B.is_unicode_cn(cp)){var s=cp.toString(16)\nwhile(s.length < 4){s='0'+s}\nrepl+='\\\\u'+s}else if(cp < 0x20 ||(cp >=0x7f && cp < 0xa0)){cp=cp.toString(16)\nif(cp.length < 2){cp='0'+cp}\nrepl+='\\\\x'+cp}else if(cp >=0x300 && cp <=0x36F){repl+=\"\\u200B\"+chars[i]+' '}else if(cp.toString(16)=='feff'){repl+='\\\\ufeff'}else{repl+=chars[i]}}\nvar res=repl\nif(res.search('\"')==-1 && res.search(\"'\")==-1){return \"'\"+res+\"'\"}else if(self.search('\"')==-1){return '\"'+res+'\"'}\nvar qesc=new RegExp(\"'\",\"g\")\nres=\"'\"+res.replace(qesc,\"\\\\'\")+\"'\"\nreturn res}\nstr.__rmul__=function(self,other){if(_b_.isinstance(other,_b_.int)){other=_b_.int.numerator(other)\nvar res=''\nwhile(other > 0){res+=self\nother--}\nreturn res}\nreturn _b_.NotImplemented}\nstr.__setattr__=function(self,attr,value){if(typeof self===\"string\"){if(str.hasOwnProperty(attr)){throw _b_.AttributeError.$factory(\"'str' object attribute '\"+\nattr+\"' is read-only\")}else{throw _b_.AttributeError.$factory(\n\"'str' object has no attribute '\"+attr+\"'\")}}\n_b_.dict.$setitem(self.__dict__,attr,value)\nreturn $N}\nstr.__setitem__=function(self,attr,value){throw _b_.TypeError.$factory(\n\"'str' object does not support item assignment\")}\nvar combining=[]\nfor(var cp=0x300;cp <=0x36F;cp++){combining.push(String.fromCharCode(cp))}\nvar combining_re=new RegExp(\"(\"+combining.join(\"|\")+\")\",\"g\")\nstr.__str__=function(self){var repl='',chars=to_chars(self)\nif(chars.length==self.length){return self.replace(combining_re,\"\\u200B$1\")}\nfor(var i=0;i < chars.length;i++){var cp=_b_.ord(chars[i])\nif(cp >=0x300 && cp <=0x36F){repl+=\"\\u200B\"+chars[i]}else{repl+=chars[i]}}\nreturn repl}\nstr.toString=function(){return \"string!\"}\nvar $comp_func=function(self,other){if(typeof other !==\"string\"){return _b_.NotImplemented}\nreturn self > other}\n$comp_func+=\"\" \nvar $comps={\">\":\"gt\",\">=\":\"ge\",\"<\":\"lt\",\"<=\":\"le\"}\nfor(var $op in $comps){eval(\"str.__\"+$comps[$op]+'__ = '+$comp_func.replace(/>/gm,$op))}\nvar $notimplemented=function(self,other){throw _b_.NotImplementedError.$factory(\n\"OPERATOR not implemented for class str\")}\nstr.capitalize=function(self){var $=$B.args(\"capitalize\",1,{self},[\"self\"],arguments,{},null,null)\nif(self.length==0){return \"\"}\nreturn self.charAt(0).toUpperCase()+self.substr(1)}\nstr.casefold=function(self){var $=$B.args(\"casefold\",1,{self},[\"self\"],arguments,{},null,null),res=\"\",char,cf,chars=to_chars($.self)\nfor(var i=0,len=chars.length;i < len;i++){char=chars[i]\ncf=$B.unicode_casefold[char]\nif(cf){cf.forEach(function(cp){res+=String.fromCharCode(cp)})}else{res+=char.toLowerCase()}}\nreturn res}\nstr.center=function(){var $=$B.args(\"center\",3,{self:null,width:null,fillchar:null},[\"self\",\"width\",\"fillchar\"],arguments,{fillchar:\" \"},null,null),self=$.self\nif($.width <=self.length){return self}\nvar pad=parseInt(($.width-self.length)/2),res=$.fillchar.repeat(pad)\nres+=self+res\nif(res.length < $.width){res+=$.fillchar}\nreturn res}\nstr.count=function(){var $=$B.args(\"count\",4,{self:null,sub:null,start:null,stop:null},[\"self\",\"sub\",\"start\",\"stop\"],arguments,{start:null,stop:null},null,null)\nif(!(typeof $.sub.valueOf()==\"string\")){throw _b_.TypeError.$factory(\"Can't convert '\"+$B.class_name($.sub)+\n\"' object to str implicitly\")}\nvar substr=$.self\nif($.start !==null){var _slice\nif($.stop !==null){_slice=_b_.slice.$factory($.start,$.stop)}else{_slice=_b_.slice.$factory($.start,$.self.length)}\nsubstr=str.__getitem__.apply(null,[$.self].concat(_slice))}else{if($.self.length+$.sub.length==0){return 1}}\nif($.sub.length==0){if($.start==$.self.length){return 1}else if(substr.length==0){return 0}\nreturn substr.length+1}\nvar n=0,pos=0\nwhile(pos < substr.length){pos=substr.indexOf($.sub,pos)\nif(pos >=0){n++\npos+=$.sub.length}else{break}}\nreturn n}\nstr.encode=function(){var $=$B.args(\"encode\",3,{self:null,encoding:null,errors:null},[\"self\",\"encoding\",\"errors\"],arguments,{encoding:\"utf-8\",errors:\"strict\"},null,null)\nif($.encoding==\"rot13\" ||$.encoding==\"rot_13\"){\nvar res=\"\"\nfor(var i=0,len=$.self.length;i < len ;i++){var char=$.self.charAt(i)\nif((\"a\" <=char && char <=\"m\")||(\"A\" <=char && char <=\"M\")){res+=String.fromCharCode(String.charCodeAt(char)+13)}else if((\"m\" < char && char <=\"z\")||\n(\"M\" < char && char <=\"Z\")){res+=String.fromCharCode(String.charCodeAt(char)-13)}else{res+=char}}\nreturn res}\nreturn _b_.bytes.__new__(_b_.bytes,$.self,$.encoding,$.errors)}\nstr.endswith=function(){\nvar $=$B.args(\"endswith\",4,{self:null,suffix:null,start:null,end:null},[\"self\",\"suffix\",\"start\",\"end\"],arguments,{start:0,end:null},null,null)\nnormalize_start_end($)\nvar suffixes=$.suffix\nif(! _b_.isinstance(suffixes,_b_.tuple)){suffixes=[suffixes]}\nvar chars=to_chars($.self),s=chars.slice($.start,$.end)\nfor(var i=0,len=suffixes.length;i < len;i++){var suffix=suffixes[i]\nif(! _b_.isinstance(suffix,str)){throw _b_.TypeError.$factory(\n\"endswith first arg must be str or a tuple of str, not int\")}\nif(suffix.length <=s.length &&\ns.slice(s.length-suffix.length).join('')==suffix){return true}}\nreturn false}\nstr.expandtabs=function(self,tabsize){var $=$B.args(\"expandtabs\",2,{self:null,tabsize:null},[\"self\",\"tabsize\"],arguments,{tabsize:8},null,null)\nvar s=$B.$GetInt($.tabsize),col=0,pos=0,res=\"\",chars=to_chars(self)\nif(s==1){return self.replace(/\\t/g,\" \")}\nwhile(pos < chars.length){var car=chars[pos]\nswitch(car){case \"\\t\":\nwhile(col % s > 0){res+=\" \";\ncol++}\nbreak\ncase \"\\r\":\ncase \"\\n\":\nres+=car\ncol=0\nbreak\ndefault:\nres+=car\ncol++\nbreak}\npos++}\nreturn res}\nstr.find=function(){\nvar $=$B.args(\"str.find\",4,{self:null,sub:null,start:null,end:null},[\"self\",\"sub\",\"start\",\"end\"],arguments,{start:0,end:null},null,null)\ncheck_str($.sub)\nnormalize_start_end($)\nvar len=str.__len__($.self),sub_len=str.__len__($.sub)\nif(sub_len==0 && $.start==len){return len}\nif(len+sub_len==0){return-1}\nvar js_start=pypos2jspos($.self,$.start),js_end=pypos2jspos($.self,$.end),ix=$.self.substring(js_start,js_end).indexOf($.sub)\nif(ix==-1){return-1}\nreturn jspos2pypos($.self,js_start+ix)}\n$B.parse_format=function(fmt_string){\nvar elts=fmt_string.split(\":\"),name,conv,spec,name_ext=[]\nif(elts.length==1){\nname=fmt_string}else{\nname=elts[0]\nspec=elts.splice(1).join(\":\")}\nvar elts=name.split(\"!\")\nif(elts.length > 1){name=elts[0]\nconv=elts[1]}\nif(name !==undefined){\nfunction name_repl(match){name_ext.push(match)\nreturn \"\"}\nvar name_ext_re=/\\.[_a-zA-Z][_a-zA-Z0-9]*|\\[[_a-zA-Z][_a-zA-Z0-9]*\\]|\\[[0-9]+\\]/g\nname=name.replace(name_ext_re,name_repl)}\nreturn{name:name,name_ext:name_ext,conv:conv,spec:spec ||\"\",string:fmt_string}}\n$B.split_format=function(self){\nvar pos=0,_len=self.length,car,text=\"\",parts=[],rank=0\nwhile(pos < _len){car=self.charAt(pos)\nif(car==\"{\" && self.charAt(pos+1)==\"{\"){\ntext+=\"{\"\npos+=2}else if(car==\"}\" && self.charAt(pos+1)==\"}\"){\ntext+=\"}\"\npos+=2}else if(car==\"{\"){\nparts.push(text)\nvar end=pos+1,nb=1\nwhile(end < _len){if(self.charAt(end)==\"{\"){nb++;end++}\nelse if(self.charAt(end)==\"}\"){nb--;end++\nif(nb==0){\nvar fmt_string=self.substring(pos+1,end-1)\nvar fmt_obj=$B.parse_format(fmt_string)\nfmt_obj.raw_name=fmt_obj.name\nfmt_obj.raw_spec=fmt_obj.spec\nif(!fmt_obj.name){fmt_obj.name=rank+\"\"\nrank++}\nif(fmt_obj.spec !==undefined){\nfunction replace_nested(name,key){if(key==\"\"){\nreturn \"{\"+rank+++\"}\"}\nreturn \"{\"+key+\"}\"}\nfmt_obj.spec=fmt_obj.spec.replace(/\\{(.*?)\\}/g,replace_nested)}\nparts.push(fmt_obj)\ntext=\"\"\nbreak}}else{end++}}\nif(nb > 0){throw _b_.ValueError.$factory(\"wrong format \"+self)}\npos=end}else{text+=car\npos++}}\nif(text){parts.push(text)}\nreturn parts}\nstr.format=function(self){\nvar last_arg=$B.last(arguments)\nif(last_arg.$nat==\"mapping\"){var mapping=last_arg.mapping,getitem=$B.$getattr(mapping,\"__getitem__\")\nvar args=[]\nfor(var i=0,len=arguments.length-1;i < len;i++){args.push(arguments[i])}\nvar $=$B.args(\"format\",1,{self:null},[\"self\"],args,{},\"$args\",null)}else{var $=$B.args(\"format\",1,{self:null},[\"self\"],arguments,{},\"$args\",\"$kw\"),mapping=$.$kw,\ngetitem=function(key){return _b_.dict.$getitem(mapping,key)}}\nvar parts=$B.split_format($.self)\nvar res=\"\",fmt\nfor(var i=0;i < parts.length;i++){\nif(typeof parts[i]==\"string\"){res+=parts[i];\ncontinue}\nfmt=parts[i]\nif(fmt.spec !==undefined){\nfunction replace_nested(name,key){if(/\\d+/.exec(key)){\nreturn _b_.tuple.__getitem__($.$args,parseInt(key))}else{\nreturn _b_.dict.__getitem__($.$kw,key)}}\nfmt.spec=fmt.spec.replace(/\\{(.*?)\\}/g,replace_nested)}\nif(fmt.name.charAt(0).search(/\\d/)>-1){\nvar pos=parseInt(fmt.name),value=_b_.tuple.__getitem__($.$args,pos)}else{\nvar value=getitem(fmt.name)}\nfor(var j=0;j < fmt.name_ext.length;j++){var ext=fmt.name_ext[j]\nif(ext.charAt(0)==\".\"){\nvalue=$B.$getattr(value,ext.substr(1))}else{\nvar key=ext.substr(1,ext.length-2)\nif(key.charAt(0).search(/\\d/)>-1){key=parseInt(key)}\nvalue=$B.$getattr(value,\"__getitem__\")(key)}}\nif(fmt.conv==\"a\"){value=_b_.ascii(value)}\nelse if(fmt.conv==\"r\"){value=_b_.repr(value)}\nelse if(fmt.conv==\"s\"){value=_b_.str.$factory(value)}\nif(value.$is_class ||value.$factory){\nres+=value.__class__.__format__(value,fmt.spec)}else{res+=$B.$getattr(value,\"__format__\")(fmt.spec)}}\nreturn res}\nstr.format_map=function(self,mapping){var $=$B.args(\"format_map\",2,{self:null,mapping:null},['self','mapping'],arguments,{},null,null)\nreturn str.format(self,{$nat:'mapping',mapping})}\nstr.index=function(self){\nvar res=str.find.apply(null,arguments)\nif(res===-1){throw _b_.ValueError.$factory(\"substring not found\")}\nreturn res}\nstr.isascii=function(self){\nfor(var i=0,len=self.length;i < len;i++){if(self.charCodeAt(i)> 127){return false}}\nreturn true}\nstr.isalnum=function(self){\nvar $=$B.args(\"isalnum\",1,{self:null},[\"self\"],arguments,{},null,null),cp\nfor(var char of to_chars(self)){cp=_b_.ord(char)\nif(unicode_tables.Ll[cp]||\nunicode_tables.Lu[cp]||\nunicode_tables.Lm[cp]||\nunicode_tables.Lt[cp]||\nunicode_tables.Lo[cp]||\nunicode_tables.Nd[cp]||\nunicode_tables.digits[cp]||\nunicode_tables.numeric[cp]){continue}\nreturn false}\nreturn true}\nstr.isalpha=function(self){\nvar $=$B.args(\"isalpha\",1,{self:null},[\"self\"],arguments,{},null,null),cp\nfor(var char of to_chars(self)){cp=_b_.ord(char)\nif(unicode_tables.Ll[cp]||\nunicode_tables.Lu[cp]||\nunicode_tables.Lm[cp]||\nunicode_tables.Lt[cp]||\nunicode_tables.Lo[cp]){continue}\nreturn false}\nreturn true}\nstr.isdecimal=function(self){\nvar $=$B.args(\"isdecimal\",1,{self:null},[\"self\"],arguments,{},null,null),cp\nfor(var char of to_chars(self)){cp=_b_.ord(char)\nif(! unicode_tables.Nd[cp]){return false}}\nreturn self.length > 0}\nstr.isdigit=function(self){\nvar $=$B.args(\"isdigit\",1,{self:null},[\"self\"],arguments,{},null,null),cp\nfor(var char of to_chars(self)){cp=_b_.ord(char)\nif(! unicode_tables.digits[cp]){return false}}\nreturn self.length > 0}\nstr.isidentifier=function(self){\nvar $=$B.args(\"isidentifier\",1,{self:null},[\"self\"],arguments,{},null,null)\nif(self.length==0){return false}\nvar chars=to_chars(self)\nif(unicode_tables.XID_Start[_b_.ord(chars[0])]===undefined){return false}else{for(var char of chars){var cp=_b_.ord(char)\nif(unicode_tables.XID_Continue[cp]===undefined){return false}}}\nreturn true}\nstr.islower=function(self){\nvar $=$B.args(\"islower\",1,{self:null},[\"self\"],arguments,{},null,null),has_cased=false,cp\nfor(var char of to_chars(self)){cp=_b_.ord(char)\nif(unicode_tables.Ll[cp]){has_cased=true\ncontinue}else if(unicode_tables.Lu[cp]||unicode_tables.Lt[cp]){return false}}\nreturn has_cased}\nstr.isnumeric=function(self){\nvar $=$B.args(\"isnumeric\",1,{self:null},[\"self\"],arguments,{},null,null)\nfor(var char of to_chars(self)){if(! unicode_tables.numeric[_b_.ord(char)]){return false}}\nreturn self.length > 0}\nvar unprintable={},unprintable_gc=['Cc','Cf','Co','Cs','Zl','Zp','Zs']\nstr.isprintable=function(self){\nif(Object.keys(unprintable).length==0){for(var i=0;i < unprintable_gc.length;i++){var table=unicode_tables[unprintable_gc[i]]\nfor(var cp in table){unprintable[cp]=true}}\nunprintable[32]=true}\nvar $=$B.args(\"isprintable\",1,{self:null},[\"self\"],arguments,{},null,null)\nfor(var char of to_chars(self)){if(unprintable[_b_.ord(char)]){return false}}\nreturn true}\nstr.isspace=function(self){\nvar $=$B.args(\"isspace\",1,{self:null},[\"self\"],arguments,{},null,null),cp\nfor(var char of to_chars(self)){cp=_b_.ord(char)\nif(! unicode_tables.Zs[cp]&&\n$B.unicode_bidi_whitespace.indexOf(cp)==-1){return false}}\nreturn self.length > 0}\nstr.istitle=function(self){\nvar $=$B.args(\"istitle\",1,{self:null},[\"self\"],arguments,{},null,null)\nreturn self.length > 0 && str.title(self)==self}\nstr.isupper=function(self){\nvar $=$B.args(\"islower\",1,{self:null},[\"self\"],arguments,{},null,null),is_upper=false,cp\nfor(var char of to_chars(self)){cp=_b_.ord(char)\nif(unicode_tables.Lu[cp]){is_upper=true\ncontinue}else if(unicode_tables.Ll[cp]||unicode_tables.Lt[cp]){return false}}\nreturn is_upper}\nstr.join=function(){var $=$B.args(\"join\",2,{self:null,iterable:null},[\"self\",\"iterable\"],arguments,{},null,null)\nvar iterable=_b_.iter($.iterable),res=[],count=0\nwhile(1){try{var obj2=_b_.next(iterable)\nif(! _b_.isinstance(obj2,str)){throw _b_.TypeError.$factory(\"sequence item \"+count+\n\": expected str instance, \"+$B.class_name(obj2)+\n\" found\")}\nres.push(obj2)}catch(err){if(_b_.isinstance(err,_b_.StopIteration)){break}\nelse{throw err}}}\nreturn res.join($.self)}\nstr.ljust=function(self){var $=$B.args(\"ljust\",3,{self:null,width:null,fillchar:null},[\"self\",\"width\",\"fillchar\"],arguments,{fillchar:\" \"},null,null),len=str.__len__(self)\nif($.width <=len){return self}\nreturn self+$.fillchar.repeat($.width-len)}\nstr.lower=function(self){var $=$B.args(\"lower\",1,{self:null},[\"self\"],arguments,{},null,null)\nreturn self.toLowerCase()}\nstr.lstrip=function(self,x){var $=$B.args(\"lstrip\",2,{self:null,chars:null},[\"self\",\"chars\"],arguments,{chars:_b_.None},null,null),self=$.self,chars=$.chars\nif(chars===_b_.None){return self.trimStart()}\nwhile(self.length > 0){var flag=false\nfor(var char of chars){if(self.startsWith(char)){self=self.substr(char.length)\nflag=true\nbreak}}\nif(! flag){return $.self.surrogates ? $B.String(self):self}}\nreturn ''}\nstr.maketrans=function(){var $=$B.args(\"maketrans\",3,{x:null,y:null,z:null},[\"x\",\"y\",\"z\"],arguments,{y:null,z:null},null,null)\nvar _t=$B.empty_dict()\nif($.y===null && $.z===null){\nif(! _b_.isinstance($.x,_b_.dict)){throw _b_.TypeError.$factory(\n\"maketrans only argument must be a dict\")}\nvar items=_b_.list.$factory(_b_.dict.items($.x))\nfor(var i=0,len=items.length;i < len;i++){var k=items[i][0],v=items[i][1]\nif(! _b_.isinstance(k,_b_.int)){if(_b_.isinstance(k,_b_.str)&& k.length==1){k=_b_.ord(k)}else{throw _b_.TypeError.$factory(\"dictionary key \"+k+\n\" is not int or 1-char string\")}}\nif(v !==_b_.None && ! _b_.isinstance(v,[_b_.int,_b_.str])){throw _b_.TypeError.$factory(\"dictionary value \"+v+\n\" is not None, integer or string\")}\n_b_.dict.$setitem(_t,k,v)}\nreturn _t}else{\nif(!(_b_.isinstance($.x,_b_.str)&& _b_.isinstance($.y,_b_.str))){throw _b_.TypeError.$factory(\"maketrans arguments must be strings\")}else if($.x.length !==$.y.length){throw _b_.TypeError.$factory(\n\"maketrans arguments must be strings or same length\")}else{var toNone={}\nif($.z !==null){\nif(! _b_.isinstance($.z,_b_.str)){throw _b_.TypeError.$factory(\n\"maketrans third argument must be a string\")}\nfor(var i=0,len=$.z.length;i < len;i++){toNone[_b_.ord($.z.charAt(i))]=true}}\nfor(var i=0,len=$.x.length;i < len;i++){var key=_b_.ord($.x.charAt(i)),value=$.y.charCodeAt(i)\n_b_.dict.$setitem(_t,key,value)}\nfor(var k in toNone){_b_.dict.$setitem(_t,parseInt(k),_b_.None)}\nreturn _t}}}\nstr.maketrans.$type=\"staticmethod\"\nstr.partition=function(){var $=$B.args(\"partition\",2,{self:null,sep:null},[\"self\",\"sep\"],arguments,{},null,null)\nif($.sep==\"\"){throw _b_.ValueError.$factory(\"empty separator\")}\ncheck_str($.sep)\nvar chars=to_chars($.self),i=$.self.indexOf($.sep)\nif(i==-1){return _b_.tuple.$factory([$.self,\"\",\"\"])}\nreturn _b_.tuple.$factory([chars.slice(0,i).join(''),$.sep,chars.slice(i+$.sep.length).join('')])}\nstr.removeprefix=function(){var $=$B.args(\"removeprefix\",2,{self:null,prefix:null},[\"self\",\"prefix\"],arguments,{},null,null)\nif(!_b_.isinstance($.prefix,str)){throw _b_.ValueError.$factory(\"prefix should be str, not \"+\n`'${$B.class_name($.prefix)}'`)}\nif(str.startswith($.self,$.prefix)){return $.self.substr($.prefix.length)}\nreturn $.self.substr(0)}\nstr.removesuffix=function(){var $=$B.args(\"removesuffix\",2,{self:null,prefix:null},[\"self\",\"suffix\"],arguments,{},null,null)\nif(!_b_.isinstance($.suffix,str)){throw _b_.ValueError.$factory(\"suffix should be str, not \"+\n`'${$B.class_name($.prefix)}'`)}\nif($.suffix.length > 0 && str.endswith($.self,$.suffix)){return $.self.substr(0,$.self.length-$.suffix.length)}\nreturn $.self.substr(0)}\nfunction $re_escape(str){var specials=\"[.*+?|()$^\"\nfor(var i=0,len=specials.length;i < len;i++){var re=new RegExp(\"\\\\\"+specials.charAt(i),\"g\")\nstr=str.replace(re,\"\\\\\"+specials.charAt(i))}\nreturn str}\nstr.replace=function(self,old,_new,count){\nvar $=$B.args(\"replace\",4,{self:null,old:null,new:null,count:null},[\"self\",\"old\",\"new\",\"count\"],arguments,{count:-1},null,null),count=$.count,self=$.self,old=$.old,_new=$.new\ncheck_str(old,\"replace() argument 1 \")\ncheck_str(_new,\"replace() argument 2 \")\nif(! _b_.isinstance(count,[_b_.int,_b_.float])){throw _b_.TypeError.$factory(\"'\"+$B.class_name(count)+\n\"' object cannot be interpreted as an integer\")}else if(_b_.isinstance(count,_b_.float)){throw _b_.TypeError.$factory(\"integer argument expected, got float\")}\nif(count==0){return self}\nif(count.__class__==$B.long_int){count=parseInt(count.value)}\nif(old==\"\"){if(_new==\"\"){return self}\nif(self==\"\"){return _new}\nvar elts=self.split(\"\")\nif(count >-1 && elts.length >=count){var rest=elts.slice(count).join(\"\")\nreturn _new+elts.slice(0,count).join(_new)+rest}else{return _new+elts.join(_new)+_new}}else{var elts=str.split(self,old,count)}\nvar res=self,pos=-1\nif(old.length==0){var res=_new\nfor(var i=0;i < elts.length;i++){res+=elts[i]+_new}\nreturn res+rest}\nif(count < 0){count=res.length}\nwhile(count > 0){pos=res.indexOf(old,pos)\nif(pos < 0){break}\nres=res.substr(0,pos)+_new+res.substr(pos+old.length)\npos=pos+_new.length\ncount--}\nreturn res}\nstr.rfind=function(self,substr){\nvar $=$B.args(\"rfind\",4,{self:null,sub:null,start:null,end:null},[\"self\",\"sub\",\"start\",\"end\"],arguments,{start:0,end:null},null,null)\nnormalize_start_end($)\ncheck_str($.sub)\nvar len=str.__len__($.self),sub_len=str.__len__($.sub)\nif(sub_len==0){if($.js_start > len){return-1}else{return str.__len__($.self)}}\nvar js_start=pypos2jspos($.self,$.start),js_end=pypos2jspos($.self,$.end),ix=$.self.substring(js_start,js_end).lastIndexOf($.sub)\nif(ix==-1){return-1}\nreturn jspos2pypos($.self,js_start+ix)-$.start}\nstr.rindex=function(){\nvar res=str.rfind.apply(null,arguments)\nif(res==-1){throw _b_.ValueError.$factory(\"substring not found\")}\nreturn res}\nstr.rjust=function(self){var $=$B.args(\"rjust\",3,{self:null,width:null,fillchar:null},[\"self\",\"width\",\"fillchar\"],arguments,{fillchar:\" \"},null,null)\nvar len=str.__len__(self)\nif($.width <=len){return self}\nreturn $B.String($.fillchar.repeat($.width-len)+self)}\nstr.rpartition=function(self,sep){var $=$B.args(\"rpartition\",2,{self:null,sep:null},[\"self\",\"sep\"],arguments,{},null,null)\ncheck_str($.sep)\nvar self=reverse($.self),sep=reverse($.sep)\nvar items=str.partition(self,sep).reverse()\nfor(var i=0;i < items.length;i++){items[i]=items[i].split(\"\").reverse().join(\"\")}\nreturn items}\nstr.rsplit=function(self){var $=$B.args(\"rsplit\",3,{self:null,sep:null,maxsplit:null},[\"self\",\"sep\",\"maxsplit\"],arguments,{sep:_b_.None,maxsplit:-1},null,null),sep=$.sep\nvar rev_str=reverse($.self),rev_sep=sep===_b_.None ? sep :reverse($.sep),rev_res=str.split(rev_str,rev_sep,$.maxsplit)\nrev_res.reverse()\nfor(var i=0;i < rev_res.length;i++){rev_res[i]=reverse(rev_res[i])}\nreturn rev_res}\nstr.rstrip=function(self,x){var $=$B.args(\"rstrip\",2,{self:null,chars:null},[\"self\",\"chars\"],arguments,{chars:_b_.None},null,null),self=$.self,chars=$.chars\nif(chars===_b_.None){return self.trimEnd()}\nwhile(self.length > 0){var flag=false\nfor(var char of chars){if(self.endsWith(char)){self=self.substr(0,self.length-char.length)\nflag=true\nbreak}}\nif(! flag){return $.self.surrogates ? $B.String(self):self}}\nreturn ''}\nstr.split=function(){var $=$B.args(\"split\",3,{self:null,sep:null,maxsplit:null},[\"self\",\"sep\",\"maxsplit\"],arguments,{sep:_b_.None,maxsplit:-1},null,null),sep=$.sep,maxsplit=$.maxsplit,self=$.self,pos=0\nif(maxsplit.__class__===$B.long_int){maxsplit=parseInt(maxsplit.value)}\nif(sep==\"\"){throw _b_.ValueError.$factory(\"empty separator\")}\nif(sep===_b_.None){var res=[]\nwhile(pos < self.length && self.charAt(pos).search(/\\s/)>-1){pos++}\nif(pos===self.length-1){return[self]}\nvar name=\"\"\nwhile(1){if(self.charAt(pos).search(/\\s/)==-1){if(name==\"\"){name=self.charAt(pos)}else{name+=self.charAt(pos)}}else{if(name !==\"\"){res.push(name)\nif(maxsplit !==-1 && res.length==maxsplit+1){res.pop()\nres.push(name+self.substr(pos))\nreturn res}\nname=\"\"}}\npos++\nif(pos > self.length-1){if(name){res.push(name)}\nbreak}}\nreturn res.map($B.String)}else{var res=[],s=\"\",seplen=sep.length\nif(maxsplit==0){return[self]}\nwhile(pos < self.length){if(self.substr(pos,seplen)==sep){res.push(s)\npos+=seplen\nif(maxsplit >-1 && res.length >=maxsplit){res.push(self.substr(pos))\nreturn res.map($B.String)}\ns=\"\"}else{s+=self.charAt(pos)\npos++}}\nres.push(s)\nreturn res.map($B.String)}}\nstr.splitlines=function(self){var $=$B.args('splitlines',2,{self:null,keepends:null},['self','keepends'],arguments,{keepends:false},null,null)\nif(!_b_.isinstance($.keepends,[_b_.bool,_b_.int])){throw _b_.TypeError('integer argument expected, got '+\n$B.get_class($.keepends).__name)}\nvar keepends=_b_.int.$factory($.keepends),res=[],self=$.self,start=0,pos=0\nif(!self.length){return res}\nwhile(pos < self.length){if(self.substr(pos,2)=='\\r\\n'){res.push(self.slice(start,keepends ? pos+2 :pos))\nstart=pos=pos+2}else if(self[pos]=='\\r' ||self[pos]=='\\n'){res.push(self.slice(start,keepends ? pos+1 :pos))\nstart=pos=pos+1}else{pos++}}\nif(start < self.length){res.push(self.slice(start))}\nreturn res.map($B.String)}\nstr.startswith=function(){\nvar $=$B.args(\"startswith\",4,{self:null,prefix:null,start:null,end:null},[\"self\",\"prefix\",\"start\",\"end\"],arguments,{start:0,end:null},null,null)\nnormalize_start_end($)\nvar prefixes=$.prefix\nif(! _b_.isinstance(prefixes,_b_.tuple)){prefixes=[prefixes]}\nvar s=$.self.substring($.js_start,$.js_end)\nfor(var prefix of prefixes){if(! _b_.isinstance(prefix,str)){throw _b_.TypeError.$factory(\"endswith first arg must be str \"+\n\"or a tuple of str, not int\")}\nif(s.substr(0,prefix.length)==prefix){return true}}\nreturn false}\nstr.strip=function(){var $=$B.args(\"strip\",2,{self:null,chars:null},[\"self\",\"chars\"],arguments,{chars:_b_.None},null,null)\nif($.chars===_b_.None){return $.self.trim()}\nreturn str.rstrip(str.lstrip($.self,$.chars),$.chars)}\nstr.swapcase=function(self){var $=$B.args(\"swapcase\",1,{self},[\"self\"],arguments,{},null,null),res=\"\",cp\nfor(var char of to_chars(self)){cp=_b_.ord(char)\nif(unicode_tables.Ll[cp]){res+=char.toUpperCase()}else if(unicode_tables.Lu[cp]){res+=char.toLowerCase()}else{res+=char}}\nreturn res}\nstr.title=function(self){var $=$B.args(\"title\",1,{self},[\"self\"],arguments,{},null,null),state,cp,res=\"\"\nfor(var char of to_chars(self)){cp=_b_.ord(char)\nif(unicode_tables.Ll[cp]){if(! state){res+=char.toUpperCase()\nstate=\"word\"}else{res+=char}}else if(unicode_tables.Lu[cp]||unicode_tables.Lt[cp]){res+=state ? char.toLowerCase():char\nstate=\"word\"}else{state=null\nres+=char}}\nreturn res}\nstr.translate=function(self,table){var res=[],getitem=$B.$getattr(table,\"__getitem__\"),cp\nfor(var char of to_chars(self)){cp=_b_.ord(char)\ntry{var repl=getitem(cp)\nif(repl !==_b_.None){if(typeof repl==\"string\"){res.push(repl)}else if(typeof repl==\"number\"){res.push(String.fromCharCode(repl))}}}catch(err){res.push(char)}}\nreturn res.join(\"\")}\nstr.upper=function(self){var $=$B.args(\"upper\",1,{self:null},[\"self\"],arguments,{},null,null)\nreturn self.toUpperCase()}\nstr.zfill=function(self,width){var $=$B.args(\"zfill\",2,{self:null,width:null},[\"self\",\"width\"],arguments,{},null,null),len=str.__len__(self)\nif($.width <=len){return self}\nswitch(self.charAt(0)){case \"+\":\ncase \"-\":\nreturn self.charAt(0)+\n\"0\".repeat($.width-len)+self.substr(1)\ndefault:\nreturn \"0\".repeat($.width-len)+self}}\nstr.$factory=function(arg,encoding,errors){if(arguments.length==0){return \"\"}\nif(arg===undefined){return $B.UndefinedClass.__str__()}else if(arg===null){return '<Javascript null>'}\nif(encoding !==undefined){\nvar $=$B.args(\"str\",3,{arg:null,encoding:null,errors:null},[\"arg\",\"encoding\",\"errors\"],arguments,{encoding:\"utf-8\",errors:\"strict\"},null,null),encoding=$.encoding,errors=$.errors}\nif(typeof arg==\"string\" ||arg instanceof String ||\ntypeof arg==\"number\"){if(isFinite(arg)){return arg.toString()}}\ntry{if(arg.$is_class ||arg.$factory){\nvar func=$B.$getattr(arg.__class__,\"__str__\")\nreturn func(arg)}\nif(arg.__class__ && arg.__class__===_b_.bytes &&\nencoding !==undefined){\nreturn _b_.bytes.decode(arg,$.encoding,$.errors)}\nvar klass=arg.__class__ ||$B.get_class(arg)\nif(klass===undefined){return $B.JSObj.__str__($B.JSObj.$factory(arg))}\nvar method=$B.$getattr(klass ,\"__str__\",null)\nif(method===null ||\n(arg.__class__ && arg.__class__ !==_b_.object &&\nmethod===_b_.object.__str__)){var method=$B.$getattr(klass,\"__repr__\")}}\ncatch(err){console.log(\"no __str__ for\",arg)\nconsole.log(\"err \",err)\nif($B.debug > 1){console.log(err)}\nconsole.log(\"Warning - no method __str__ or __repr__, \"+\n\"default to toString\",arg)\nthrow err}\nreturn $B.$call(method)(arg)}\nstr.__new__=function(cls){if(cls===undefined){throw _b_.TypeError.$factory(\"str.__new__(): not enough arguments\")}\nreturn{__class__:cls}}\n$B.set_func_names(str,\"builtins\")\nvar StringSubclass=$B.StringSubclass={__class__:_b_.type,__mro__:[_b_.object],$infos:{__module__:\"builtins\",__name__:\"str\"},$is_class:true}\nfor(var $attr in str){if(typeof str[$attr]==\"function\"){StringSubclass[$attr]=(function(attr){return function(){var args=[],pos=0\nif(arguments.length > 0){var args=[arguments[0].valueOf()],pos=1\nfor(var i=1,len=arguments.length;i < len;i++){args[pos++]=arguments[i]}}\nreturn str[attr].apply(null,args)}})($attr)}}\nStringSubclass.__new__=function(cls){return{__class__:cls}}\n$B.set_func_names(StringSubclass,\"builtins\")\n_b_.str=str\n$B.parse_format_spec=function(spec){if(spec==\"\"){this.empty=true}else{var pos=0,aligns=\"<>=^\",digits=\"0123456789\",types=\"bcdeEfFgGnosxX%\",align_pos=aligns.indexOf(spec.charAt(0))\nif(align_pos !=-1){if(spec.charAt(1)&& aligns.indexOf(spec.charAt(1))!=-1){\nthis.fill=spec.charAt(0)\nthis.align=spec.charAt(1)\npos=2}else{\nthis.align=aligns[align_pos]\nthis.fill=\" \"\npos++}}else{align_pos=aligns.indexOf(spec.charAt(1))\nif(spec.charAt(1)&& align_pos !=-1){\nthis.align=aligns[align_pos]\nthis.fill=spec.charAt(0)\npos=2}}\nvar car=spec.charAt(pos)\nif(car==\"+\" ||car==\"-\" ||car==\" \"){this.sign=car\npos++\ncar=spec.charAt(pos)}\nif(car==\"#\"){this.alternate=true;pos++;car=spec.charAt(pos)}\nif(car==\"0\"){\nthis.fill=\"0\"\nif(align_pos==-1){this.align=\"=\"}\npos++\ncar=spec.charAt(pos)}\nwhile(car && digits.indexOf(car)>-1){if(this.width===undefined){this.width=car}else{this.width+=car}\npos++\ncar=spec.charAt(pos)}\nif(this.width !==undefined){this.width=parseInt(this.width)}\nif(this.width===undefined && car==\"{\"){\nvar end_param_pos=spec.substr(pos).search(\"}\")\nthis.width=spec.substring(pos,end_param_pos)\nconsole.log(\"width\",\"[\"+this.width+\"]\")\npos+=end_param_pos+1}\nif(car==\",\"){this.comma=true\npos++\ncar=spec.charAt(pos)}\nif(car==\".\"){if(digits.indexOf(spec.charAt(pos+1))==-1){throw _b_.ValueError.$factory(\n\"Missing precision in format spec\")}\nthis.precision=spec.charAt(pos+1)\npos+=2\ncar=spec.charAt(pos)\nwhile(car && digits.indexOf(car)>-1){this.precision+=car\npos++\ncar=spec.charAt(pos)}\nthis.precision=parseInt(this.precision)}\nif(car && types.indexOf(car)>-1){this.type=car\npos++\ncar=spec.charAt(pos)}\nif(pos !==spec.length){throw _b_.ValueError.$factory(\"Invalid format specifier: \"+spec)}}\nthis.toString=function(){return(this.fill===undefined ? \"\" :_b_.str.$factory(this.fill))+\n(this.align ||\"\")+\n(this.sign ||\"\")+\n(this.alternate ? \"#\" :\"\")+\n(this.sign_aware ? \"0\" :\"\")+\n(this.width ||\"\")+\n(this.comma ? \",\" :\"\")+\n(this.precision ? \".\"+this.precision :\"\")+\n(this.type ||\"\")}}\n$B.format_width=function(s,fmt){if(fmt.width && s.length < fmt.width){var fill=fmt.fill ||\" \",align=fmt.align ||\"<\",missing=fmt.width-s.length\nswitch(align){case \"<\":\nreturn s+fill.repeat(missing)\ncase \">\":\nreturn fill.repeat(missing)+s\ncase \"=\":\nif(\"+-\".indexOf(s.charAt(0))>-1){return s.charAt(0)+fill.repeat(missing)+s.substr(1)}else{return fill.repeat(missing)+s}\ncase \"^\":\nvar left=parseInt(missing/2)\nreturn fill.repeat(left)+s+fill.repeat(missing-left)}}\nreturn s}\nfunction fstring_expression(start){this.type=\"expression\"\nthis.start=start\nthis.expression=\"\"\nthis.conversion=null\nthis.fmt=null}\nfunction fstring_error(msg,pos){error=Error(msg)\nerror.position=pos\nthrow error}\n$B.parse_fstring=function(string){\nvar elts=[],pos=0,current=\"\",ctype=null,nb_braces=0,expr_start,car\nwhile(pos < string.length){if(ctype===null){car=string.charAt(pos)\nif(car==\"{\"){if(string.charAt(pos+1)==\"{\"){ctype=\"string\"\ncurrent=\"{\"\npos+=2}else{ctype=\"expression\"\nexpr_start=pos+1\nnb_braces=1\npos++}}else if(car==\"}\"){if(string.charAt(pos+1)==car){ctype=\"string\"\ncurrent=\"}\"\npos+=2}else{fstring_error(\" f-string: single '}' is not allowed\",pos)}}else{ctype=\"string\"\ncurrent=car\npos++}}else if(ctype==\"string\"){\nvar i=pos\nwhile(i < string.length){car=string.charAt(i)\nif(car==\"{\"){if(string.charAt(i+1)==\"{\"){current+=\"{\"\ni+=2}else{elts.push(current)\nctype=\"expression\"\nexpr_start=i+1\npos=i+1\nbreak}}else if(car==\"}\"){if(string.charAt(i+1)==car){current+=car\ni+=2}else{fstring_error(\" f-string: single '}' is not allowed\",pos)}}else{current+=car\ni++}}\npos=i+1}else if(ctype==\"debug\"){\nwhile(string.charAt(i)==\" \"){i++}\nif(string.charAt(i)==\"}\"){\nelts.push(current)\nctype=null\ncurrent=\"\"\npos=i+1}}else{\nvar i=pos,nb_braces=1,nb_paren=0,current=new fstring_expression(expr_start)\nwhile(i < string.length){car=string.charAt(i)\nif(car==\"{\" && nb_paren==0){nb_braces++\ncurrent.expression+=car\ni++}else if(car==\"}\" && nb_paren==0){nb_braces-=1\nif(nb_braces==0){\nif(current.expression==\"\"){fstring_error(\"f-string: empty expression not allowed\",pos)}\nelts.push(current)\nctype=null\ncurrent=\"\"\npos=i+1\nbreak}\ncurrent.expression+=car\ni++}else if(car==\"\\\\\"){\nthrow Error(\"f-string expression part cannot include a\"+\n\" backslash\")}else if(nb_paren==0 && car==\"!\" && current.fmt===null &&\n\":}\".indexOf(string.charAt(i+2))>-1){if(current.expression.length==0){throw Error(\"f-string: empty expression not allowed\")}\nif(\"ars\".indexOf(string.charAt(i+1))==-1){throw Error(\"f-string: invalid conversion character:\"+\n\" expected 's', 'r', or 'a'\")}else{current.conversion=string.charAt(i+1)\ni+=2}}else if(car==\"(\" ||car=='['){nb_paren++\ncurrent.expression+=car\ni++}else if(car==\")\" ||car==']'){nb_paren--\ncurrent.expression+=car\ni++}else if(car=='\"'){\nif(string.substr(i,3)=='\"\"\"'){var end=string.indexOf('\"\"\"',i+3)\nif(end==-1){fstring_error(\"f-string: unterminated string\",pos)}else{var trs=string.substring(i,end+3)\ntrs=trs.replace(\"\\n\",\"\\\\n\\\\\")\ncurrent.expression+=trs\ni=end+3}}else{var end=string.indexOf('\"',i+1)\nif(end==-1){fstring_error(\"f-string: unterminated string\",pos)}else{current.expression+=string.substring(i,end+1)\ni=end+1}}}else if(nb_paren==0 && car==\":\"){\ncurrent.fmt=true\nvar cb=0,fmt_complete=false\nfor(var j=i+1;j < string.length;j++){if(string[j]=='{'){if(string[j+1]=='{'){j+=2}else{cb++}}else if(string[j]=='}'){if(string[j+1]=='}'){j+=2}else if(cb==0){fmt_complete=true\nvar fmt=string.substring(i+1,j)\ncurrent.format=$B.parse_fstring(fmt)\ni=j\nbreak}else{cb--}}}\nif(! fmt_complete){fstring_error('invalid format',pos)}}else if(car==\"=\"){\nvar ce=current.expression,last_char=ce.charAt(ce.length-1),last_char_re=('()'.indexOf(last_char)>-1 ? \"\\\\\" :\"\")+last_char\nif(ce.length==0 ||\nnb_paren > 0 ||\nstring.charAt(i+1)==\"=\" ||\n\"=!<>:\".search(last_char_re)>-1){\ncurrent.expression+=car\ni+=1}else{\ntail=car\nwhile(string.charAt(i+1).match(/\\s/)){tail+=string.charAt(i+1)\ni++}\nelts.push(current.expression+tail)\nwhile(ce.match(/\\s$/)){ce=ce.substr(0,ce.length-1)}\ncurrent.expression=ce\nctype=\"debug\"\ni++}}else{current.expression+=car\ni++}}\nif(nb_braces > 0){fstring_error(\"f-string: expected '}'\",pos)}}}\nif(current.length > 0){elts.push(current)}\nfor(var elt of elts){if(typeof elt==\"object\"){if(elt.fmt_pos !==undefined &&\nelt.expression.charAt(elt.fmt_pos)!=':'){console.log('mauvais format',string,elts)\nthrow Error()}}}\nreturn elts}\nvar _chr=$B.codepoint2jsstring=function(i){if(i >=0x10000 && i <=0x10FFFF){var code=(i-0x10000)\nreturn String.fromCodePoint(0xD800 |(code >> 10))+\nString.fromCodePoint(0xDC00 |(code & 0x3FF))}else{return String.fromCodePoint(i)}}\nvar _ord=$B.jsstring2codepoint=function(c){if(c.length==1){return c.charCodeAt(0)}\nvar code=0x10000\ncode+=(c.charCodeAt(0)& 0x03FF)<< 10\ncode+=(c.charCodeAt(1)& 0x03FF)\nreturn code}})(__BRYTHON__)\n;\n;(function($B){var _b_=$B.builtins\nfunction $err(op,other){var msg=\"unsupported operand type(s) for \"+op+\n\" : 'int' and '\"+$B.class_name(other)+\"'\"\nthrow _b_.TypeError.$factory(msg)}\nfunction int_value(obj){\nif(typeof obj==\"boolean\"){return obj ? 1 :0}\nreturn obj.$brython_value !==undefined ? obj.$brython_value :obj}\nvar int={__class__:_b_.type,__dir__:_b_.object.__dir__,__mro__:[_b_.object],$infos:{__module__:\"builtins\",__name__:\"int\"},$is_class:true,$native:true,$descriptors:{\"numerator\":true,\"denominator\":true,\"imag\":true,\"real\":true}}\nint.as_integer_ratio=function(){var $=$B.args(\"as_integer_ratio\",1,{self:null},[\"self\"],arguments,{},null,null)\nreturn $B.$list([$.self,1])}\nint.from_bytes=function(){var $=$B.args(\"from_bytes\",3,{bytes:null,byteorder:null,signed:null},[\"bytes\",\"byteorder\",\"signed\"],arguments,{signed:false},null,null)\nvar x=$.bytes,byteorder=$.byteorder,signed=$.signed,_bytes,_len\nif(_b_.isinstance(x,[_b_.bytes,_b_.bytearray])){_bytes=x.source\n_len=x.source.length}else{_bytes=_b_.list.$factory(x)\n_len=_bytes.length\nfor(var i=0;i < _len;i++){_b_.bytes.$factory([_bytes[i]])}}\nif(byteorder==\"big\"){_bytes.reverse()}else if(byteorder !=\"little\"){throw _b_.ValueError.$factory(\n\"byteorder must be either 'little' or 'big'\")}\nvar num=_bytes[0]\nif(signed && num >=128){num=num-256}\nvar _mult=256\nfor(var i=1;i < _len;i++){num=$B.add($B.mul(_mult,_bytes[i]),num)\n_mult=$B.mul(_mult,256)}\nif(! signed){return num}\nif(_bytes[_len-1]< 128){return num}\nreturn $B.sub(num,_mult)}\nint.to_bytes=function(){var $=$B.args(\"to_bytes\",3,{self:null,len:null,byteorder:null,signed:null},[\"self\",\"len\",\"byteorder\",\"*\",\"signed\"],arguments,{signed:false},null,null),self=$.self,len=$.len,byteorder=$.byteorder,signed=$.signed\nif(! _b_.isinstance(len,_b_.int)){throw _b_.TypeError.$factory(\"integer argument expected, got \"+\n$B.class_name(len))}\nif([\"little\",\"big\"].indexOf(byteorder)==-1){throw _b_.ValueError.$factory(\n\"byteorder must be either 'little' or 'big'\")}\nif(_b_.isinstance(self,$B.long_int)){return $B.long_int.to_bytes(self,len,byteorder,signed)}\nif(self < 0){if(! signed){throw _b_.OverflowError.$factory(\n\"can't convert negative int to unsigned\")}\nself=Math.pow(256,len)+self}\nvar res=[],value=self\nwhile(value > 0){var quotient=Math.floor(value/256),rest=value-256*quotient\nres.push(rest)\nif(res.length > len){throw _b_.OverflowError.$factory(\"int too big to convert\")}\nvalue=quotient}\nwhile(res.length < len){res.push(0)}\nif(byteorder==\"big\"){res.reverse()}\nreturn{\n__class__:_b_.bytes,source:res}}\nint.__abs__=function(self){return _b_.abs(self)}\nint.__add__=function(self,other){self=int_value(self)\nif(_b_.isinstance(other,int)){if(other.__class__==$B.long_int){return $B.long_int.__add__($B.long_int.$factory(self),$B.long_int.$factory(other))}\nother=int_value(other)\nvar res=self+other\nif(res > $B.min_int && res < $B.max_int){return res}else{return $B.long_int.__add__($B.long_int.$factory(self),$B.long_int.$factory(other))}}\nreturn _b_.NotImplemented}\nint.__bool__=function(self){return int_value(self).valueOf()==0 ? false :true}\nint.__ceil__=function(self){return Math.ceil(int_value(self))}\nint.__divmod__=function(self,other){if(! _b_.isinstance(other,int)){return _b_.NotImplemented}\nreturn $B.fast_tuple([int.__floordiv__(self,other),int.__mod__(self,other)])}\nint.__eq__=function(self,other){\nif(_b_.isinstance(other,int)){return self.valueOf()==int_value(other).valueOf()}\nif(_b_.isinstance(other,_b_.float)){return self.valueOf()==other.valueOf()}\nif(_b_.isinstance(other,_b_.complex)){if(other.$imag !=0){return _b_.False}\nreturn self.valueOf()==other.$real}\nreturn _b_.NotImplemented}\nint.__float__=function(self){return new Number(self)}\nfunction preformat(self,fmt){if(fmt.empty){return _b_.str.$factory(self)}\nif(fmt.type && 'bcdoxXn'.indexOf(fmt.type)==-1){throw _b_.ValueError.$factory(\"Unknown format code '\"+fmt.type+\n\"' for object of type 'int'\")}\nvar res\nswitch(fmt.type){case undefined:\ncase \"d\":\nres=self.toString()\nbreak\ncase \"b\":\nres=(fmt.alternate ? \"0b\" :\"\")+self.toString(2)\nbreak\ncase \"c\":\nres=_b_.chr(self)\nbreak\ncase \"o\":\nres=(fmt.alternate ? \"0o\" :\"\")+self.toString(8)\nbreak\ncase \"x\":\nres=(fmt.alternate ? \"0x\" :\"\")+self.toString(16)\nbreak\ncase \"X\":\nres=(fmt.alternate ? \"0X\" :\"\")+self.toString(16).toUpperCase()\nbreak\ncase \"n\":\nreturn self }\nif(fmt.sign !==undefined){if((fmt.sign==\" \" ||fmt.sign==\"+\" )&& self >=0){res=fmt.sign+res}}\nreturn res}\nint.__format__=function(self,format_spec){var fmt=new $B.parse_format_spec(format_spec)\nif(fmt.type && 'eEfFgG%'.indexOf(fmt.type)!=-1){\nreturn _b_.float.__format__(self,format_spec)}\nfmt.align=fmt.align ||\">\"\nvar res=preformat(self,fmt)\nif(fmt.comma){var sign=res[0]==\"-\" ? \"-\" :\"\",rest=res.substr(sign.length),len=rest.length,nb=Math.ceil(rest.length/3),chunks=[]\nfor(var i=0;i < nb;i++){chunks.push(rest.substring(len-3*i-3,len-3*i))}\nchunks.reverse()\nres=sign+chunks.join(\",\")}\nreturn $B.format_width(res,fmt)}\nint.__floordiv__=function(self,other){if(other.__class__===$B.long_int){return $B.long_int.__floordiv__($B.long_int.$factory(self),other)}\nif(_b_.isinstance(other,int)){other=int_value(other)\nif(other==0){throw _b_.ZeroDivisionError.$factory(\"division by zero\")}\nreturn Math.floor(self/other)}\nreturn _b_.NotImplemented}\nint.__hash__=function(self){if(self.$brython_value){\nvar hash_method=$B.$getattr(self.__class__,'__hash__')\nif(hash_method===int.__hash__){if(typeof self.$brython_value==\"number\"){return self.$brython_value}else{\nreturn $B.long_int.__hash__(self.$brython_value)}}else{return hash_method(self)}}\nreturn self.valueOf()}\nint.__index__=function(self){return int_value(self)}\nint.__init__=function(self,value){if(value===undefined){value=0}\nself.toString=function(){return value}\nreturn _b_.None}\nint.__int__=function(self){return self}\nint.__invert__=function(self){return ~self}\nint.__lshift__=function(self,other){self=int_value(self)\nif(_b_.isinstance(other,int)){other=int_value(other)\ntry{return int.$factory($B.long_int.__lshift__($B.long_int.$factory(self),$B.long_int.$factory(other)))}catch(err){console.log('err in lshift',self,other)\nthrow err}}\nreturn _b_.NotImplemented}\nint.__mod__=function(self,other){\nif(_b_.isinstance(other,_b_.tuple)&& other.length==1){other=other[0]}\nif(other.__class__===$B.long_int){return $B.long_int.__mod__($B.long_int.$factory(self),other)}\nif(_b_.isinstance(other,int)){other=int_value(other)\nif(other===false){other=0}\nelse if(other===true){other=1}\nif(other==0){throw _b_.ZeroDivisionError.$factory(\n\"integer division or modulo by zero\")}\nreturn(self % other+other)% other}\nreturn _b_.NotImplemented}\nint.__mul__=function(self,other){self=int_value(self)\nif(_b_.isinstance(other,int)){if(other.__class__==$B.long_int){return $B.long_int.__mul__($B.long_int.$factory(self),$B.long_int.$factory(other))}\nother=int_value(other)\nvar res=self*other\nif(res > $B.min_int && res < $B.max_int){return res}else{return int.$factory($B.long_int.__mul__($B.long_int.$factory(self),$B.long_int.$factory(other)))}}\nreturn _b_.NotImplemented}\nint.__ne__=function(self,other){var res=int.__eq__(self,other)\nreturn(res===_b_.NotImplemented)? res :!res}\nint.__neg__=function(self){return-self}\nint.__new__=function(cls,value){if(cls===undefined){throw _b_.TypeError.$factory(\"int.__new__(): not enough arguments\")}else if(! _b_.isinstance(cls,_b_.type)){throw _b_.TypeError.$factory(\"int.__new__(X): X is not a type object\")}\nif(cls===int){return int.$factory(value)}\nreturn{\n__class__:cls,__dict__:$B.empty_dict(),$brython_value:value ||0}}\nint.__pos__=function(self){return self}\nfunction extended_euclidean(a,b){var d,u,v\nif(b==0){return[a,1,0]}else{[d,u,v]=extended_euclidean(b,a % b)\nreturn[d,v,u-Math.floor(a/b)*v]}}\nint.__pow__=function(self,other,z){if(! _b_.isinstance(other,int)){return _b_.NotImplemented}\nif(typeof other==\"number\" ||_b_.isinstance(other,int)){other=int_value(other)\nswitch(other.valueOf()){case 0:\nreturn int.$factory(1)\ncase 1:\nreturn int.$factory(self.valueOf())}\nif(z !==undefined && z !==_b_.None){\nif(z==1){return 0}\nvar result=1,base=self % z,exponent=other,long_int=$B.long_int\nif(exponent < 0){var gcd,inv,_\n[gcd,inv,_]=extended_euclidean(self,z)\nif(gcd !==1){throw _b_.ValueError.$factory(\"not relative primes: \"+\nself+' and '+z)}\nreturn int.__pow__(inv,-exponent,z)}\nwhile(exponent > 0){if(exponent % 2==1){if(result*base > $B.max_int){result=long_int.__mul__(\nlong_int.$factory(result),long_int.$factory(base))\nresult=long_int.__mod__(result,z)}else{result=(result*base)% z}}\nexponent=exponent >> 1\nif(base*base > $B.max_int){base=long_int.__mul__(long_int.$factory(base),long_int.$factory(base))\nbase=long_int.__mod__(base,z)}else{base=(base*base)% z}}\nreturn result}\nvar res=Math.pow(self.valueOf(),other.valueOf())\nif(res > $B.min_int && res < $B.max_int){return other > 0 ? res :new Number(res)}else if(res !==Infinity && !isFinite(res)){return res}else{if($B.BigInt){return{\n__class__:$B.long_int,value:($B.BigInt(self)**$B.BigInt(other)).toString(),pos:true}}\nreturn $B.long_int.__pow__($B.long_int.$from_int(self),$B.long_int.$from_int(other))}}\nif(_b_.isinstance(other,_b_.float)){other=_b_.float.numerator(other)\nif(self >=0){return new Number(Math.pow(self,other))}else{\nreturn _b_.complex.__pow__($B.make_complex(self,0),other)}}else if(_b_.isinstance(other,_b_.complex)){var preal=Math.pow(self,other.$real),ln=Math.log(self)\nreturn $B.make_complex(preal*Math.cos(ln),preal*Math.sin(ln))}\nvar rpow=$B.$getattr(other,\"__rpow__\",_b_.None)\nif(rpow !==_b_.None){return rpow(self)}\n$err(\"**\",other)}\nfunction __newobj__(){\nvar $=$B.args('__newobj__',0,{},[],arguments,{},'args',null),args=$.args\nvar res=args.slice(1)\nres.__class__=args[0]\nreturn res}\nint.__reduce_ex__=function(self){return $B.fast_tuple([__newobj__,$B.fast_tuple([self.__class__ ||int,int_value(self)]),_b_.None,_b_.None,_b_.None])}\nint.__repr__=function(self){$B.builtins_repr_check(int,arguments)\nreturn int_value(self).toString()}\nint.__rshift__=function(self,other){self=int_value(self)\nif(typeof other==\"number\" ||_b_.isinstance(other,int)){other=int_value(other)\nreturn int.$factory($B.long_int.__rshift__($B.long_int.$factory(self),$B.long_int.$factory(other)))}\nreturn _b_.NotImplemented}\nint.__setattr__=function(self,attr,value){if(typeof self==\"number\" ||typeof self==\"boolean\"){var cl_name=$B.class_name(self)\nif(_b_.dir(self).indexOf(attr)>-1){throw _b_.AttributeError.$factory(\"attribute '\"+attr+\n`' of '${cl_name}' objects is not writable`)}else{throw _b_.AttributeError.$factory(`'${cl_name}' object`+\n` has no attribute '${attr}'`)}\nthrow _b_.AttributeError.$factory(msg)}\n_b_.dict.$setitem(self.__dict__,attr,value)\nreturn _b_.None}\nint.__sub__=function(self,other){self=int_value(self)\nif(_b_.isinstance(other,int)){if(other.__class__==$B.long_int){return $B.long_int.__sub__($B.long_int.$factory(self),$B.long_int.$factory(other))}\nother=int_value(other)\nvar res=self-other\nif(res > $B.min_int && res < $B.max_int){return res}else{return $B.long_int.__sub__($B.long_int.$factory(self),$B.long_int.$factory(other))}}\nreturn _b_.NotImplemented}\nint.__truediv__=function(self,other){if(_b_.isinstance(other,int)){other=int_value(other)\nif(other==0){throw _b_.ZeroDivisionError.$factory(\"division by zero\")}\nif(other.__class__===$B.long_int){return new Number(self/parseInt(other.value))}\nreturn new Number(self/other)}\nreturn _b_.NotImplemented}\nint.bit_length=function(self){s=_b_.bin(self)\ns=$B.$getattr(s,\"lstrip\")(\"-0b\")\nreturn s.length }\nint.numerator=function(self){return int_value(self)}\nint.denominator=function(self){return int.$factory(1)}\nint.imag=function(self){return int.$factory(0)}\nint.real=function(self){return self}\nfor(var attr of['numerator','denominator','imag','real']){int[attr].setter=(function(x){return function(self,value){throw _b_.AttributeError.$factory(`attribute '${x}' of `+\n`'${$B.class_name(self)}' objects is not writable`)}})(attr)}\n$B.max_int32=(1 << 30)*2-1\n$B.min_int32=-$B.max_int32\nvar $op_func=function(self,other){self=int_value(self)\nif(typeof other==\"number\" ||_b_.isinstance(other,int)){if(other.__class__===$B.long_int){return $B.long_int.__sub__($B.long_int.$factory(self),$B.long_int.$factory(other))}\nother=int_value(other)\nif(self > $B.max_int32 ||self < $B.min_int32 ||\nother > $B.max_int32 ||other < $B.min_int32){return $B.long_int.__sub__($B.long_int.$factory(self),$B.long_int.$factory(other))}\nreturn self-other}\nreturn _b_.NotImplemented}\n$op_func+=\"\" \nvar $ops={\"&\":\"and\",\"|\":\"or\",\"^\":\"xor\"}\nfor(var $op in $ops){var opf=$op_func.replace(/-/gm,$op)\nopf=opf.replace(new RegExp(\"sub\",\"gm\"),$ops[$op])\neval(\"int.__\"+$ops[$op]+\"__ = \"+opf)}\nvar $comp_func=function(self,other){if(other.__class__===$B.long_int){return $B.long_int.__lt__(other,$B.long_int.$factory(self))}\nif(_b_.isinstance(other,int)){other=int_value(other)\nreturn self.valueOf()> other.valueOf()}else if(_b_.isinstance(other,_b_.float)){return self.valueOf()> _b_.float.numerator(other)}else if(_b_.isinstance(other,_b_.bool)){return self.valueOf()> _b_.bool.__hash__(other)}\nif(_b_.hasattr(other,\"__int__\")||_b_.hasattr(other,\"__index__\")){return int.__gt__(self,$B.$GetInt(other))}\nreturn _b_.NotImplemented}\n$comp_func+=\"\" \nfor(var $op in $B.$comps){eval(\"int.__\"+$B.$comps[$op]+\"__ = \"+\n$comp_func.replace(/>/gm,$op).\nreplace(/__gt__/gm,\"__\"+$B.$comps[$op]+\"__\").\nreplace(/__lt__/,\"__\"+$B.$inv_comps[$op]+\"__\"))}\nvar r_opnames=[\"add\",\"sub\",\"mul\",\"truediv\",\"floordiv\",\"mod\",\"pow\",\"lshift\",\"rshift\",\"and\",\"xor\",\"or\",\"divmod\"]\nfor(var r_opname of r_opnames){if(int[\"__r\"+r_opname+\"__\"]===undefined &&\nint['__'+r_opname+'__']){int[\"__r\"+r_opname+\"__\"]=(function(name){return function(self,other){if(_b_.isinstance(other,int)){other=int_value(other)\nreturn int[\"__\"+name+\"__\"](other,self)}\nreturn _b_.NotImplemented}})(r_opname)}}\nvar $valid_digits=function(base){var digits=\"\"\nif(base===0){return \"0\"}\nif(base < 10){for(var i=0;i < base;i++){digits+=String.fromCharCode(i+48)}\nreturn digits}\nvar digits=\"0123456789\"\nfor(var i=10;i < base;i++){digits+=String.fromCharCode(i+55)}\nreturn digits}\nint.$factory=function(value,base){\nif(value===undefined){return 0}\nif(typeof value==\"number\" &&\n(base===undefined ||base==10)){return parseInt(value)}\nif(_b_.isinstance(value,_b_.complex)){throw _b_.TypeError.$factory(\"can't convert complex to int\")}\nvar $ns=$B.args(\"int\",2,{x:null,base:null},[\"x\",\"base\"],arguments,{\"base\":10},null,null),value=$ns[\"x\"],base=$ns[\"base\"]\nif(_b_.isinstance(value,_b_.float)&& base==10){value=_b_.float.numerator(value)\nif(value < $B.min_int ||value > $B.max_int){return $B.long_int.$from_float(value)}\nelse{return value > 0 ? Math.floor(value):Math.ceil(value)}}\nif(!(base >=2 && base <=36)){\nif(base !=0){throw _b_.ValueError.$factory(\"invalid base\")}}\nif(typeof value==\"number\"){if(base==10){if(value < $B.min_int ||value > $B.max_int){return $B.long_int.$factory(value)}\nreturn value}else if(value.toString().search(\"e\")>-1){\nthrow _b_.OverflowError.$factory(\"can't convert to base \"+base)}else{var res=parseInt(value,base)\nif(value < $B.min_int ||value > $B.max_int){return $B.long_int.$factory(value,base)}\nreturn res}}\nif(value===true){return Number(1)}\nif(value===false){return Number(0)}\nif(value.__class__===$B.long_int){var z=parseInt(value.value)\nif(z > $B.min_int && z < $B.max_int){return z}\nelse{return value}}\nbase=$B.$GetInt(base)\nfunction invalid(value,base){throw _b_.ValueError.$factory(\"invalid literal for int() with base \"+\nbase+\": '\"+_b_.str.$factory(value)+\"'\")}\nif(_b_.isinstance(value,_b_.str)){value=value.valueOf()}\nif(typeof value==\"string\"){var _value=value.trim()\nif(_value.length==2 && base==0 &&\n(_value==\"0b\" ||_value==\"0o\" ||_value==\"0x\")){throw _b_.ValueError.$factory(\"invalid value\")}\nif(_value.length > 2){var _pre=_value.substr(0,2).toUpperCase()\nif(base==0){if(_pre==\"0B\"){base=2}\nif(_pre==\"0O\"){base=8}\nif(_pre==\"0X\"){base=16}}else if(_pre==\"0X\" && base !=16){invalid(_value,base)}\nelse if(_pre==\"0O\" && base !=8){invalid(_value,base)}\nif((_pre==\"0B\" && base==2)||_pre==\"0O\" ||_pre==\"0X\"){_value=_value.substr(2)\nwhile(_value.startsWith(\"_\")){_value=_value.substr(1)}}}else if(base==0){\nbase=10}\nvar _digits=$valid_digits(base),_re=new RegExp(\"^[+-]?[\"+_digits+\"]\"+\n\"[\"+_digits+\"_]*$\",\"i\"),match=_re.exec(_value)\nif(match===null){invalid(value,base)}else{value=_value.replace(/_/g,\"\")}\nif(base <=10 && ! isFinite(value)){invalid(_value,base)}\nvar res=parseInt(value,base)\nif(res < $B.min_int ||res > $B.max_int){return $B.long_int.$factory(value,base)}\nreturn res}\nif(_b_.isinstance(value,[_b_.bytes,_b_.bytearray])){return int.$factory($B.$getattr(value,\"decode\")(\"latin-1\"),base)}\nfor(var special_method of[\"__int__\",\"__index__\",\"__trunc__\"]){var num_value=$B.$getattr(value.__class__ ||$B.get_class(value),special_method,_b_.None)\nif(num_value !==_b_.None){return $B.$call(num_value)(value)}}\nthrow _b_.TypeError.$factory(\n\"int() argument must be a string, a bytes-like \"+\n\"object or a number, not '\"+$B.class_name(value)+\"'\")}\n$B.set_func_names(int,\"builtins\")\n_b_.int=int\n$B.$bool=function(obj){\nif(obj===null ||obj===undefined ){return false}\nswitch(typeof obj){case \"boolean\":\nreturn obj\ncase \"number\":\ncase \"string\":\nif(obj){return true}\nreturn false\ndefault:\nif(obj.$is_class){return true}\nvar klass=obj.__class__ ||$B.get_class(obj),missing={},bool_method=$B.$getattr(klass,\"__bool__\",missing)\nif(bool_method===missing){try{return _b_.len(obj)> 0}\ncatch(err){return true}}else{var res=$B.$call(bool_method)(obj)\nif(res !==true && res !==false){throw _b_.TypeError.$factory(\"__bool__ should return \"+\n\"bool, returned \"+$B.class_name(res))}\nreturn res}}}\nvar bool={__bases__:[int],__class__:_b_.type,__mro__:[int,_b_.object],$infos:{__name__:\"bool\",__module__:\"builtins\"},$is_class:true,$native:true,$descriptors:{\"numerator\":true,\"denominator\":true,\"imag\":true,\"real\":true}}\nbool.__and__=function(self,other){if(_b_.isinstance(other,bool)){return self && other}else if(_b_.isinstance(other,int)){return int.__and__(bool.__index__(self),int.__index__(other))}\nreturn _b_.NotImplemented}\nbool.__float__=function(self){return self ? new Number(1):new Number(0)}\nbool.__hash__=bool.__index__=bool.__int__=function(self){if(self.valueOf())return 1\nreturn 0}\nbool.__neg__=function(self){return-$B.int_or_bool(self)}\nbool.__or__=function(self,other){if(_b_.isinstance(other,bool)){return self ||other}else if(_b_.isinstance(other,int)){return int.__or__(bool.__index__(self),int.__index__(other))}\nreturn _b_.NotImplemented}\nbool.__pos__=$B.int_or_bool\nbool.__repr__=function(self){$B.builtins_repr_check(bool,arguments)\nreturn self ? \"True\" :\"False\"}\nbool.__xor__=function(self,other){if(_b_.isinstance(other,bool)){return self ^ other ? true :false}else if(_b_.isinstance(other,int)){return int.__xor__(bool.__index__(self),int.__index__(other))}\nreturn _b_.NotImplemented}\nbool.$factory=function(){\nvar $=$B.args(\"bool\",1,{x:null},[\"x\"],arguments,{x:false},null,null)\nreturn $B.$bool($.x)}\nbool.numerator=int.numerator\nbool.denominator=int.denominator\nbool.real=int.real\nbool.imag=int.imag\n_b_.bool=bool\n$B.set_func_names(bool,\"builtins\")})(__BRYTHON__)\n;\n;(function($B){\nvar _b_=$B.builtins\ntry{eval(\"window\")}catch(err){window=self}\nvar long_int={__class__:_b_.type,__mro__:[_b_.int,_b_.object],$infos:{__module__:\"builtins\",__name__:\"int\"},$is_class:true,$native:true,$descriptors:{\"numerator\":true,\"denominator\":true,\"imag\":true,\"real\":true}}\nvar max_safe_divider=$B.max_int/9\nfunction add_pos(v1,v2){\nreturn{\n__class__:long_int,value:(BigInt(v1)+BigInt(v2)).toString(),pos:true}}\nvar len=((Math.pow(2,53)-1)+'').length-1\nfunction binary_pos(t){var nb_chunks=Math.ceil(t.length/len),chunks=[],pos,start,nb,bin=[]\nfor(var i=0;i < nb_chunks;i++){pos=t.length-(i+1)*len\nstart=Math.max(0,pos)\nnb=pos-start\nchunks.push(t.substr(start,len+nb))}\nchunks=chunks.reverse()\nchunks.forEach(function(chunk,i){chunks[i]=parseInt(chunk)})\nvar rest\nvar carry=Math.pow(10,15)\nwhile(chunks[chunks.length-1]> 0){chunks.forEach(function(chunk,i){rest=chunk % 2\nchunks[i]=Math.floor(chunk/2)\nif(rest && i < chunks.length-1){chunks[i+1]+=carry}})\nbin.push(rest)\nif(chunks[0]==0){chunks.shift()}}\nbin=bin.reverse().join('')\nreturn bin}\nfunction binary(obj){var bpos=binary_pos(obj.value)\nif(obj.pos){return bpos}\nvar res=''\nfor(var i=0,len=bpos.length;i < len;i++){res+=bpos.charAt(i)==\"0\" ? \"1\":\"0\"}\nvar add1=add_pos(res,\"1\").value\nadd1=res.substr(0,res.length-add1.length)+add1\nreturn add1}\nfunction comp_pos(v1,v2){\nif(v1.length > v2.length){return 1}\nelse if(v1.length < v2.length){return-1}\nelse{if(v1 > v2){return 1}\nelse if(v1 < v2){return-1}}\nreturn 0}\nfunction divmod_by_safe_int(t,n){\nif(n==1){return[t,0]}\nvar quotient=BigInt(t)/BigInt(n),rest=BigInt(t)-quotient*BigInt(n)\nconsole.log(\"divmod by safe int\")\nreturn[from_BigInt(quotient),from_BigInt(rest)]}\nfunction divmod_pos(v1,v2){\nvar a={__class__:long_int,value:(BigInt(v1)/BigInt(v2)).toString(),pos:true},b={__class__:long_int,value:(BigInt(v1)% BigInt(v2)).toString(),pos:true}\nreturn[a,b]}\nfunction split_chunks(s,size){var nb=Math.ceil(s.length/size),chunks=[],len=s.length\nfor(var i=0;i < nb;i++){var pos=len-size*(i+1)\nif(pos < 0){size+=pos;pos=0}\nchunks.push(parseInt(s.substr(pos,size)))}\nreturn chunks}\nfunction mul_pos(x,y){\nreturn long_int.$factory(from_BigInt(BigInt(x)*BigInt(y)))}\nfunction sub_pos(v1,v2){\nreturn{\n__class__:long_int,value:(BigInt(v1)-BigInt(v2)).toString(),pos:true}}\nfunction to_BigInt(x){var res=$B.BigInt(x.value)\nif(x.pos){return res}\nreturn-res}\nfunction to_int(long_int){return long_int.pos ? parseInt(long_int.value):-parseInt(long_int.value)}\nfunction from_BigInt(y){var pos=y >=0\ny=y.toString()\ny=y.endsWith(\"n\")? y.substr(0,y.length-1):y\ny=y.startsWith('-')? y.substr(1):y\nreturn intOrLong({__class__:long_int,value:y,pos:pos})}\nlong_int.$from_float=function(value){var s=Math.abs(value).toString(),v=s\nif(s.search(\"e\")>-1){var t=/-?(\\d)(\\.\\d+)?e([+-])(\\d*)/.exec(s),n1=t[1],n2=t[2],pos=t[3],exp=t[4]\nif(pos==\"+\"){if(n2===undefined){v=n1+\"0\".repeat(exp-1)}else{v=n1+n2+\"0\".repeat(exp-1-n2.length)}}}\nreturn{__class__:long_int,value:v,pos:value >=0}}\nfunction preformat(self,fmt){if(fmt.empty){return _b_.str.$factory(self)}\nif(fmt.type && 'bcdoxXn'.indexOf(fmt.type)==-1){throw _b_.ValueError.$factory(\"Unknown format code '\"+fmt.type+\n\"' for object of type 'int'\")}\nvar res\nswitch(fmt.type){case undefined:\ncase \"d\":\nres=self.toString()\nbreak\ncase \"b\":\nres=(fmt.alternate ? \"0b\" :\"\")+BigInt(self.value).toString(2)\nbreak\ncase \"c\":\nres=_b_.chr(self)\nbreak\ncase \"o\":\nres=(fmt.alternate ? \"0o\" :\"\")+BigInt(self.value).toString(8)\nbreak\ncase \"x\":\nres=(fmt.alternate ? \"0x\" :\"\")+BigInt(self.value).toString(16)\nbreak\ncase \"X\":\nres=(fmt.alternate ? \"0X\" :\"\")+BigInt(self.value).toString(16).toUpperCase()\nbreak\ncase \"n\":\nreturn self }\nif(fmt.sign !==undefined){if((fmt.sign==\" \" ||fmt.sign==\"+\" )&& self >=0){res=fmt.sign+res}}\nreturn res}\nlong_int.__format__=function(self,format_spec){var fmt=new $B.parse_format_spec(format_spec)\nif(fmt.type && 'eEfFgG%'.indexOf(fmt.type)!=-1){\nreturn _b_.float.__format__(self,format_spec)}\nfmt.align=fmt.align ||\">\"\nvar res=preformat(self,fmt)\nif(fmt.comma){var sign=res[0]==\"-\" ? \"-\" :\"\",rest=res.substr(sign.length),len=rest.length,nb=Math.ceil(rest.length/3),chunks=[]\nfor(var i=0;i < nb;i++){chunks.push(rest.substring(len-3*i-3,len-3*i))}\nchunks.reverse()\nres=sign+chunks.join(\",\")}\nreturn $B.format_width(res,fmt)}\nlong_int.__abs__=function(self){return{__class__:long_int,value:self.value,pos:true}}\nlong_int.__add__=function(self,other){if(_b_.isinstance(other,_b_.float)){return _b_.float.$factory(to_int(self)+other)}\nif(typeof other==\"number\"){other=long_int.$factory(_b_.str.$factory(other))}else if(other.__class__ !==long_int){if(_b_.isinstance(other,_b_.bool)){other=long_int.$factory(other ? 1 :0)}else if(_b_.isinstance(other,_b_.int)){\nother=long_int.$factory(_b_.str.$factory(_b_.int.__index__(other)))}else{return _b_.NotImplemented}}\nreturn from_BigInt(to_BigInt(self)+to_BigInt(other))}\nlong_int.__and__=function(self,other){if(typeof other==\"number\"){other=long_int.$factory(_b_.str.$factory(other))}\nreturn from_BigInt(to_BigInt(self)& to_BigInt(other))}\nlong_int.__divmod__=function(self,other){if(typeof other==\"number\"){other=long_int.$factory(_b_.str.$factory(other))}\nvar a=to_BigInt(self),b=to_BigInt(other),quotient\nif((a >=0 && b > 0)||(a <=0 && b < 0)){quotient=a/b}else{quotient=a/b-BigInt(1)}\nvar rest=a-quotient*b\nreturn $B.fast_tuple([from_BigInt(quotient),from_BigInt(rest)])}\nlong_int.__eq__=function(self,other){if(typeof other==\"number\"){other=long_int.$factory(_b_.str.$factory(other))}\nreturn self.value==other.value && self.pos==other.pos}\nlong_int.__float__=function(self){if(! isFinite(parseFloat(self.value))){throw _b_.OverflowError.$factory(\"int too big to convert to float\")}\nreturn new Number((self.pos ? 1 :-1)*parseFloat(self.value))}\nlong_int.__floordiv__=function(self,other){if(_b_.isinstance(other,_b_.float)){return _b_.float.$factory(to_int(self)/other)}\nif(typeof other==\"number\" && Math.abs(other)< $B.max_safe_divider){var t=self.value,res=divmod_by_safe_int(t,other),pos=other > 0 ? self.pos :!self.pos\nreturn{__class__:long_int,value:res[0],pos:pos}}\nvar res=intOrLong(long_int.__divmod__(self,other)[0])\nreturn res}\nlong_int.__ge__=function(self,other){if(typeof other==\"number\"){other=long_int.$factory(_b_.str.$factory(other))}\nif(self.pos !=other.pos){return ! other.pos}\nif(self.value.length > other.value.length){return self.pos}\nelse if(self.value.length < other.value.length){return ! self.pos}\nelse{return self.pos ? self.value >=other.value :\nself.value <=other.value}}\nlong_int.__gt__=function(self,other){return ! long_int.__le__(self,other)}\nlong_int.__hash__=function(self){var modulus=$B.fast_long_int(\"2305843009213693951\",true),self_pos=$B.fast_long_int(self.value,true)\nvar _hash=$B.long_int.__mod__(self_pos,modulus)\nif(typeof _hash==\"number\"){_hash=self.pos ? _hash :-_hash}else{_hash.pos=self.pos}\nreturn self.__hashvalue__=_hash}\nlong_int.__index__=function(self){\nvar res='',temp=self.value,d\nwhile(true){d=divmod_pos(temp,\"2\")\nres=d[1].value+res\ntemp=d[0].value\nif(temp==\"0\"){break}}\nif(! self.pos){\nvar nres=\"\",flag=false\nfor(var len=res.length-1,i=len;i >=0 ;i--){var bit=res.charAt(i)\nif(bit==\"0\"){if(flag){nres=\"1\"+nres}else{nres=\"0\"+nres}}else{if(flag){nres=\"0\"+nres}\nelse{flag=true;nres=\"1\"+nres}}}\nnres=\"1\"+nres\nres=nres}else{res=\"0\"+res}\nreturn intOrLong(res)}\nlong_int.__invert__=function(self){return long_int.__sub__(long_int.$factory(\"-1\"),self)}\nlong_int.__le__=function(self,other){if(typeof other==\"number\"){other=long_int.$factory(_b_.str.$factory(other))}\nif(self.pos !==other.pos){return ! self.pos}\nif(self.value.length > other.value.length){return ! self.pos}\nelse if(self.value.length < other.value.length){return self.pos}\nelse{return self.pos ? self.value <=other.value :\nself.value >=other.value}}\nlong_int.__lt__=function(self,other){return !long_int.__ge__(self,other)}\nlong_int.__lshift__=function(self,shift){if(shift.__class__==long_int){shift=shift.value}\nreturn intOrLong({__class__:long_int,value:(BigInt(self.value)<< BigInt(shift)).toString(),pos:self.pos})}\nlong_int.__mod__=function(self,other){return intOrLong(long_int.__divmod__(self,other)[1])}\nlong_int.__mro__=[_b_.int,_b_.object]\nlong_int.__mul__=function(self,other){switch(self){case Number.NEGATIVE_INFINITY:\ncase Number.POSITIVE_INFINITY:\nif($B.rich_comp(\"__eq__\",other,0)){return NaN}\nelse if(_b_.getattr(other,\"__gt__\")(0)){return self}\nelse{return-self}}\nif(_b_.isinstance(other,_b_.float)){return _b_.float.$factory(to_int(self)*other)}\nif(typeof other==\"number\"){other=long_int.$factory(other)}\nother_value=other.value\nother_pos=other.pos\nif(other.__class__ !==long_int && _b_.isinstance(other,_b_.int)){\nvar value=_b_.int.__index__(other)\nother_value=_b_.str.$factory(value)\nother_pos=value > 0}\nreturn from_BigInt(to_BigInt(self)*to_BigInt(other))}\nlong_int.__ne__=function(self,other){var res=long_int.__eq__(self,other)\nreturn res===_b_.NotImplemented ? res :!res}\nlong_int.__neg__=function(obj){return{__class__:long_int,value:obj.value,pos:! obj.pos}}\nlong_int.__or__=function(self,other){other=long_int.$factory(other)\nvar v1=long_int.__index__(self)\nvar v2=long_int.__index__(other)\nif(v1.length < v2.length){var temp=v2;v2=v1;v1=temp}\nvar start=v1.length-v2.length\nvar res=v1.substr(0,start)\nfor(var i=0;i < v2.length;i++){if(v1.charAt(start+i)==\"1\" ||v2.charAt(i)==\"1\"){res+=\"1\"}\nelse{res+=\"0\"}}\nreturn intOrLong(long_int.$factory(res,2))}\nlong_int.__pos__=function(self){return self}\nlong_int.__pow__=function(self,power,z){if(typeof power==\"number\"){power=long_int.$from_int(power)}else if(_b_.isinstance(power,_b_.int)){\npower=long_int.$factory(_b_.str.$factory(_b_.int.__index__(power)))}else if(! _b_.isinstance(power,long_int)){var msg=\"power must be an integer, not '\"\nthrow _b_.TypeError.$factory(msg+$B.class_name(power)+\"'\")}\nif(! power.pos){if(self.value==\"1\"){return self}\nreturn long_int.$factory(\"0\")}else if(power.value==\"0\"){return long_int.$factory(\"1\")}\nvar s=$B.BigInt(self.value),b=$B.BigInt(1),x=$B.BigInt(power.value),z=z===undefined ? z :typeof z==\"number\" ? $B.BigInt(z):\n$B.BigInt(z.value)\nif(z===undefined){return{\n__class__:long_int,value:(s**x).toString(),pos:true}}\nwhile(x > 0){if(x % $B.BigInt(2)==1){b=b*s}\nx=x/$B.BigInt(2)\nif(x > 0){s=s*s}\nif(z !==undefined){b=b % z}}\nreturn{__class__:long_int,value:b.toString(),pos:true}}\nlong_int.__rshift__=function(self,shift){if(shift.__class__===long_int){shift=shift.value}\nreturn intOrLong(\n{__class__:long_int,value:(BigInt(self.value)>> BigInt(shift)).toString(),pos:self.pos}\n)}\nlong_int.__str__=long_int.__repr__=function(self){var res=\"\"\nif(! self.pos){res+='-'}\nreturn res+self.value}\nlong_int.__sub__=function(self,other){if(_b_.isinstance(other,_b_.float)){other=other instanceof Number ? other :other.$brython_value\nreturn _b_.float.$factory(to_int(self)-other)}\nif(typeof other==\"number\"){other=long_int.$factory(_b_.str.$factory(other))}\nif($B.BigInt){}\nvar res\nif(self.pos && other.pos){switch(comp_pos(self.value,other.value)){case 1:\nres=sub_pos(self.value,other.value)\nbreak\ncase 0:\nres={__class__:long_int,value:\"0\",pos:true}\nbreak\ncase-1:\nres=sub_pos(other.value,self.value)\nres.pos=false\nbreak}\nreturn intOrLong(res)}else if(! self.pos && ! other.pos){switch(comp_pos(self.value,other.value)){case 1:\nres=sub_pos(self.value,other.value)\nres.pos=false\nbreak\ncase 0:\nres={__class__:long_int,value:\"0\",pos:true}\nbreak\ncase-1:\nres=sub_pos(other.value,self.value)\nbreak}\nreturn intOrLong(res)}else if(self.pos && ! other.pos){return intOrLong(add_pos(self.value,other.value))}else{res=add_pos(self.value,other.value)\nres.pos=false\nreturn intOrLong(res)}}\nlong_int.__truediv__=function(self,other){if(_b_.isinstance(other,long_int)){return _b_.float.$factory(to_int(self)/to_int(other))}else if(_b_.isinstance(other,_b_.int)){return _b_.float.$factory(to_int(self)/other)}else if(_b_.isinstance(other,_b_.float)){return _b_.float.$factory(to_int(self)/other)}else{throw _b_.TypeError.$factory(\n\"unsupported operand type(s) for /: 'int' and '\"+\n$B.class_name(other)+\"'\")}}\nlong_int.__xor__=function(self,other){other=long_int.$factory(other)\nvar v1=long_int.__index__(self),v2=long_int.__index__(other)\nif(v1.length < v2.length){var temp=v2;v2=v1;v1=temp}\nvar start=v1.length-v2.length\nvar res=v1.substr(0,start)\nfor(var i=0;i < v2.length;i++){if(v1.charAt(start+i)==\"1\" && v2.charAt(i)==\"0\"){res+=\"1\"}\nelse if(v1.charAt(start+i)==\"0\" && v2.charAt(i)==\"1\"){res+=\"1\"}\nelse{res+=\"0\"}}\nreturn intOrLong(long_int.$factory(res,2))}\nlong_int.bit_length=function(self){return binary(self).length}\nfunction _infos(self){\nvar nbits=$B.long_int.bit_length(self),pow2=2n**BigInt(nbits-1),rest=BigInt(self.value)-pow2,relative_rest=new Number(rest)/new Number(pow2)\nreturn{nbits,pow2,rest,relative_rest}}\nlong_int.$log2=function(x){if(! x.pos){throw _b_.ValueError.$factory('math domain error')}\nvar infos=_infos(x)\nreturn _b_.float.$factory(infos.nbits-1+\nMath.log(1+infos.relative_rest/Math.LN2))}\nlong_int.$log10=function(x){if(! x.pos){throw _b_.ValueError.$factory('math domain error')}\nvar exp=x.value.length-1,mant=eval(x.value[0]+'.'+x.value.substr(1))\nreturn _b_.float.$factory(exp+Math.log10(mant))}\nlong_int.numerator=function(self){return self}\nlong_int.denominator=function(self){return _b_.int.$factory(1)}\nlong_int.imag=function(self){return _b_.int.$factory(0)}\nlong_int.real=function(self){return self}\nlong_int.to_base=function(self,base){\nif(base==2){return binary_pos(self.value)}\nvar res=\"\",v=self.value\nwhile(v > 0){var dm=divmod_pos(v,base.toString())\nres=parseInt(dm[1].value).toString(base)+res\nv=dm[0].value\nif(v==0){break}}\nreturn res}\nlong_int.to_bytes=function(self,len,byteorder,signed){\nvar res=[],v=self.value\nif(! $B.$bool(signed)&& ! self.pos){throw _b_.OverflowError.$factory(\"can't convert negative int to unsigned\")}\nwhile(v > 0){var dm=divmod_pos(v,256)\nv=parseInt(dm[0].value)\nres.push(parseInt(dm[1].value))\nif(res.length > len){throw _b_.OverflowError.$factory(\"int too big to convert\")}}\nwhile(res.length < len){res.push(0)}\nif(byteorder=='big'){res.reverse()}\nreturn _b_.bytes.$factory(res)}\nfunction digits(base){\nvar is_digits={}\nfor(var i=0;i < base;i++){if(i==10){break}\nis_digits[i]=true}\nif(base > 10){\nfor(var i=0;i < base-10;i++){is_digits[String.fromCharCode(65+i)]=true\nis_digits[String.fromCharCode(97+i)]=true}}\nreturn is_digits}\nvar MAX_SAFE_INTEGER=Math.pow(2,53)-1\nvar MIN_SAFE_INTEGER=-MAX_SAFE_INTEGER\nfunction isSafeInteger(n){return(typeof n===\"number\" &&\nMath.round(n)===n &&\nMIN_SAFE_INTEGER <=n &&\nn <=MAX_SAFE_INTEGER)}\nfunction intOrLong(long){\nvar v=parseInt(long.value)*(long.pos ? 1 :-1)\nif(v > MIN_SAFE_INTEGER && v < MAX_SAFE_INTEGER){return v}\nreturn long}\nlong_int.$from_int=function(value){return{__class__:long_int,value:value.toString(),pos:value > 0}}\nlong_int.$factory=function(value,base){if(arguments.length > 2){throw _b_.TypeError.$factory(\"long_int takes at most 2 arguments (\"+\narguments.length+\" given)\")}\nif(base===undefined){base=10}\nelse if(! _b_.isinstance(base,_b_.int)){throw _b_.TypeError.$factory(\"'\"+$B.class_name(base)+\n\"' object cannot be interpreted as an integer\")}\nif(base < 0 ||base==1 ||base > 36){throw _b_.ValueError.$factory(\n\"long_int.$factory() base must be >= 2 and <= 36\")}\nif(typeof value==\"number\"){var pos=value >=0,value=Math.abs(value),res\nif(isSafeInteger(value)){res=long_int.$from_int(value)}\nelse if(value.constructor==Number){var s=value.toString(),pos_exp=s.search(\"e\")\nif(pos_exp >-1){var mant=s.substr(0,pos_exp),exp=parseInt(s.substr(pos_exp+1)),point=mant.search(/\\./)\nif(point >-1){var nb_dec=mant.substr(point+1).length\nif(nb_dec > exp){var res=mant.substr(0,point)+\nmant.substr(point+1).substr(0,exp)\nres=long_int.$from_int(res)}else{var res=mant.substr(0,point)+\nmant.substr(point+1)+'0'.repeat(exp-nb_dec)\nres=long_int.$from_int(res)}}else{res=long_int.$from_int(mant+'0'.repeat(exp))}}else{var point=s.search(/\\./)\nif(point >-1){res=long_int.$from_int(s.substr(0,point))}else{res=long_int.$from_int(s)}}}\nelse{throw _b_.ValueError.$factory(\n\"argument of long_int is not a safe integer\")}\nres.pos=pos\nreturn res}else if(_b_.isinstance(value,_b_.float)){if(value===Number.POSITIVE_INFINITY ||\nvalue===Number.NEGATIVE_INFINITY){return value}\nif(value >=0){value=new Number(Math.round(value.value))}\nelse{value=new Number(Math.ceil(value.value))}}else if(_b_.isinstance(value,_b_.bool)){if(value.valueOf()){return _b_.int.$factory(1)}\nreturn _b_.int.$factory(0)}else if(value.__class__===long_int){return value}else if(_b_.isinstance(value,_b_.int)){\nvalue=value.$brython_value+\"\"}else if(_b_.isinstance(value,_b_.bool)){value=_b_.bool.__int__(value)+\"\"}else if(typeof value !=\"string\"){throw _b_.ValueError.$factory(\n\"argument of long_int must be a string, not \"+\n$B.class_name(value))}\nvar has_prefix=false,pos=true,start=0\nwhile(value.charAt(0)==\" \" && value.length){value=value.substr(1)}\nwhile(value.charAt(value.length-1)==\" \" && value.length){value=value.substr(0,value.length-1)}\nif(value.charAt(0)==\"+\"){has_prefix=true}\nelse if(value.charAt(0)==\"-\"){has_prefix=true;pos=false}\nif(has_prefix){\nif(value.length==1){\nthrow _b_.ValueError.$factory(\n'long_int argument is not a valid number: \"'+value+'\"')}else{value=value.substr(1)}}\nwhile(start < value.length-1 && value.charAt(start)==\"0\"){start++}\nvalue=value.substr(start)\nvar is_digits=digits(base),point=-1\nfor(var i=0;i < value.length;i++){if(value.charAt(i)==\".\" && point==-1){point=i}else if(false){ var mant; }\nelse if(! is_digits[value.charAt(i)]){throw _b_.ValueError.$factory(\n'long_int argument is not a valid number: \"'+value+'\"')}}\nif(point !=-1){value=value.substr(0,point)}\nif(base !=10){\nvar coef=\"1\",v10=long_int.$factory(0),ix=value.length\nwhile(ix--){var digit_base10=parseInt(value.charAt(ix),base).toString(),digit_by_coef=mul_pos(coef,digit_base10).value\nv10=add_pos(v10.value,digit_by_coef)\ncoef=mul_pos(coef,base.toString()).value}\nreturn v10}\nreturn{__class__:long_int,value:value,pos:pos}}\nfunction extended_euclidean_algorithm(a,b){\nvar s=0,old_s=1,t=1,old_t=0,r=b,old_r=a,quotient,tmp\nwhile($B.rich_comp('__ne__',r,0)){quotient=$B.rich_op('floordiv',old_r,r)\ntmp=$B.rich_op('sub',old_r,$B.rich_op('mul',quotient,r))\nold_r=r\nr=tmp\ntmp=$B.rich_op('sub',old_s,$B.rich_op('mul',quotient,s))\nold_s=s\ns=tmp\ntmp=$B.rich_op('sub',old_t,$B.rich_op('mul',quotient,t))\nold_t=t\nt=tmp}\nreturn[old_r,old_s,old_t]}\nfunction inverse_of(n,p){\nvar gcd,x,y\n[gcd,x,y]=extended_euclidean_algorithm(n,p)\nif($B.rich_comp('__ne__',gcd,1)){\nthrow Error(\n`${n} has no multiplicative inverse '\n            'modulo ${p}`)}else{return $B.rich_op('mod',x,p)}}\n$B.inverse_of=inverse_of\n$B.set_func_names(long_int,\"builtins\")\n$B.long_int=long_int\n$B.fast_long_int=function(value,pos){return{__class__:$B.long_int,value:value,pos:pos}}})(__BRYTHON__)\n;\n;(function($B){var _b_=$B.builtins\nvar object=_b_.object\nfunction $err(op,other){var msg=\"unsupported operand type(s) for \"+op+\n\": 'float' and '\"+$B.class_name(other)+\"'\"\nthrow _b_.TypeError.$factory(msg)}\nfunction float_value(obj){\nreturn obj.$brython_value !==undefined ? obj.$brython_value :obj}\nvar float={__class__:_b_.type,__dir__:object.__dir__,$infos:{__module__:\"builtins\",__name__:\"float\"},$is_class:true,$native:true,$descriptors:{\"numerator\":true,\"denominator\":true,\"imag\":true,\"real\":true}}\nfloat.numerator=function(self){return float_value(self)}\nfloat.denominator=function(self){return _b_.int.$factory(1)}\nfloat.imag=function(self){return _b_.int.$factory(0)}\nfloat.real=function(self){return float_value(self)}\nfloat.__float__=function(self){return float_value(self)}\n$B.shift1_cache={}\nfloat.as_integer_ratio=function(self){self=float_value(self)\nif(self.valueOf()==Number.POSITIVE_INFINITY ||\nself.valueOf()==Number.NEGATIVE_INFINITY){throw _b_.OverflowError.$factory(\"Cannot pass infinity to \"+\n\"float.as_integer_ratio.\")}\nif(! Number.isFinite(self.valueOf())){throw _b_.ValueError.$factory(\"Cannot pass NaN to \"+\n\"float.as_integer_ratio.\")}\nvar tmp=_b_.$frexp(self.valueOf()),fp=tmp[0],exponent=tmp[1]\nfor(var i=0;i < 300;i++){if(fp==Math.floor(fp)){break}else{fp*=2\nexponent--}}\nnumerator=_b_.int.$factory(fp)\npy_exponent=_b_.abs(exponent)\ndenominator=1\nvar x\nif($B.shift1_cache[py_exponent]!==undefined){x=$B.shift1_cache[py_exponent]}else{x=$B.$getattr(1,\"__lshift__\")(py_exponent)\n$B.shift1_cache[py_exponent]=x}\npy_exponent=x\nif(exponent > 0){numerator=$B.rich_op(\"mul\",numerator,py_exponent)}else{denominator=py_exponent}\nreturn $B.fast_tuple([_b_.int.$factory(numerator),_b_.int.$factory(denominator)])}\nfloat.__abs__=function(self){return new Number(Math.abs(float_value(self)))}\nfloat.__bool__=function(self){self=float_value(self)\nreturn _b_.bool.$factory(self.valueOf())}\nfloat.__divmod__=function(self,other){if(! _b_.isinstance(other,[_b_.int,float])){return _b_.NotImplemented}\nreturn $B.fast_tuple([float.__floordiv__(self,other),float.__mod__(self,other)])}\nfloat.__eq__=function(self,other){self=float_value(self)\nother=float_value(other)\nif(isNaN(self)&& isNaN(other)){return false}\nif(_b_.isinstance(other,_b_.int)){return self==other}\nif(_b_.isinstance(other,float)){\nreturn self.valueOf()==other.valueOf()}\nif(_b_.isinstance(other,_b_.complex)){if(other.$imag !=0){return false}\nreturn self==other.$real}\nreturn _b_.NotImplemented}\nfloat.__floordiv__=function(self,other){self=float_value(self)\nother=float_value(other)\nif(_b_.isinstance(other,[_b_.int,float])){if(other.valueOf()==0){throw _b_.ZeroDivisionError.$factory('division by zero')}\nreturn float.$factory(Math.floor(self/other))}\nreturn _b_.NotImplemented}\nfloat.fromhex=function(arg){\nif(! _b_.isinstance(arg,_b_.str)){throw _b_.ValueError.$factory(\"argument must be a string\")}\nvar value=arg.trim()\nswitch(value.toLowerCase()){case \"+inf\":\ncase \"inf\":\ncase \"+infinity\":\ncase \"infinity\":\nreturn $FloatClass(Infinity)\ncase \"-inf\":\ncase \"-infinity\":\nreturn $FloatClass(-Infinity)\ncase \"+nan\":\ncase \"nan\":\nreturn $FloatClass(Number.NaN)\ncase \"-nan\":\nreturn $FloatClass(-Number.NaN)\ncase \"\":\nthrow _b_.ValueError.$factory(\"could not convert string to float\")}\nvar mo=/^(\\d*)(\\.?)(\\d*)$/.exec(value)\nif(mo !==null){var res=parseFloat(mo[1]),coef=16\nif(mo[2]){for(var digit of mo[3]){res+=parseInt(digit,16)/coef\ncoef*=16}}\nreturn $FloatClass(res)}\nvar _m=/^(\\+|-)?(0x)?([0-9A-F]+\\.?)?(\\.[0-9A-F]+)?(p(\\+|-)?\\d+)?$/i.exec(value)\nif(_m==null){throw _b_.ValueError.$factory(\"invalid hexadecimal floating-point string\")}\nvar _sign=_m[1],_int=parseInt(_m[3]||'0',16),_fraction=_m[4]||'.0',_exponent=_m[5]||'p0'\nif(_sign==\"-\"){_sign=-1}else{_sign=1}\nvar _sum=_int\nfor(var i=1,len=_fraction.length;i < len;i++){_sum+=parseInt(_fraction.charAt(i),16)/Math.pow(16,i)}\nreturn new Number(_sign*_sum*Math.pow(2,parseInt(_exponent.substring(1))))}\nfloat.__getformat__=function(arg){if(arg==\"double\" ||arg==\"float\"){return \"IEEE, little-endian\"}\nthrow _b_.ValueError.$factory(\"__getformat__() argument 1 must be \"+\n\"'double' or 'float'\")}\nfunction preformat(self,fmt){if(fmt.empty){return _b_.str.$factory(self)}\nif(fmt.type && 'eEfFgGn%'.indexOf(fmt.type)==-1){throw _b_.ValueError.$factory(\"Unknown format code '\"+fmt.type+\n\"' for object of type 'float'\")}\nif(isNaN(self)){if(fmt.type==\"f\" ||fmt.type==\"g\"){return \"nan\"}\nelse{return \"NAN\"}}\nif(self==Number.POSITIVE_INFINITY){if(fmt.type==\"f\" ||fmt.type==\"g\"){return \"inf\"}\nelse{return \"INF\"}}\nif(fmt.precision===undefined && fmt.type !==undefined){fmt.precision=6}\nif(fmt.type==\"%\"){self*=100}\nif(fmt.type==\"e\"){var res=self.toExponential(fmt.precision),exp=parseInt(res.substr(res.search(\"e\")+1))\nif(Math.abs(exp)< 10){res=res.substr(0,res.length-1)+\"0\"+\nres.charAt(res.length-1)}\nreturn res}\nif(fmt.precision !==undefined){\nvar prec=fmt.precision\nif(prec==0){return Math.round(self)+\"\"}\nvar res=self.toFixed(prec),pt_pos=res.indexOf(\".\")\nif(fmt.type !==undefined &&\n(fmt.type==\"%\" ||fmt.type.toLowerCase()==\"f\")){if(pt_pos==-1){res+=\".\"+\"0\".repeat(fmt.precision)}else{var missing=fmt.precision-res.length+pt_pos+1\nif(missing > 0){res+=\"0\".repeat(missing)}}}else if(fmt.type && fmt.type.toLowerCase()==\"g\"){var exp_fmt=preformat(self,{type:\"e\"}).split(\"e\"),exp=parseInt(exp_fmt[1])\nif(-4 <=exp && exp < fmt.precision){res=preformat(self,{type:\"f\",precision:fmt.precision-1-exp})}else{res=preformat(self,{type:\"e\",precision:fmt.precision-1})}\nvar parts=res.split(\"e\")\nif(fmt.alternate){if(parts[0].search(/\\./)==-1){parts[0]+='.'}}else{if(parts[1]){var signif=parts[0]\nwhile(signif.endsWith(\"0\")){signif=signif.substr(0,signif.length-1)}\nif(signif.endsWith(\".\")){signif=signif.substr(0,signif.length-1)}\nparts[0]=signif}}\nres=parts.join(\"e\")\nif(fmt.type==\"G\"){res=res.toUpperCase()}\nreturn res}else if(fmt.type===undefined){fmt.type=\"g\"\nres=preformat(self,fmt)\nfmt.type=undefined}else{var res1=self.toExponential(fmt.precision-1),exp=parseInt(res1.substr(res1.search(\"e\")+1))\nif(exp <-4 ||exp >=fmt.precision-1){var elts=res1.split(\"e\")\nwhile(elts[0].endsWith(\"0\")){elts[0]=elts[0].substr(0,elts[0].length-1)}\nres=elts.join(\"e\")}}}else{var res=_b_.str.$factory(self)}\nif(fmt.type===undefined ||\"gGn\".indexOf(fmt.type)!=-1){\nif(res.search(\"e\")==-1){while(res.charAt(res.length-1)==\"0\"){res=res.substr(0,res.length-1)}}\nif(res.charAt(res.length-1)==\".\"){if(fmt.type===undefined){res+=\"0\"}\nelse{res=res.substr(0,res.length-1)}}}\nif(fmt.sign !==undefined){if((fmt.sign==\" \" ||fmt.sign==\"+\" )&& self > 0){res=fmt.sign+res}}\nif(fmt.type==\"%\"){res+=\"%\"}\nreturn res}\nfloat.__format__=function(self,format_spec){self=float_value(self)\nvar fmt=new $B.parse_format_spec(format_spec)\nfmt.align=fmt.align ||\">\"\nvar raw=preformat(self,fmt).split('.'),_int=raw[0]\nif(fmt.comma){var len=_int.length,nb=Math.ceil(_int.length/3),chunks=[]\nfor(var i=0;i < nb;i++){chunks.push(_int.substring(len-3*i-3,len-3*i))}\nchunks.reverse()\nraw[0]=chunks.join(\",\")}\nreturn $B.format_width(raw.join(\".\"),fmt)}\nfloat.__hash__=function(self){if(self===undefined){return float.__hashvalue__ ||$B.$py_next_hash--}\nvar _v=self.valueOf()\nif(_v===Infinity){return 314159}\nif(_v===-Infinity){return-271828}\nif(isNaN(_v)){return 0}\nif(_v==Math.round(_v)){return Math.round(_v)}\nvar r=_b_.$frexp(_v)\nr[0]*=Math.pow(2,31)\nvar hipart=_b_.int.$factory(r[0])\nr[0]=(r[0]-hipart)*Math.pow(2,31)\nvar x=hipart+_b_.int.$factory(r[0])+(r[1]<< 15)\nreturn x & 0xFFFFFFFF}\n_b_.$isninf=function(x){var x1=x\nif(_b_.isinstance(x,float)){x1=float.numerator(x)}\nreturn x1==-Infinity ||x1==Number.NEGATIVE_INFINITY}\n_b_.$isinf=function(x){var x1=x\nif((! x instanceof Number)&& _b_.isinstance(x,float)){x1=float.numerator(x)}\nreturn x1==Infinity ||x1==-Infinity ||\nx1==Number.POSITIVE_INFINITY ||x1==Number.NEGATIVE_INFINITY}\n_b_.$isnan=function(x){var x1=x\nif(_b_.isinstance(x,float)){x1=float.numerator(x)}\nreturn isNaN(x1)}\n_b_.$fabs=function(x){if(x==0){return new Number(0)}\nreturn x > 0 ? float.$factory(x):float.$factory(-x)}\n_b_.$frexp=function(x){var x1=x\nif(_b_.isinstance(x,float)){x1=x.valueOf()}\nif(isNaN(x1)||_b_.$isinf(x1)){return[x1,-1]}else if(x1==0){return[0,0]}\nvar sign=1,ex=0,man=x1\nif(man < 0.){sign=-sign\nman=-man}\nwhile(man < 0.5){man*=2.0\nex--}\nwhile(man >=1.0){man*=0.5\nex++}\nman*=sign\nreturn[man,ex]}\n_b_.$ldexp=function(x,i){if(_b_.$isninf(x)){return float.$factory('-inf')}\nif(_b_.$isinf(x)){return float.$factory('inf')}\nvar y=x\nif(_b_.isinstance(x,float)){y=x.valueOf()}\nif(y==0){return y}\nvar j=i\nif(_b_.isinstance(i,float)){j=i.valueOf()}\nreturn y*Math.pow(2,j)}\nfloat.hex=function(self){\nself=float_value(self)\nvar DBL_MANT_DIG=53,\nTOHEX_NBITS=DBL_MANT_DIG+3-(DBL_MANT_DIG+2)% 4\nswitch(self.valueOf()){case Infinity:\ncase-Infinity:\ncase Number.NaN:\ncase-Number.NaN:\nreturn self\ncase-0:\nreturn \"-0x0.0p0\"\ncase 0:\nreturn \"0x0.0p0\"}\nvar _a=_b_.$frexp(_b_.$fabs(self.valueOf())),_m=_a[0],_e=_a[1],_shift=1-Math.max(-1021-_e,0)\n_m=_b_.$ldexp(_m,_shift)\n_e-=_shift\nvar _int2hex=\"0123456789ABCDEF\".split(\"\"),_s=_int2hex[Math.floor(_m)]\n_s+='.'\n_m-=Math.floor(_m)\nfor(var i=0;i <(TOHEX_NBITS-1)/4;i++){_m*=16.0\n_s+=_int2hex[Math.floor(_m)]\n_m-=Math.floor(_m)}\nvar _esign=\"+\"\nif(_e < 0){_esign=\"-\"\n_e=-_e}\nif(self.value < 0){return \"-0x\"+_s+\"p\"+_esign+_e}\nreturn \"0x\"+_s+\"p\"+_esign+_e}\nfloat.__init__=function(self,value){return _b_.None}\nfloat.__int__=function(self){return parseInt(self)}\nfloat.is_integer=function(self){return _b_.int.$factory(self)==self}\nfloat.__mod__=function(self,other){\nself=float_value(self)\nother=float_value(other)\nif(other==0){throw _b_.ZeroDivisionError.$factory(\"float modulo\")}\nif(_b_.isinstance(other,_b_.int)){other=_b_.int.numerator(other)\nreturn new Number((self % other+other)% other)}\nif(_b_.isinstance(other,float)){\nvar q=Math.floor(self/other),r=self-other*q\nreturn new Number(r)}\nreturn _b_.NotImplemented}\nfloat.__mro__=[object]\nfloat.__mul__=function(self,other){self=float_value(self)\nother=float_value(other)\nif(_b_.isinstance(other,_b_.int)){if(other.__class__==$B.long_int){return new Number(self*parseFloat(other.value))}\nother=_b_.int.numerator(other)\nreturn new Number(self*other)}\nif(_b_.isinstance(other,float)){return new Number(self*float_value(other))}\nreturn _b_.NotImplemented}\nfloat.__ne__=function(self,other){var res=float.__eq__(self,other)\nreturn res===_b_.NotImplemented ? res :! res}\nfloat.__neg__=function(self){return new Number(-float_value(self))}\nfloat.__new__=function(cls,value){if(cls===undefined){throw _b_.TypeError.$factory(\"float.__new__(): not enough arguments\")}else if(! _b_.isinstance(cls,_b_.type)){throw _b_.TypeError.$factory(\"float.__new__(X): X is not a type object\")}\nif(cls===float){return float.$factory(value)}\nreturn{\n__class__:cls,__dict__:$B.empty_dict(),$brython_value:value ||0}}\nfloat.__pos__=function(self){return float_value(self)}\nfloat.__pow__=function(self,other){self=float_value(self)\nother=float_value(other)\nvar other_int=_b_.isinstance(other,_b_.int)\nif(other_int ||_b_.isinstance(other,float)){if(self==1){return new Number(1)}\nif(other==0){return new Number(1)}\nif(self==-1 &&\n(! isFinite(other)||other.__class__===$B.long_int ||\n! $B.is_safe_int(other))&&\n! isNaN(other)){return new Number(1)}else if(self==0 && isFinite(other)&& other < 0){throw _b_.ZeroDivisionError.$factory(\"0.0 cannot be raised \"+\n\"to a negative power\")}else if(self==Number.NEGATIVE_INFINITY && ! isNaN(other)){if(other < 0 && other % 2==1){return new Number(-0.0)}else if(other < 0){return new Number(0)}\nelse if(other > 0 && other % 2==1){return Number.NEGATIVE_INFINITY}else{return Number.POSITIVE_INFINITY}}else if(self==Number.POSITIVE_INFINITY && ! isNaN(other)){return other > 0 ? self :new Number(0)}\nif(other==Number.NEGATIVE_INFINITY && ! isNaN(self)){return Math.abs(self)< 1 ? Number.POSITIVE_INFINITY :\nnew Number(0)}else if(other==Number.POSITIVE_INFINITY && ! isNaN(self)){return Math.abs(self)< 1 ? new Number(0):\nNumber.POSITIVE_INFINITY}\nif(self < 0 &&\n! $B.$getattr(other,\"__eq__\")(_b_.int.$factory(other))){\nreturn _b_.complex.__pow__($B.make_complex(self,0),other)}\nreturn float.$factory(Math.pow(self,other))}\nreturn _b_.NotImplemented}\nfunction __newobj__(){\nvar $=$B.args('__newobj__',0,{},[],arguments,{},'args',null),args=$.args\nvar res=args.slice(1)\nres.__class__=args[0]\nreturn res}\nfloat.__reduce_ex__=function(self){return $B.fast_tuple([__newobj__,$B.fast_tuple([self.__class__ ||_b_.int,float_value(self)]),_b_.None,_b_.None,_b_.None])}\nfloat.__repr__=function(self){$B.builtins_repr_check(float,arguments)\nself=float_value(self).valueOf()\nif(self==Infinity){return 'inf'}else if(self==-Infinity){return '-inf'}else if(isNaN(self)){return 'nan'}else if(self===0){if(1/self===-Infinity){return '-0.0'}\nreturn '0.0'}\nvar res=self+\"\" \nif(res.search(/[.eE]/)==-1){res+=\".0\"}\nvar split_e=res.split(/e/i)\nif(split_e.length==2){var mant=split_e[0],exp=split_e[1]\nif(exp.startsWith('-')){exp_str=parseInt(exp.substr(1))+''\nif(exp_str.length < 2){exp_str='0'+exp_str}\nreturn mant+'e-'+exp_str}}\nvar x,y\n[x,y]=res.split('.')\nvar sign=''\nif(x[0]=='-'){x=x.substr(1)\nsign='-'}\nif(x.length > 16){var exp=x.length-1,int_part=x[0],dec_part=x.substr(1)+y\nwhile(dec_part.endsWith(\"0\")){dec_part=dec_part.substr(0,dec_part.length-1)}\nvar mant=int_part\nif(dec_part.length > 0){mant+='.'+dec_part}\nreturn sign+mant+'e+'+exp}else if(x==\"0\"){var exp=0\nwhile(exp < y.length && y.charAt(exp)==\"0\"){exp++}\nif(exp > 3){\nvar rest=y.substr(exp),exp=(exp+1).toString()\nwhile(rest.endsWith(\"0\")){rest=rest.substr(0,res.length-1)}\nvar mant=rest[0]\nif(rest.length > 1){mant+='.'+rest.substr(1)}\nif(exp.length==1){exp='0'+exp}\nreturn sign+mant+'e-'+exp}}\nreturn _b_.str.$factory(res)}\nfloat.__setattr__=function(self,attr,value){if(self.constructor===Number){if(float[attr]===undefined){throw _b_.AttributeError.$factory(\"'float' object has no attribute '\"+\nattr+\"'\")}else{throw _b_.AttributeError.$factory(\"'float' object attribute '\"+\nattr+\"' is read-only\")}}\nself[attr]=value\nreturn _b_.None}\nfloat.__truediv__=function(self,other){self=float_value(self)\nother=float_value(other)\nif(_b_.isinstance(other,[_b_.int,float])){if(other.valueOf()==0){throw _b_.ZeroDivisionError.$factory(\"division by zero\")}\nreturn float.$factory(self/other)}\nreturn _b_.NotImplemented}\nvar $op_func=function(self,other){self=float_value(self)\nother=float_value(other)\nif(_b_.isinstance(other,_b_.int)){if(typeof other==\"boolean\"){return other ? self-1 :self}else if(other.__class__===$B.long_int){return float.$factory(self-parseInt(other.value))}else{return float.$factory(self-other)}}\nif(_b_.isinstance(other,float)){return float.$factory(self-other)}\nreturn _b_.NotImplemented}\n$op_func+=\"\" \nvar $ops={\"+\":\"add\",\"-\":\"sub\"}\nfor(var $op in $ops){var $opf=$op_func.replace(/-/gm,$op)\n$opf=$opf.replace(/__rsub__/gm,\"__r\"+$ops[$op]+\"__\")\neval(\"float.__\"+$ops[$op]+\"__ = \"+$opf)}\nvar $comp_func=function(self,other){self=float_value(self)\nother=float_value(other)\nif(_b_.isinstance(other,_b_.int)){if(other.__class__===$B.long_int){return self > parseInt(other.value)}\nreturn self > other.valueOf()}\nif(_b_.isinstance(other,float)){return self > other}\nif(_b_.isinstance(other,_b_.bool)){return self.valueOf()> _b_.bool.__hash__(other)}\nif(_b_.hasattr(other,\"__int__\")||_b_.hasattr(other,\"__index__\")){return _b_.int.__gt__(self,$B.$GetInt(other))}\nvar inv_op=$B.$getattr(other,\"__le__\",_b_.None)\nif(inv_op !==_b_.None){return inv_op(self)}\nthrow _b_.TypeError.$factory(\n\"unorderable types: float() > \"+$B.class_name(other)+\"()\")}\n$comp_func+=\"\" \nfor(var $op in $B.$comps){eval(\"float.__\"+$B.$comps[$op]+\"__ = \"+\n$comp_func.replace(/>/gm,$op).\nreplace(/__gt__/gm,\"__\"+$B.$comps[$op]+\"__\").\nreplace(/__le__/,\"__\"+$B.$inv_comps[$op]+\"__\"))}\nvar r_opnames=[\"add\",\"sub\",\"mul\",\"truediv\",\"floordiv\",\"mod\",\"pow\",\"lshift\",\"rshift\",\"and\",\"xor\",\"or\",\"divmod\"]\nfor(var r_opname of r_opnames){if(float[\"__r\"+r_opname+\"__\"]===undefined &&\nfloat['__'+r_opname+'__']){float[\"__r\"+r_opname+\"__\"]=(function(name){return function(self,other){if(_b_.isinstance(other,_b_.int)){other=float_value(_b_.int.numerator(other))\nreturn float[\"__\"+name+\"__\"](other,self)}else if(_b_.isinstance(other,float)){other=float_value(other)\nreturn float[\"__\"+name+\"__\"](other,self)}\nreturn _b_.NotImplemented}})(r_opname)}}\nfunction $FloatClass(value){return new Number(value)}\nfunction to_digits(s){\nvar arabic_digits=\"\\u0660\\u0661\\u0662\\u0663\\u0664\\u0665\\u0666\\u0667\\u0668\\u0669\",res=\"\"\nfor(var i=0;i < s.length;i++){var x=arabic_digits.indexOf(s[i])\nif(x >-1){res+=x}\nelse{res+=s[i]}}\nreturn res}\nfloat.$factory=function(value){switch(value){case undefined:\nreturn $FloatClass(0.0)\ncase Number.MAX_VALUE:\nreturn $FloatClass(Infinity)\ncase-Number.MAX_VALUE:\nreturn $FloatClass(-Infinity)\ncase true:\nreturn new Number(1)\ncase false:\nreturn new Number(0)}\nif(typeof value==\"number\"){return new Number(value)}\nif(_b_.isinstance(value,float)){return float_value(value)}\nif(_b_.isinstance(value,_b_.bytes)){var s=$B.$getattr(value,\"decode\")(\"latin-1\")\nreturn float.$factory($B.$getattr(value,\"decode\")(\"latin-1\"))}\nif(typeof value==\"string\"){value=value.trim()\nswitch(value.toLowerCase()){case \"+inf\":\ncase \"inf\":\ncase \"+infinity\":\ncase \"infinity\":\nreturn Number.POSITIVE_INFINITY\ncase \"-inf\":\ncase \"-infinity\":\nreturn Number.NEGATIVE_INFINITY\ncase \"+nan\":\ncase \"nan\":\nreturn Number.NaN\ncase \"-nan\":\nreturn-Number.NaN\ncase \"\":\nthrow _b_.ValueError.$factory(\"count not convert string to float\")\ndefault:\nvalue=value.charAt(0)+value.substr(1).replace(/_/g,\"\")\nvalue=to_digits(value)\nif(isFinite(value))return $FloatClass(eval(value))\nelse{\n_b_.str.encode(value,\"latin-1\")\nthrow _b_.ValueError.$factory(\n\"Could not convert to float(): '\"+\n_b_.str.$factory(value)+\"'\")}}}\nvar klass=value.__class__ ||$B.get_class(value),num_value=$B.to_num(value,[\"__float__\",\"__index__\"])\nif(value !==Number.POSITIVE_INFINITY && ! isFinite(num_value)){throw _b_.OverflowError.$factory('int too large to convert to float')}\nif(num_value !==null){return num_value}\nthrow _b_.TypeError.$factory(\"float() argument must be a string or a \"+\n\"number, not '\"+$B.class_name(value)+\"'\")}\n$B.$FloatClass=$FloatClass\n$B.set_func_names(float,\"builtins\")\nvar FloatSubclass=$B.FloatSubclass={__class__:_b_.type,__mro__:[object],$infos:{__module__:\"builtins\",__name__:\"float\"},$is_class:true}\nfor(var $attr in float){if(typeof float[$attr]==\"function\"){FloatSubclass[$attr]=(function(attr){return function(){var args=[],pos=0\nif(arguments.length > 0){var args=[arguments[0].valueOf()],pos=1\nfor(var i=1,len=arguments.length;i < len;i++){args[pos++]=arguments[i]}}\nreturn float[attr].apply(null,args)}})($attr)}}\n$B.set_func_names(FloatSubclass,\"builtins\")\n_b_.float=float})(__BRYTHON__)\n;\n;(function($B){var _b_=$B.builtins\nfunction $UnsupportedOpType(op,class1,class2){throw _b_.TypeError.$factory(\"unsupported operand type(s) for \"+\nop+\": '\"+class1+\"' and '\"+class2+\"'\")}\nvar complex={__class__:_b_.type,__dir__:_b_.object.__dir__,$infos:{__module__:\"builtins\",__name__:\"complex\"},$is_class:true,$native:true,$descriptors:{real:true,imag:true}}\ncomplex.__abs__=function(self){var _rf=isFinite(self.$real),_if=isFinite(self.$imag)\nif((_rf && isNaN(self.$imag))||(_if && isNaN(self.$real))||\n(isNaN(self.$imag)&& isNaN(self.$real))){return NaN}\nif(! _rf ||! _if){return Infinity}\nvar mag=Math.sqrt(Math.pow(self.$real,2)+Math.pow(self.$imag,2))\nif(!isFinite(mag)&& _rf && _if){\nthrow _b_.OverflowError.$factory(\"absolute value too large\")}\nreturn mag}\ncomplex.__add__=function(self,other){if(_b_.isinstance(other,complex)){return make_complex(self.$real+other.$real,self.$imag+other.$imag)}\nif(_b_.isinstance(other,_b_.int)){other=_b_.int.numerator(other)\nreturn make_complex($B.add(self.$real,other.valueOf()),self.$imag)}\nif(_b_.isinstance(other,_b_.float)){return make_complex(self.$real+other.valueOf(),self.$imag)}\nreturn _b_.NotImplemented}\ncomplex.__bool__=function(self){return(self.$real !=0 ||self.$imag !=0)}\ncomplex.__complex__=function(self){return self}\ncomplex.__eq__=function(self,other){if(_b_.isinstance(other,complex)){return self.$real.valueOf()==other.$real.valueOf()&&\nself.$imag.valueOf()==other.$imag.valueOf()}\nif(_b_.isinstance(other,_b_.int)){if(self.$imag !=0){return false}\nreturn self.$real==other.valueOf()}\nif(_b_.isinstance(other,_b_.float)){if(self.$imag !=0){return false}\nreturn self.$real==other.valueOf()}\nreturn _b_.NotImplemented}\ncomplex.__hash__=function(self){\nreturn self.$imag*1000003+self.$real}\ncomplex.__init__=function(){return _b_.None}\ncomplex.__invert__=function(self){return ~self}\ncomplex.__mro__=[_b_.object]\ncomplex.__mul__=function(self,other){if(_b_.isinstance(other,complex)){return make_complex(self.$real*other.$real-self.$imag*other.$imag,self.$imag*other.$real+self.$real*other.$imag)}else if(_b_.isinstance(other,_b_.int)){return make_complex(self.$real*other.valueOf(),self.$imag*other.valueOf())}else if(_b_.isinstance(other,_b_.float)){return make_complex(self.$real*other,self.$imag*other)}else if(_b_.isinstance(other,_b_.bool)){if(other.valueOf()){return self}\nreturn make_complex(0,0)}\n$UnsupportedOpType(\"*\",complex,other)}\ncomplex.__ne__=function(self,other){var res=complex.__eq__(self,other)\nreturn res===_b_.NotImplemented ? res :! res}\ncomplex.__neg__=function(self){return make_complex(-self.$real,-self.$imag)}\ncomplex.__new__=function(cls){if(cls===undefined){throw _b_.TypeError.$factory('complex.__new__(): not enough arguments')}\nvar res,missing={},args=$B.args(\"complex\",3,{cls:null,real:null,imag:null},[\"cls\",\"real\",\"imag\"],arguments,{real:0,imag:missing},null,null),$real=args.real,$imag=args.imag\nif(typeof $real==\"string\"){if($imag !==missing){throw _b_.TypeError.$factory(\"complex() can't take second arg \"+\n\"if first is a string\")}else{var arg=$real\n$real=$real.trim()\nif($real.startsWith(\"(\")&& $real.endsWith(\")\")){$real=$real.substr(1)\n$real=$real.substr(0,$real.length-1)}\nvar complex_re=/^\\s*([\\+\\-]*[0-9_]*\\.?[0-9_]*(e[\\+\\-]*[0-9_]*)?)([\\+\\-]?)([0-9_]*\\.?[0-9_]*(e[\\+\\-]*[0-9_]*)?)(j?)\\s*$/i\nvar parts=complex_re.exec($real)\nfunction to_num(s){var res=parseFloat(s.charAt(0)+s.substr(1).replace(/_/g,\"\"))\nif(isNaN(res)){throw _b_.ValueError.$factory(\"could not convert string \"+\n\"to complex: '\"+arg+\"'\")}\nreturn res}\nif(parts===null){throw _b_.ValueError.$factory(\"complex() arg is a malformed string\")}else if(parts[_real]==\".\" ||parts[_imag]==\".\" ||\nparts[_real]==\".e\" ||parts[_imag]==\".e\" ||\nparts[_real]==\"e\" ||parts[_imag]==\"e\"){throw _b_.ValueError.$factory(\"complex() arg is a malformed string\")}else if(parts[_j]!=\"\"){if(parts[_sign]==\"\"){$real=0\nif(parts[_real]==\"+\" ||parts[_real]==\"\"){$imag=1}else if(parts[_real]=='-'){$imag=-1}else{$imag=to_num(parts[_real])}}else{$real=to_num(parts[_real])\n$imag=parts[_imag]==\"\" ? 1 :to_num(parts[_imag])\n$imag=parts[_sign]==\"-\" ?-$imag :$imag}}else{$real=to_num(parts[_real])\n$imag=0}\nres={__class__:complex,$real:$real ||0,$imag:$imag ||0}\nreturn res}}\n$imag=$imag===missing ? 0 :$imag\nif(arguments.length==2 && $real.__class__===complex && $imag==0){return $real}\nif(_b_.isinstance($real,[_b_.float,_b_.int])&&\n_b_.isinstance($imag,[_b_.float,_b_.int])){res={__class__:complex,$real:$real,$imag:$imag}\nreturn res}\nvar real_to_num=$B.to_num($real,[\"__complex__\",\"__float__\",\"__index__\"])\nif(real_to_num===null){throw _b_.TypeError.$factory(\"complex() first argument must be a \"+\n\" string or a number, not '\"+$B.class_name($real)+\"'\")}\n$real=real_to_num\n$imag=_convert($imag)\nif(! _b_.isinstance($real,_b_.float)&& ! _b_.isinstance($real,_b_.int)&&\n! _b_.isinstance($real,_b_.complex)){throw _b_.TypeError.$factory(\"complex() argument must be a string \"+\n\"or a number\")}\nif(typeof $imag==\"string\"){throw _b_.TypeError.$factory(\"complex() second arg can't be a string\")}\nif(! _b_.isinstance($imag,_b_.float)&& ! _b_.isinstance($imag,_b_.int)&&\n! _b_.isinstance($imag,_b_.complex)&& $imag !==missing){throw _b_.TypeError.$factory(\"complex() argument must be a string \"+\n\"or a number\")}\n$imag=complex.__mul__(complex.$factory(\"1j\"),$imag)\nreturn complex.__add__($imag,$real)}\ncomplex.__pos__=function(self){return self}\nfunction complex2expo(cx){var norm=Math.sqrt((cx.$real*cx.$real)+(cx.$imag*cx.$imag)),sin=cx.$imag/norm,cos=cx.$real/norm,angle\nif(cos==0){angle=sin==1 ? Math.PI/2 :3*Math.PI/2}\nelse if(sin==0){angle=cos==1 ? 0 :Math.PI}\nelse{angle=Math.atan(sin/cos)}\nreturn{norm:norm,angle:angle}}\ncomplex.__pow__=function(self,other){\nif(other==1){return self}\nvar exp=complex2expo(self),angle=exp.angle,res=Math.pow(exp.norm,other)\nif(_b_.isinstance(other,[_b_.int,_b_.float])){return make_complex(res*Math.cos(angle*other),res*Math.sin(angle*other))}else if(_b_.isinstance(other,complex)){\nvar x=other.$real,y=other.$imag\nvar pw=Math.pow(exp.norm,x)*Math.pow(Math.E,-y*angle),theta=y*Math.log(exp.norm)-x*angle\nreturn make_complex(pw*Math.cos(theta),pw*Math.sin(theta))}else{throw _b_.TypeError.$factory(\"unsupported operand type(s) \"+\n\"for ** or pow(): 'complex' and '\"+\n$B.class_name(other)+\"'\")}}\ncomplex.__radd__=function(self,other){if(_b_.isinstance(other,_b_.bool)){other=other ? 1 :0}\nif(_b_.isinstance(other,[_b_.int,_b_.float])){return make_complex(other+self.$real,self.$imag)}\nreturn _b_.NotImplemented}\ncomplex.__repr__=function(self){$B.builtins_repr_check(complex,arguments)\nvar real=_b_.str.$factory(self.$real),imag=_b_.str.$factory(self.$imag)\nif(self.$real instanceof Number && self.$real==parseInt(self.$real)){real=_b_.str.$factory(parseInt(self.$real))}\nif(self.$imag instanceof Number && self.$imag==parseInt(self.$imag)){imag=_b_.str.$factory(parseInt(self.$imag))\nif(self.$imag==0 && 1/self.$imag===-Infinity){imag=\"-0\"}}\nif(self.$real==0){if(1/self.$real < 0){if(imag.startsWith('-')){return \"-0\"+imag+\"j\"}\nreturn \"-0+\"+imag+\"j\"}else{return imag+\"j\"}}\nif(self.$imag > 0 ||isNaN(self.$imag)){return \"(\"+real+\"+\"+imag+\"j)\"}\nif(self.$imag==0){if(1/self.$imag < 0){return \"(\"+real+\"-0j)\"}\nreturn \"(\"+real+\"+0j)\"}\nreturn \"(\"+real+\"-\"+_b_.str.$factory(-self.$imag)+\"j)\"}\ncomplex.__rmul__=function(self,other){if(_b_.isinstance(other,_b_.bool)){other=other ? 1 :0}\nif(_b_.isinstance(other,[_b_.int,_b_.float])){return make_complex(other*self.$real,other*self.$imag)}\nreturn _b_.NotImplemented}\ncomplex.__sqrt__=function(self){if(self.$imag==0){return complex(Math.sqrt(self.$real))}\nvar r=self.$real,i=self.$imag,_a=Math.sqrt((r+sqrt)/2),_b=Number.sign(i)*Math.sqrt((-r+sqrt)/2)\nreturn make_complex(_a,_b)}\ncomplex.__sub__=function(self,other){if(_b_.isinstance(other,complex)){return make_complex(self.$real-other.$real,self.$imag-other.$imag)}\nif(_b_.isinstance(other,_b_.int)){other=_b_.int.numerator(other)\nreturn make_complex($B.sub(self.$real,other.valueOf()),self.$imag)}\nif(_b_.isinstance(other,_b_.float)){return make_complex(self.$real-other.valueOf(),self.$imag)}\nreturn _b_.NotImplemented}\ncomplex.__truediv__=function(self,other){if(_b_.isinstance(other,complex)){if(other.$real==0 && other.$imag==0){throw _b_.ZeroDivisionError.$factory(\"division by zero\")}\nvar _num=self.$real*other.$real+self.$imag*other.$imag,_div=other.$real*other.$real+other.$imag*other.$imag\nvar _num2=self.$imag*other.$real-self.$real*other.$imag\nreturn make_complex(_num/_div,_num2/_div)}\nif(_b_.isinstance(other,_b_.int)){if(! other.valueOf()){throw _b_.ZeroDivisionError.$factory('division by zero')}\nreturn complex.__truediv__(self,complex.$factory(other.valueOf()))}\nif(_b_.isinstance(other,_b_.float)){if(! other.valueOf()){throw _b_.ZeroDivisionError.$factory(\"division by zero\")}\nreturn complex.__truediv__(self,complex.$factory(other.valueOf()))}\n$UnsupportedOpType(\"//\",\"complex\",other.__class__)}\ncomplex.conjugate=function(self){return make_complex(self.$real,-self.$imag)}\ncomplex.__ior__=complex.__or__\nvar r_opnames=[\"add\",\"sub\",\"mul\",\"truediv\",\"floordiv\",\"mod\",\"pow\",\"lshift\",\"rshift\",\"and\",\"xor\",\"or\"]\nfor(var r_opname of r_opnames){if(complex[\"__r\"+r_opname+\"__\"]===undefined &&\ncomplex['__'+r_opname+'__']){complex[\"__r\"+r_opname+\"__\"]=(function(name){return function(self,other){if(_b_.isinstance(other,[_b_.int,_b_.float])){other=make_complex(other,0)\nreturn complex[\"__\"+name+\"__\"](other,self)}else if(_b_.isinstance(other,complex)){return complex[\"__\"+name+\"__\"](other,self)}\nreturn _b_.NotImplemented}})(r_opname)}}\nvar $comp_func=function(self,other){if(other===undefined ||other==_b_.None){return _b_.NotImplemented}\nthrow _b_.TypeError.$factory(\"no ordering relation \"+\n\"is defined for complex numbers\")}\n$comp_func+='' \nfor(var $op in $B.$comps){eval(\"complex.__\"+$B.$comps[$op]+\"__ = \"+\n$comp_func.replace(/>/gm,$op))}\ncomplex.real=function(self){return new Number(self.$real)}\ncomplex.real.setter=function(){throw _b_.AttributeError.$factory(\"readonly attribute\")}\ncomplex.imag=function(self){return new Number(self.$imag)}\ncomplex.imag.setter=function(){throw _b_.AttributeError.$factory(\"readonly attribute\")}\nvar _real=1,_real_mantissa=2,_sign=3,_imag=4,_imag_mantissa=5,_j=6\nvar type_conversions=[\"__complex__\",\"__float__\",\"__index__\"]\nvar _convert=function(num){var klass=num.__class__ ||$B.get_class(num)\nfor(var i=0;i < type_conversions.length;i++){var missing={},method=$B.$getattr(klass,type_conversions[i],missing)\nif(method !==missing){return method(num)}}\nreturn null}\nvar make_complex=$B.make_complex=function(real,imag){return{\n__class__:complex,$real:real,$imag:imag}}\ncomplex.$factory=function(){return complex.__new__(complex,...arguments)}\n$B.set_func_names(complex,\"builtins\")\n_b_.complex=complex})(__BRYTHON__)\n;\n;(function($B){\nvar _b_=$B.builtins\nvar str_hash=_b_.str.__hash__,$N=_b_.None\nvar set_ops=[\"eq\",\"le\",\"lt\",\"ge\",\"gt\",\"sub\",\"rsub\",\"and\",\"or\",\"xor\"]\nfunction is_sublist(t1,t2){\nfor(var i=0,ilen=t1.length;i < ilen;i++){var x=t1[i],flag=false\nfor(var j=0,jlen=t2.length;j < jlen;j++){if($B.rich_comp(\"__eq__\",x,t2[j])){t2.splice(j,1)\nflag=true\nbreak}}\nif(! flag){return false}}\nreturn true}\ndict_view_op={__eq__:function(t1,t2){return t1.length==t2.length && is_sublist(t1,t2)},__ne__:function(t1,t2){return ! dict_view_op.__eq__(t1,t2)},__lt__:function(t1,t2){return t1.length < t2.length && is_sublist(t1,t2)},__gt__:function(t1,t2){return dict_view_op.__lt__(t2,t1)},__le__:function(t1,t2){return t1.length <=t2.length && is_sublist(t1,t2)},__ge__:function(t1,t2){return dict_view_op.__le__(t2,t1)},__and__:function(t1,t2){var items=[]\nfor(var i=0,ilen=t1.length;i < ilen;i++){var x=t1[i]\nflag=false\nfor(var j=0,jlen=t2.length;j < jlen;j++){if($B.rich_comp(\"__eq__\",x,t2[j])){t2.splice(j,1)\nitems.push(x)\nbreak}}}\nreturn items},__or__:function(t1,t2){var items=t1\nfor(var j=0,jlen=t2.length;j < jlen;j++){var y=t2[j],flag=false\nfor(var i=0,ilen=t1.length;i < ilen;i++){if($B.rich_comp(\"__eq__\",y,t1[i])){t2.splice(j,1)\nflag=true\nbreak}}\nif(! flag){items.push(y)}}\nreturn items}}\n$B.make_view=function(name){var klass=$B.make_class(name,function(d,items,set_like){return{\n__class__:klass,__dict__:$B.empty_dict(),counter:-1,dict:d,items:items,len:items.length,set_like:set_like}})\nfor(var i=0,len=set_ops.length;i < len;i++){var op=\"__\"+set_ops[i]+\"__\"\nklass[op]=(function(op){return function(self,other){\nif(self.set_like){return _b_.set[op](_b_.set.$factory(self),_b_.set.$factory(other))}else{\nif(other.__class__ !==klass){return false}\nvar other_items=_b_.list.$factory(other)\nreturn dict_view_op[op](self.items,other_items)}}})(op)}\nklass.__iter__=function(self){var it=klass.$iterator.$factory(self.items)\nit.test_change=function(){return self.dict.$version !=self.dict_version}\nreturn it}\nklass.__len__=function(self){return self.len}\nklass.__repr__=function(self){return klass.$infos.__name__+'('+_b_.repr(self.items)+')'}\n$B.set_func_names(klass,\"builtins\")\nreturn klass}\nvar dict={__class__:_b_.type,__mro__:[_b_.object],$infos:{__module__:\"builtins\",__name__:\"dict\"},$is_class:true,$native:true,$match_mapping_pattern:true }\ndict.$to_obj=function(d){\nvar res={}\nfor(var key in d.$string_dict){res[key]=d.$string_dict[key][0]}\nreturn res}\nfunction to_list(d,ix){var items=[],item\nif(d.$jsobj){items=[]\nfor(var attr in d.$jsobj){if((! attr.startsWith(\"$\"))&&\n((! d.$exclude)||! d.$exclude(attr))){var val=d.$jsobj[attr]\nif(val===undefined){val=_b_.NotImplemented}\nelse if(val===null){val=$N}\nitems.push([attr,val])}}}else if(_b_.isinstance(d,_b_.dict)){for(var k in d.$numeric_dict){items.push([parseFloat(k),d.$numeric_dict[k]])}\nfor(var k in d.$string_dict){items.push([k,d.$string_dict[k]])}\nfor(var k in d.$object_dict){d.$object_dict[k].forEach(function(item){items.push(item)})}\nitems.sort(function(a,b){return a[1][1]-b[1][1]})\nitems=items.map(function(item){return[item[0],item[1][0]]})}\nif(ix !==undefined){res=items.map(function(item){return item[ix]})\nreturn res}else{items.__class__=_b_.tuple\nreturn items.map(function(item){item.__class__=_b_.tuple;return item}\n)}}\n$B.dict_to_list=to_list \nvar $copy_dict=function(left,right){var _l=to_list(right),si=dict.$setitem\nright.$version=right.$version ||0\nvar right_version=right.$version ||0\nfor(var i=0,len=_l.length;i < len;i++){si(left,_l[i][0],_l[i][1])\nif(right.$version !=right_version){throw _b_.RuntimeError.$factory(\"dict mutated during update\")}}}\nfunction rank(self,hash,key){\nvar pairs=self.$object_dict[hash]\nif(pairs !==undefined){for(var i=0,len=pairs.length;i < len;i++){if($B.rich_comp(\"__eq__\",key,pairs[i][0])){return i}}}\nreturn-1}\ndict.__bool__=function(){var $=$B.args(\"__bool__\",1,{self:null},[\"self\"],arguments,{},null,null)\nreturn dict.__len__($.self)> 0}\ndict.__class_getitem__=function(cls,item){\nif(! Array.isArray(item)){item=[item]}\nreturn $B.GenericAlias.$factory(cls,item)}\ndict.__contains__=function(){var $=$B.args(\"__contains__\",2,{self:null,key:null},[\"self\",\"key\"],arguments,{},null,null),self=$.self,key=$.key\nif(self.$jsobj){return self.$jsobj[key]!==undefined}\nswitch(typeof key){case \"string\":\nreturn self.$string_dict[key]!==undefined\ncase \"number\":\nreturn self.$numeric_dict[key]!==undefined}\nvar hash=_b_.hash(key)\nif(self.$str_hash[hash]!==undefined &&\n$B.rich_comp(\"__eq__\",key,self.$str_hash[hash])){return true}\nif(self.$numeric_dict[hash]!==undefined &&\n$B.rich_comp(\"__eq__\",key,hash)){return true}\nreturn rank(self,hash,key)>-1}\ndict.__delitem__=function(){var $=$B.args(\"__eq__\",2,{self:null,arg:null},[\"self\",\"arg\"],arguments,{},null,null),self=$.self,arg=$.arg\nif(self.$jsobj){if(self.$jsobj[arg]===undefined){throw _b_.KeyError.$factory(arg)}\ndelete self.$jsobj[arg]\nreturn $N}\nswitch(typeof arg){case \"string\":\nif(self.$string_dict[arg]===undefined){throw _b_.KeyError.$factory(_b_.str.$factory(arg))}\ndelete self.$string_dict[arg]\ndelete self.$str_hash[str_hash(arg)]\nself.$version++\nreturn $N\ncase \"number\":\nif(self.$numeric_dict[arg]===undefined){throw _b_.KeyError.$factory(_b_.str.$factory(arg))}\ndelete self.$numeric_dict[arg]\nself.$version++\nreturn $N}\nvar hash=_b_.hash(arg),ix\nif((ix=rank(self,hash,arg))>-1){self.$object_dict[hash].splice(ix,1)}else{throw _b_.KeyError.$factory(_b_.str.$factory(arg))}\nself.$version++\nreturn $N}\ndict.__eq__=function(){var $=$B.args(\"__eq__\",2,{self:null,other:null},[\"self\",\"other\"],arguments,{},null,null),self=$.self,other=$.other\nif(! _b_.isinstance(other,dict)){return false}\nif(self.$jsobj){self=jsobj2dict(self.$jsobj)}\nif(other.$jsobj){other=jsobj2dict(other.$jsobj)}\nif(dict.__len__(self)!=dict.__len__(other)){return false}\nif(self.$string_dict.length !=other.$string_dict.length){return false}\nfor(var k in self.$numeric_dict){if(other.$numeric_dict.hasOwnProperty(k)){if(!$B.rich_comp(\"__eq__\",other.$numeric_dict[k][0],self.$numeric_dict[k][0])){return false}}else if(other.$object_dict.hasOwnProperty(k)){var pairs=other.$object_dict[k],flag=false\nfor(var i=0,len=pairs.length;i < len;i++){if($B.rich_comp(\"__eq__\",k,pairs[i][0])&&\n$B.rich_comp(\"__eq__\",self.$numeric_dict[k],pairs[i][1])){flag=true\nbreak}}\nif(! flag){return false}}else{return false}}\nfor(var k in self.$string_dict){if(!other.$string_dict.hasOwnProperty(k)||\n!$B.rich_comp(\"__eq__\",other.$string_dict[k][0],self.$string_dict[k][0])){return false}}\nfor(var hash in self.$object_dict){var pairs=self.$object_dict[hash]\nvar other_pairs=[]\nif(other.$numeric_dict[hash]!==undefined){other_pairs.push([hash,other.$numeric_dict[hash]])}\nif(other.$object_dict[hash]!==undefined){other_pairs=other_pairs.concat(other.$object_dict[hash])}\nif(other_pairs.length==0){return false}\nfor(var i=0,len_i=pairs.length;i < len_i;i++){var flag=false\nvar key=pairs[i][0],value=pairs[i][1][0]\nfor(var j=0,len_j=other_pairs.length;j < len_j;j++){if($B.rich_comp(\"__eq__\",key,other_pairs[j][0])&&\n$B.rich_comp(\"__eq__\",value,other_pairs[j][1][0])){flag=true\nbreak}}\nif(! flag){return false}}}\nreturn true}\ndict.__getitem__=function(){var $=$B.args(\"__getitem__\",2,{self:null,arg:null},[\"self\",\"arg\"],arguments,{},null,null),self=$.self,arg=$.arg\nreturn dict.$getitem(self,arg)}\ndict.$getitem=function(self,arg,ignore_missing){\nif(self.$jsobj){if(self.$exclude && self.$exclude(arg)){throw _b_.KeyError.$factory(arg)}\nif(self.$jsobj[arg]===undefined){if(self.$jsobj.hasOwnProperty &&\nself.$jsobj.hasOwnProperty(arg)){return $B.Undefined}\nthrow _b_.KeyError.$factory(arg)}\nreturn self.$jsobj[arg]}\nswitch(typeof arg){case \"string\":\nvar x=self.$string_dict[arg]\nif(x !==undefined){return x[0]}\nbreak\ncase \"number\":\nif(self.$numeric_dict[arg]!==undefined){return self.$numeric_dict[arg][0]}\nbreak}\nvar hash=_b_.hash(arg),_eq=function(other){return $B.rich_comp(\"__eq__\",arg,other)}\nif(typeof arg==\"object\"){arg.$hash=hash }\nvar sk=self.$str_hash[hash]\nif(sk !==undefined && _eq(sk)){return self.$string_dict[sk][0]}\nif(self.$numeric_dict[hash]!==undefined && _eq(hash)){return self.$numeric_dict[hash][0]}\nif(_b_.isinstance(arg,_b_.str)){\nvar res=self.$string_dict[arg.valueOf()]\nif(res !==undefined){return res[0]}}\nvar ix=rank(self,hash,arg)\nif(ix >-1){return self.$object_dict[hash][ix][1][0]}\nif(! ignore_missing){if(self.__class__ !==dict && ! ignore_missing){try{var missing_method=$B.$getattr(self.__class__,\"__missing__\",_b_.None)}catch(err){console.log(err)}\nif(missing_method !==_b_.None){return missing_method(self,arg)}}}\nthrow _b_.KeyError.$factory(arg)}\ndict.__hash__=_b_.None\nfunction init_from_list(self,args){var i=-1,stop=args.length-1,si=dict.__setitem__\nwhile(i++< stop){var item=args[i]\nif(item.length !=2){throw _b_.ValueError.$factory(\"dictionary \"+\n`update sequence element #${i} has length 1; 2 is required`)}\nswitch(typeof item[0]){case 'string':\nself.$string_dict[item[0]]=[item[1],self.$order++]\nself.$str_hash[str_hash(item[0])]=item[0]\nself.$version++\nbreak\ncase 'number':\nif(item[0]!=0 && item[0]!=1){self.$numeric_dict[item[0]]=[item[1],self.$order++]\nself.$version++\nbreak}\ndefault:\nsi(self,item[0],item[1])\nbreak}}}\ndict.__init__=function(self,first,second){if(first===undefined){return $N}\nif(second===undefined){if(first.$nat !='kw' && $B.get_class(first)===$B.JSObj){for(var key in first){self.$string_dict[key]=[first[key],self.$order++]}\nreturn _b_.None}else if(first.$jsobj){self.$jsobj={}\nfor(var attr in first.$jsobj){self.$jsobj[attr]=first.$jsobj[attr]}\nreturn $N}else if(Array.isArray(first)){init_from_list(self,first)\nreturn $N}}\nvar $=$B.args(\"dict\",1,{self:null},[\"self\"],arguments,{},\"first\",\"second\")\nvar args=$.first\nif(args.length > 1){throw _b_.TypeError.$factory(\"dict expected at most 1 argument\"+\n\", got 2\")}else if(args.length==1){args=args[0]\nif(args.__class__===dict){['$string_dict','$str_hash','$numeric_dict','$object_dict'].\nforEach(function(d){for(key in args[d]){self[d][key]=args[d][key]}})}else if(_b_.isinstance(args,dict)){$copy_dict(self,args)}else{var keys=$B.$getattr(args,\"keys\",null)\nif(keys !==null){var gi=$B.$getattr(args,\"__getitem__\",null)\nif(gi !==null){\ngi=$B.$call(gi)\nvar kiter=_b_.iter($B.$call(keys)())\nwhile(true){try{var key=_b_.next(kiter),value=gi(key)\ndict.__setitem__(self,key,value)}catch(err){if(err.__class__===_b_.StopIteration){break}\nthrow err}}\nreturn $N}}\nif(! Array.isArray(args)){args=_b_.list.$factory(args)}\ninit_from_list(self,args)}}\nvar kw=$.second.$string_dict\nfor(var attr in kw){switch(typeof attr){case \"string\":\nself.$string_dict[attr]=[kw[attr][0],self.$order++]\nself.$str_hash[str_hash(attr)]=attr\nbreak\ncase \"number\":\nself.$numeric_dict[attr]=[kw[attr][0],self.$order++]\nbreak\ndefault:\nsi(self,attr,kw[attr][0])\nbreak}}\nreturn $N}\ndict.__iter__=function(self){return _b_.iter(dict.keys(self))}\ndict.__ior__=function(self,other){\ndict.update(self,other)\nreturn self}\ndict.__len__=function(self){var _count=0\nif(self.$jsobj){for(var attr in self.$jsobj){if(attr.charAt(0)!=\"$\" &&\n((! self.$exclude)||! self.$exclude(attr))){_count++}}\nreturn _count}\nfor(var k in self.$numeric_dict){_count++}\nfor(var k in self.$string_dict){_count++}\nfor(var hash in self.$object_dict){_count+=self.$object_dict[hash].length}\nreturn _count}\ndict.__ne__=function(self,other){return ! dict.__eq__(self,other)}\ndict.__new__=function(cls){if(cls===undefined){throw _b_.TypeError.$factory(\"int.__new__(): not enough arguments\")}\nvar instance={__class__:cls,$numeric_dict :{},$object_dict :{},$string_dict :{},$str_hash:{},$version:0,$order:0}\nif(cls !==dict){instance.__dict__=$B.empty_dict()}\nreturn instance}\ndict.__or__=function(self,other){\nif(! _b_.isinstance(other,dict)){return _b_.NotImplemented}\nvar res=dict.copy(self)\ndict.update(res,other)\nreturn res}\nfunction __newobj__(){\nvar $=$B.args('__newobj__',0,{},[],arguments,{},'args',null),args=$.args\nvar res=$B.empty_dict()\nres.__class__=args[0]\nreturn res}\ndict.__reduce_ex__=function(self,protocol){return $B.fast_tuple([__newobj__,$B.fast_tuple([self.__class__]),_b_.None,_b_.None,dict.items(self)])}\ndict.__repr__=function(self){$B.builtins_repr_check(dict,arguments)\nif(self.$jsobj){\nreturn dict.__repr__(jsobj2dict(self.$jsobj,self.$exclude))}\nif($B.repr.enter(self)){return \"{...}\"}\nvar res=[],items=to_list(self)\nitems.forEach(function(item){try{res.push(_b_.repr(item[0])+\": \"+_b_.repr(item[1]))}catch(err){throw err}})\n$B.repr.leave(self)\nreturn \"{\"+res.join(\", \")+\"}\"}\ndict.__ror__=function(self,other){\nif(! _b_.isinstance(other,dict)){return _b_.NotImplemented}\nvar res=dict.copy(other)\ndict.update(res,self)\nreturn res}\ndict.__setitem__=function(self,key,value){var $=$B.args(\"__setitem__\",3,{self:null,key:null,value:null},[\"self\",\"key\",\"value\"],arguments,{},null,null)\nreturn dict.$setitem($.self,$.key,$.value)}\ndict.$setitem=function(self,key,value,$hash){\nif(self.$jsobj){if(self.$from_js){\nvalue=$B.pyobj2jsobj(value)}\nif(self.$jsobj.__class__===_b_.type){self.$jsobj[key]=value\nif(key==\"__init__\" ||key==\"__new__\"){\nself.$jsobj.$factory=$B.$instance_creator(self.$jsobj)}}else{self.$jsobj[key]=value}\nreturn $N}\nif(key instanceof String){key=key.valueOf()}\nswitch(typeof key){case \"string\":\nif(self.$string_dict===undefined){console.log(\"pas de string dict\",self,key,value)}\nif(self.$string_dict[key]!==undefined){self.$string_dict[key][0]=value}else{self.$string_dict[key]=[value,self.$order++]\nself.$str_hash[str_hash(key)]=key\nself.$version++}\nreturn $N\ncase \"number\":\nif(self.$numeric_dict[key]!==undefined){\nself.$numeric_dict[key][0]=value}else{\nvar done=false\nif((key==0 ||key==1)&&\nself.$object_dict[key]!==undefined){for(const item of self.$object_dict[key]){if((key==0 && item[0]===false)||\n(key==1 && item[0]===true)){\nitem[1][0]=value\ndone=true}}}\nif(! done){\nself.$numeric_dict[key]=[value,self.$order++]}\nself.$version++}\nreturn $N\ncase \"boolean\":\nvar num=key ? 1 :0\nif(self.$numeric_dict[num]!==undefined){var order=self.$numeric_dict[num][1]\nself.$numeric_dict[num]=[value,order]\nreturn}\nif(self.$object_dict[num]!==undefined){self.$object_dict[num].push([key,[value,self.$order++]])}else{self.$object_dict[num]=[[key,[value,self.$order++]]]}}\nvar hash=$hash===undefined ? _b_.hash(key):$hash,_eq=function(other){return $B.rich_comp(\"__eq__\",key,other)}\nif(self.$numeric_dict[hash]!==undefined && _eq(hash)){self.$numeric_dict[hash]=[value,self.$numeric_dict[hash][1]]\nself.$version++\nreturn $N}\nvar sk=self.$str_hash[hash]\nif(sk !==undefined && _eq(sk)){self.$string_dict[sk]=[value,self.$string_dict[sk][1]]\nself.$version++\nreturn $N}\nif($hash){if(self.$object_dict[$hash]!==undefined){self.$object_dict[$hash].push([key,[value,self.$order++]])}else{self.$object_dict[$hash]=[[key,[value,self.$order++]]]}\nself.$version++\nreturn $N}\nvar ix=rank(self,hash,key)\nif(ix >-1){\nself.$object_dict[hash][ix][1]=[value,self.$object_dict[hash][ix][1][1]]\nreturn $N}else if(self.$object_dict.hasOwnProperty(hash)){self.$object_dict[hash].push([key,[value,self.$order++]])}else{self.$object_dict[hash]=[[key,[value,self.$order++]]]}\nself.$version++\nreturn $N}\n$B.make_rmethods(dict)\ndict.clear=function(){\nvar $=$B.args(\"clear\",1,{self:null},[\"self\"],arguments,{},null,null),self=$.self\nself.$numeric_dict={}\nself.$string_dict={}\nself.$str_hash={}\nself.$object_dict={}\nif(self.$jsobj){for(var attr in self.$jsobj){if(attr.charAt(0)!==\"$\" && attr !==\"__class__\"){delete self.$jsobj[attr]}}}\nself.$version++\nself.$order=0\nreturn $N}\ndict.copy=function(self){\nvar $=$B.args(\"copy\",1,{self:null},[\"self\"],arguments,{},null,null),self=$.self,res=$B.empty_dict()\n$copy_dict(res,self)\nreturn res}\ndict.fromkeys=function(){var $=$B.args(\"fromkeys\",3,{cls:null,keys:null,value:null},[\"cls\",\"keys\",\"value\"],arguments,{value:_b_.None},null,null),keys=$.keys,value=$.value\nvar klass=$.cls,res=$B.$call(klass)(),keys_iter=$B.$iter(keys)\nwhile(1){try{var key=_b_.next(keys_iter)\nif(klass===dict){dict.$setitem(res,key,value)}\nelse{$B.$getattr(res,\"__setitem__\")(key,value)}}catch(err){if($B.is_exc(err,[_b_.StopIteration])){return res}\nthrow err}}}\ndict.get=function(){var $=$B.args(\"get\",3,{self:null,key:null,_default:null},[\"self\",\"key\",\"_default\"],arguments,{_default:$N},null,null)\ntry{\nreturn dict.$getitem($.self,$.key,true)}catch(err){if(_b_.isinstance(err,_b_.KeyError)){return $._default}\nelse{throw err}}}\nvar dict_items=$B.make_view(\"dict_items\",true)\ndict_items.$iterator=$B.make_iterator_class(\"dict_itemiterator\")\ndict.items=function(self){if(arguments.length > 1){var _len=arguments.length-1,_msg=\"items() takes no arguments (\"+_len+\" given)\"\nthrow _b_.TypeError.$factory(_msg)}\nvar items=to_list(self),set_like=true\nfor(var i=0,len=items.length;i < len;i++){try{_b_.hash(items[i][1])}catch(err){set_like=false\nbreak}}\nvar values=to_list(self)\nvar it=dict_items.$factory(self,values,set_like)\nit.dict_version=self.$version\nreturn it}\nvar dict_keys=$B.make_view(\"dict_keys\")\ndict_keys.$iterator=$B.make_iterator_class(\"dict_keyiterator\")\ndict.keys=function(self){if(arguments.length > 1){var _len=arguments.length-1,_msg=\"keys() takes no arguments (\"+_len+\" given)\"\nthrow _b_.TypeError.$factory(_msg)}\nvar it=dict_keys.$factory(self,to_list(self,0),true)\nit.dict_version=self.$version\nreturn it}\ndict.pop=function(){var missing={},$=$B.args(\"pop\",3,{self:null,key:null,_default:null},[\"self\",\"key\",\"_default\"],arguments,{_default:missing},null,null),self=$.self,key=$.key,_default=$._default\ntry{var res=dict.__getitem__(self,key)\ndict.__delitem__(self,key)\nreturn res}catch(err){if(err.__class__===_b_.KeyError){if(_default !==missing){return _default}\nthrow err}\nthrow err}}\ndict.popitem=function(self){try{var itm=_b_.next(_b_.iter(dict.items(self)))\ndict.__delitem__(self,itm[0])\nreturn _b_.tuple.$factory(itm)}catch(err){if(err.__class__==_b_.StopIteration){throw _b_.KeyError.$factory(\"'popitem(): dictionary is empty'\")}}}\ndict.setdefault=function(){var $=$B.args(\"setdefault\",3,{self:null,key:null,_default:null},[\"self\",\"key\",\"_default\"],arguments,{_default:$N},null,null),self=$.self,key=$.key,_default=$._default\ntry{\nreturn dict.$getitem(self,key,true)}catch(err){if(err.__class__ !==_b_.KeyError){throw err}\nif(_default===undefined){_default=$N}\nvar hash=key.$hash\nkey.$hash=undefined\ndict.$setitem(self,key,_default,hash)\nreturn _default}}\ndict.update=function(self){var $=$B.args(\"update\",1,{\"self\":null},[\"self\"],arguments,{},\"args\",\"kw\"),self=$.self,args=$.args,kw=$.kw\nif(args.length > 0){var o=args[0]\nif(_b_.isinstance(o,dict)){if(o.$jsobj){o=jsobj2dict(o.$jsobj)}\n$copy_dict(self,o)}else if(_b_.hasattr(o,\"keys\")){var _keys=_b_.list.$factory($B.$call($B.$getattr(o,\"keys\"))())\nfor(var i=0,len=_keys.length;i < len;i++){var _value=$B.$getattr(o,\"__getitem__\")(_keys[i])\ndict.$setitem(self,_keys[i],_value)}}else{var it=_b_.iter(o),i=0\nwhile(true){try{var item=_b_.next(it)}catch(err){if(err.__class__===_b_.StopIteration){break}\nthrow err}\ntry{key_value=_b_.list.$factory(item)}catch(err){throw _b_.TypeError.$factory(\"cannot convert dictionary\"+\n\" update sequence element #\"+i+\" to a sequence\")}\nif(key_value.length !==2){throw _b_.ValueError.$factory(\"dictionary update \"+\n\"sequence element #\"+i+\" has length \"+\nkey_value.length+\"; 2 is required\")}\ndict.$setitem(self,key_value[0],key_value[1])\ni++}}}\n$copy_dict(self,kw)\nself.$version++\nreturn $N}\nvar dict_values=$B.make_view(\"dict_values\")\ndict_values.$iterator=$B.make_iterator_class(\"dict_valueiterator\")\ndict.values=function(self){if(arguments.length > 1){var _len=arguments.length-1,_msg=\"values() takes no arguments (\"+_len+\" given)\"\nthrow _b_.TypeError.$factory(_msg)}\nvar values=to_list(self,1)\nvar it=dict_values.$factory(self,values,false)\nit.dict_version=self.$version\nreturn it}\ndict.$factory=function(){var res=dict.__new__(dict)\nvar args=[res]\nfor(var i=0,len=arguments.length;i < len ;i++){args.push(arguments[i])}\ndict.__init__.apply(null,args)\nreturn res}\n_b_.dict=dict\n$B.set_func_names(dict,\"builtins\")\ndict.__class_getitem__=_b_.classmethod.$factory(dict.__class_getitem__)\n$B.empty_dict=function(){return{\n__class__:dict,$numeric_dict :{},$object_dict :{},$string_dict :{},$str_hash:{},$version:0,$order:0}}\ndict.fromkeys=_b_.classmethod.$factory(dict.fromkeys)\n$B.getset_descriptor=$B.make_class(\"getset_descriptor\",function(klass,attr){return{\n__class__:$B.getset_descriptor,__doc__:_b_.None,cls:klass,attr:attr}}\n)\n$B.getset_descriptor.__repr__=$B.getset_descriptor.__str__=function(self){return `<attribute '${self.attr}' of '${self.cls.$infos.__name__}' objects>`}\n$B.set_func_names($B.getset_descriptor,\"builtins\")\nvar mappingproxy=$B.mappingproxy=$B.make_class(\"mappingproxy\",function(obj){if(_b_.isinstance(obj,dict)){\nvar res=$B.obj_dict(dict.$to_obj(obj))}else{var res=$B.obj_dict(obj)}\nres.__class__=mappingproxy\nreturn res}\n)\nmappingproxy.$match_mapping_pattern=true \nmappingproxy.__repr__=function(){return '<mappingproxy object>'}\nmappingproxy.__setitem__=function(){throw _b_.TypeError.$factory(\"'mappingproxy' object does not support \"+\n\"item assignment\")}\nfor(var attr in dict){if(mappingproxy[attr]!==undefined ||\n[\"__class__\",\"__mro__\",\"__new__\",\"__init__\",\"__delitem__\",\"clear\",\"fromkeys\",\"pop\",\"popitem\",\"setdefault\",\"update\"].indexOf(attr)>-1){continue}\nif(typeof dict[attr]==\"function\"){mappingproxy[attr]=(function(key){return function(){return dict[key].apply(null,arguments)}})(attr)}else{mappingproxy[attr]=dict[attr]}}\n$B.set_func_names(mappingproxy,\"builtins\")\nfunction jsobj2dict(x,exclude){exclude=exclude ||function(){return false}\nvar d=$B.empty_dict()\nfor(var attr in x){if(attr.charAt(0)!=\"$\" && ! exclude(attr)){if(x[attr]===null){d.$string_dict[attr]=[_b_.None,d.$order++]}else if(x[attr]===undefined){continue}else if(x[attr].$jsobj===x){d.$string_dict[attr]=[d,d.$order++]}else{d.$string_dict[attr]=[$B.$JS2Py(x[attr]),d.$order++]}}}\nreturn d}\n$B.obj_dict=function(obj,exclude){var klass=obj.__class__ ||$B.get_class(obj)\nif(klass !==undefined && klass.$native){throw $B.attr_error(\"__dict__\",obj)}\nvar res=$B.empty_dict()\nres.$jsobj=obj\nres.$exclude=exclude ||function(){return false}\nreturn res}\nvar jsobj_as_pydict=$B.jsobj_as_pydict=$B.make_class('jsobj_as_pydict',function(jsobj,exclude){return{\n__class__:jsobj_as_pydict,obj:jsobj,exclude:exclude ? exclude :function(){return false},new_keys:[]}}\n)\njsobj_as_pydict.__contains__=function(self,key){if(self.new_keys.indexOf(key)>-1){return true}\nreturn !(self.exclude(key)||self.obj[key]===undefined)}\njsobj_as_pydict.__delitem__=function(self,key){jsobj_as_pydict.__getitem__(self,key)\ndelete self.obj[key]\nvar ix=self.new_keys.indexOf(key)\nif(ix >-1){self.new_keys.splice(ix,1)}}\njsobj_as_pydict.__eq__=function(self,other){if(other.__class__ !==jsobj_as_pydict){return _b_.NotImplemented}\nvar self1=$B.empty_dict()\nother1=$B.empty_dict()\ndict.__init__(self1,jsobj_as_pydict.items(self))\ndict.__init__(other1,jsobj_as_pydict.items(other))\nreturn dict.__eq__(self1,other1)}\njsobj_as_pydict.__getitem__=function(self,key){if(jsobj_as_pydict.__contains__(self,key)){return self.obj[key]}\nthrow _b_.KeyError.$factory(key)}\njsobj_as_pydict.__iter__=function(self){return _b_.iter(jsobj_as_pydict.keys(self))}\njsobj_as_pydict.__len__=function(self){var len=0\nfor(var key in self.obj){if(! self.exclude(key)){len++}}\nreturn len+self.new_keys.length}\njsobj_as_pydict.__repr__=function(self){if($B.repr.enter(self)){return \"{...}\"}\nvar res=[],items=_b_.list.$factory(jsobj_as_pydict.items(self))\nfor(var item of items){res.push(_b_.repr(item[0])+\": \"+_b_.repr(item[1]))}\n$B.repr.leave(self)\nreturn \"{\"+res.join(\", \")+\"}\"}\njsobj_as_pydict.__setitem__=function(self,key,value){if(self.exclude(key)&& self.new_keys.indexOf(key)==-1){self.new_keys.push(key)}\nself.obj[key]=value}\njsobj_as_pydict.get=function(self,key,_default){_default=_default===undefined ? _b_.None :_default\nif(self.exclude(key)||self.obj[key]===undefined){return _default}\nreturn self.obj[key]}\njsobj_as_pydict.items=function(self){var items=[]\nfor(var key in self.obj){if(self.exclude(key)&& self.new_keys.indexOf(key)==-1){continue}\nitems.push($B.fast_tuple([key,self.obj[key]]))}\nvar set_like=true\nfor(var item of items){try{_b_.hash(item[1])}catch(err){set_like=false\nbreak}}\nvar it=dict_items.$factory(self,items,set_like)\nit.dict_version=self.$version\nreturn it}\njsobj_as_pydict.keys=function(self){var lst=[]\nfor(var key in self.obj){if(self.exclude(key)&& self.new_keys.indexOf(key)==-1){continue}\nlst.push(key)}\nvar it=dict_keys.$factory(self,lst,true)\nit.dict_version=self.$version\nreturn it}\njsobj_as_pydict.values=function(self){var values=[]\nfor(var key in self.obj){if(self.exclude(key)&& self.new_keys.indexOf(key)==-1){continue}\nvalues.push(self.obj[key])}\nvar it=dict_values.$factory(self,values,false)\nit.dict_version=self.$version\nreturn it}\n$B.set_func_names(jsobj_as_pydict,'builtins')})(__BRYTHON__)\n;\n;(function($B){var _b_=$B.builtins,object=_b_.object,getattr=$B.$getattr,isinstance=_b_.isinstance,$N=_b_.None\nfunction check_not_tuple(self,attr){if(self.__class__===tuple){throw $B.attr_error(attr,self)}}\nfunction $list(){\nreturn list.$factory.apply(null,arguments)}\nvar list={__class__:_b_.type,__mro__:[object],$infos:{__module__:\"builtins\",__name__:\"list\"},$is_class:true,$native:true,$match_sequence_pattern:true,\n__dir__:object.__dir__}\nlist.__add__=function(self,other){if($B.get_class(self)!==$B.get_class(other)){var this_name=$B.class_name(self)\nvar radd=$B.$getattr(other,'__radd__',null)\nif(radd===null){throw _b_.TypeError.$factory('can only concatenate '+\nthis_name+' (not \"'+$B.class_name(other)+\n'\") to '+this_name)}\nreturn _b_.NotImplemented}\nvar res=self.slice(),is_js=other.$brython_class==\"js\" \nfor(const item of other){res.push(is_js ? $B.$JS2Py(item):item)}\nres.__brython__=true\nif(isinstance(self,tuple)){res=tuple.$factory(res)}\nreturn res}\nlist.__class_getitem__=function(cls,item){\nif(! Array.isArray(item)){item=[item]}\nreturn $B.GenericAlias.$factory(cls,item)}\nlist.__contains__=function(self,item){var $=$B.args(\"__contains__\",2,{self:null,item:null},[\"self\",\"item\"],arguments,{},null,null),self=$.self,item=$.item\nvar _eq=function(other){return $B.rich_comp(\"__eq__\",item,other)}\nvar i=0\nwhile(i < self.length){if(_eq(self[i])){return true}\ni++}\nreturn false}\nlist.__delitem__=function(self,arg){if(isinstance(arg,_b_.int)){var pos=arg\nif(arg < 0){pos=self.length+pos}\nif(pos >=0 && pos < self.length){self.splice(pos,1)\nreturn $N}\nthrow _b_.IndexError.$factory($B.class_name(self)+\n\" index out of range\")}\nif(isinstance(arg,_b_.slice)){var step=arg.step\nif(step===$N){step=1}\nvar start=arg.start\nif(start===$N){start=step > 0 ? 0 :self.length}\nvar stop=arg.stop\nif(stop===$N){stop=step > 0 ? self.length :0}\nif(start < 0){start=self.length+start}\nif(stop < 0){stop=self.length+stop}\nvar res=[],i=null,pos=0\nif(step > 0){if(stop > start){for(var i=start;i < stop;i+=step){if(self[i]!==undefined){res[pos++]=i}}}}else{if(stop < start){for(var i=start;i > stop;i+=step){if(self[i]!==undefined){res[pos++]=i}}\nres.reverse()}}\nvar i=res.length\nwhile(i--){self.splice(res[i],1)}\nreturn $N}\nif(_b_.hasattr(arg,\"__int__\")||_b_.hasattr(arg,\"__index__\")){list.__delitem__(self,_b_.int.$factory(arg))\nreturn $N}\nthrow _b_.TypeError.$factory($B.class_name(self)+\n\" indices must be integer, not \"+$B.class_name(arg))}\nlist.__eq__=function(self,other){if(isinstance(self,list)){var klass=list}else{var klass=tuple}\nif(isinstance(other,klass)){if(other.length==self.length){var i=self.length\nwhile(i--){if(! $B.rich_comp(\"__eq__\",self[i],other[i])){return false}}\nreturn true}}\nreturn _b_.NotImplemented}\nlist.__getitem__=function(self,key){\n$B.check_no_kw(\"__getitem__\",self,key)\n$B.check_nb_args(\"__getitem__\",2,arguments)\nreturn list.$getitem(self,key)}\nlist.$getitem=function(self,key){var klass=(self.__class__ ||$B.get_class(self))\nvar factory=function(list_res){list_res.__class__=klass\nreturn list_res}\nvar int_key\ntry{int_key=$B.PyNumber_Index(key)}catch(err){}\nif(int_key !==undefined){var items=self.valueOf(),pos=int_key\nif(int_key < 0){pos=items.length+pos}\nif(pos >=0 && pos < items.length){return items[pos]}\nthrow _b_.IndexError.$factory($B.class_name(self)+\n\" index out of range\")}\nif(key.__class__===_b_.slice ||isinstance(key,_b_.slice)){\nif(key.start===_b_.None && key.stop===_b_.None &&\nkey.step===_b_.None){return self.slice()}\nvar s=_b_.slice.$conv_for_seq(key,self.length)\nvar res=[],i=null,items=self.valueOf(),pos=0,start=s.start,stop=s.stop,step=s.step\nif(step > 0){if(stop <=start){return factory(res)}\nfor(var i=start;i < stop;i+=step){res[pos++]=items[i]}\nreturn factory(res)}else{if(stop > start){return factory(res)}\nfor(var i=start;i > stop;i+=step){res[pos++]=items[i]}\nreturn factory(res)}}\nthrow _b_.TypeError.$factory($B.class_name(self)+\n\" indices must be integer, not \"+$B.class_name(key))}\nlist.__ge__=function(self,other){if(! isinstance(other,[list,_b_.tuple])){return _b_.NotImplemented}\nvar i=0\nwhile(i < self.length){if(i >=other.length){return true}\nif($B.rich_comp(\"__eq__\",self[i],other[i])){i++}\nelse{res=$B.$getattr(self[i],\"__ge__\")(other[i])\nif(res===_b_.NotImplemented){throw _b_.TypeError.$factory(\"unorderable types: \"+\n$B.class_name(self[i])+\"() >= \"+\n$B.class_name(other[i])+\"()\")}else{return res}}}\nreturn other.length==self.length}\nlist.__gt__=function(self,other){if(! isinstance(other,[list,_b_.tuple])){return _b_.NotImplemented}\nvar i=0\nwhile(i < self.length){if(i >=other.length){return true}\nif($B.rich_comp(\"__eq__\",self[i],other[i])){i++}\nelse{res=$B.$getattr(self[i],\"__gt__\")(other[i])\nif(res===_b_.NotImplemented){throw _b_.TypeError.$factory(\"unorderable types: \"+\n$B.class_name(self[i])+\"() > \"+\n$B.class_name(other[i])+\"()\")}else return res}}\nreturn false}\nlist.__hash__=$N\nlist.__iadd__=function(){var $=$B.args(\"__iadd__\",2,{self:null,x:null},[\"self\",\"x\"],arguments,{},null,null)\nvar x=list.$factory($B.$iter($.x))\nfor(var i=0;i < x.length;i++){$.self.push(x[i])}\nreturn $.self}\nlist.__imul__=function(){var $=$B.args(\"__imul__\",2,{self:null,x:null},[\"self\",\"x\"],arguments,{},null,null),x=$B.$GetInt($.x),len=$.self.length,pos=len\nif(x==0){list.clear($.self);return $.self}\nfor(var i=1;i < x;i++){for(j=0;j < len;j++){$.self[pos++]=$.self[j]}}\nreturn $.self}\nlist.__init__=function(self,arg){var $=$B.args('__init__',1,{self:null},['self'],arguments,{},'args',null),self=$.self,args=$.args\nif(args.length > 1){throw _b_.TypeError.$factory('expected at most 1 argument, got '+\nargs.length)}\nvar arg=args[0]\nvar len_func=$B.$call($B.$getattr(self,\"__len__\")),pop_func=$B.$getattr(self,\"pop\",$N)\nif(pop_func !==$N){pop_func=$B.$call(pop_func)\nwhile(len_func()){pop_func()}}\nif(arg===undefined){return $N}\nvar arg=$B.$iter(arg),next_func=$B.$call($B.$getattr(arg,\"__next__\")),pos=len_func()\nwhile(1){try{var res=next_func()\nself[pos++]=res}catch(err){if(err.__class__===_b_.StopIteration){break}\nelse{throw err}}}\nreturn $N}\nvar list_iterator=$B.make_iterator_class(\"list_iterator\")\nlist_iterator.__reduce__=list_iterator.__reduce_ex__=function(self){return $B.fast_tuple([_b_.iter,$B.fast_tuple([list.$factory(self)]),0])}\nlist.__iter__=function(self){return list_iterator.$factory(self)}\nlist.__le__=function(self,other){var res=list.__ge__(self,other)\nif(res===_b_.NotImplemented){return res}\nreturn ! res}\nlist.__len__=function(self){return self.length}\nlist.__lt__=function(self,other){if(! isinstance(other,[list,_b_.tuple])){return _b_.NotImplemented}\nvar i=0\nwhile(i < self.length){if(i >=other.length){return false}\nif($B.rich_comp(\"__eq__\",self[i],other[i])){i++}else{res=$B.$getattr(self[i],\"__lt__\")(other[i])\nif(res===_b_.NotImplemented){throw _b_.TypeError.$factory(\"unorderable types: \"+\n$B.class_name(self[i])+\"() >= \"+\n$B.class_name(other[i])+\"()\")}else{return res}}}\nreturn other.length > self.length}\nlist.__mul__=function(self,other){if(isinstance(other,_b_.int)){other=_b_.int.numerator(other)\nvar res=[],$temp=self.slice(),len=$temp.length\nfor(var i=0;i < other;i++){for(var j=0;j < len;j++){res.push($temp[j])}}\nres.__class__=self.__class__\nreturn res}\nif(_b_.hasattr(other,\"__int__\")||_b_.hasattr(other,\"__index__\")){return list.__mul__(self,_b_.int.$factory(other))}\nvar rmul=$B.$getattr(other,'__rmul__',null)\nif(rmul===null){throw _b_.TypeError.$factory(`can't multiply sequence by non-int `+\n`of type '${$B.class_name(other)}'`)}\nreturn _b_.NotImplemented}\nlist.__new__=function(cls,...args){if(cls===undefined){throw _b_.TypeError.$factory(\"list.__new__(): not enough arguments\")}\nvar res=[]\nres.__class__=cls\nres.__brython__=true\nres.__dict__=$B.empty_dict()\nreturn res}\nfunction __newobj__(){\nvar $=$B.args('__newobj__',0,{},[],arguments,{},'args',null),args=$.args\nvar res=args.slice(1)\nres.__class__=args[0]\nreturn res}\nlist.__reduce_ex__=function(self){return $B.fast_tuple([__newobj__,$B.fast_tuple([self.__class__]),_b_.None,_b_.iter(self)])}\nlist.__repr__=function(self){$B.builtins_repr_check(list,arguments)\nreturn list_repr(self)}\nfunction list_repr(self){\nif($B.repr.enter(self)){\nreturn '[...]'}\nvar _r=[],res\nfor(var i=0;i < self.length;i++){_r.push(_b_.repr(self[i]))}\nif(_b_.isinstance(self,tuple)){if(self.length==1){res=\"(\"+_r[0]+\",)\"}else{res=\"(\"+_r.join(\", \")+\")\"}}else{res=\"[\"+_r.join(\", \")+\"]\"}\n$B.repr.leave(self)\nreturn res}\nlist.__rmul__=function(self,other){return list.__mul__(self,other)}\nlist.__setattr__=function(self,attr,value){if(self.__class__===list ||self.__class__===tuple){var cl_name=$B.class_name(self)\nif(list.hasOwnProperty(attr)){throw _b_.AttributeError.$factory(\"'\"+cl_name+\n\"' object attribute '\"+attr+\"' is read-only\")}else{throw _b_.AttributeError.$factory(\n\"'\"+cl_name+\" object has no attribute '\"+attr+\"'\")}}\n_b_.dict.$setitem(self.__dict__,attr,value)\nreturn $N}\nlist.__setitem__=function(){var $=$B.args(\"__setitem__\",3,{self:null,key:null,value:null},[\"self\",\"key\",\"value\"],arguments,{},null,null),self=$.self,arg=$.key,value=$.value\nlist.$setitem(self,arg,value)}\nlist.$setitem=function(self,arg,value){\nif(typeof arg==\"number\" ||isinstance(arg,_b_.int)){var pos=arg\nif(arg < 0){pos=self.length+pos}\nif(pos >=0 && pos < self.length){self[pos]=value}else{throw _b_.IndexError.$factory(\"list index out of range\")}\nreturn $N}\nif(isinstance(arg,_b_.slice)){var s=_b_.slice.$conv_for_seq(arg,self.length)\nif(arg.step===null){$B.set_list_slice(self,s.start,s.stop,value)}else{$B.set_list_slice_step(self,s.start,s.stop,s.step,value)}\nreturn $N}\nif(_b_.hasattr(arg,\"__int__\")||_b_.hasattr(arg,\"__index__\")){list.__setitem__(self,_b_.int.$factory(arg),value)\nreturn $N}\nthrow _b_.TypeError.$factory(\"list indices must be integer, not \"+\n$B.class_name(arg))}\nlist.append=function(self,x){$B.check_no_kw(\"append\",self,x)\n$B.check_nb_args(\"append\",2,arguments)\nself.push(x)\nreturn $N}\nlist.clear=function(){var $=$B.args(\"clear\",1,{self:null},[\"self\"],arguments,{},null,null)\nwhile($.self.length){$.self.pop()}\nreturn $N}\nlist.copy=function(){var $=$B.args(\"copy\",1,{self:null},[\"self\"],arguments,{},null,null)\nreturn $.self.slice()}\nlist.count=function(){var $=$B.args(\"count\",2,{self:null,x:null},[\"self\",\"x\"],arguments,{},null,null)\nvar res=0,_eq=function(other){return $B.rich_comp(\"__eq__\",$.x,other)},i=$.self.length\nwhile(i--){if(_eq($.self[i])){res++}}\nreturn res}\nlist.extend=function(){var $=$B.args(\"extend\",2,{self:null,t:null},[\"self\",\"t\"],arguments,{},null,null)\nvar other=list.$factory($B.$iter($.t))\nfor(var i=0;i < other.length;i++){$.self.push(other[i])}\nreturn $N}\nlist.index=function(){var missing={},$=$B.args(\"index\",4,{self:null,x:null,start:null,stop:null},[\"self\",\"x\",\"start\" ,\"stop\"],arguments,{start:0,stop:missing},null,null),self=$.self,start=$.start,stop=$.stop\nvar _eq=function(other){return $B.rich_comp(\"__eq__\",$.x,other)}\nif(start.__class__===$B.long_int){start=parseInt(start.value)*(start.pos ? 1 :-1)}\nif(start < 0){start=Math.max(0,start+self.length)}\nif(stop===missing){stop=self.length}\nelse{if(stop.__class__===$B.long_int){stop=parseInt(stop.value)*(stop.pos ? 1 :-1)}\nif(stop < 0){stop=Math.min(self.length,stop+self.length)}\nstop=Math.min(stop,self.length)}\nfor(var i=start;i < stop;i++){if(_eq(self[i])){return i}}\nthrow _b_.ValueError.$factory(_b_.repr($.x)+\" is not in \"+\n$B.class_name(self))}\nlist.insert=function(){var $=$B.args(\"insert\",3,{self:null,i:null,item:null},[\"self\",\"i\",\"item\"],arguments,{},null,null)\n$.self.splice($.i,0,$.item)\nreturn $N}\nlist.pop=function(){var missing={}\nvar $=$B.args(\"pop\",2,{self:null,pos:null},[\"self\",\"pos\"],arguments,{pos:missing},null,null),self=$.self,pos=$.pos\ncheck_not_tuple(self,\"pop\")\nif(pos===missing){pos=self.length-1}\npos=$B.$GetInt(pos)\nif(pos < 0){pos+=self.length}\nvar res=self[pos]\nif(res===undefined){throw _b_.IndexError.$factory(\"pop index out of range\")}\nself.splice(pos,1)\nreturn res}\nlist.remove=function(){var $=$B.args(\"remove\",2,{self:null,x:null},[\"self\",\"x\"],arguments,{},null,null)\nfor(var i=0,len=$.self.length;i < len;i++){if($B.rich_comp(\"__eq__\",$.self[i],$.x)){$.self.splice(i,1)\nreturn $N}}\nthrow _b_.ValueError.$factory(_b_.str.$factory($.x)+\" is not in list\")}\nlist.reverse=function(self){var $=$B.args(\"reverse\",1,{self:null},[\"self\"],arguments,{},null,null),_len=$.self.length-1,i=parseInt($.self.length/2)\nwhile(i--){var buf=$.self[i]\n$.self[i]=$.self[_len-i]\n$.self[_len-i]=buf}\nreturn $N}\nfunction $partition(arg,array,begin,end,pivot)\n{var piv=array[pivot]\narray=swap(array,pivot,end-1)\nvar store=begin\nif(arg===null){if(array.$cl !==false){\nvar le_func=_b_.getattr(array.$cl,\"__le__\")\nfor(var ix=begin;ix < end-1;++ix){if(le_func(array[ix],piv)){array=swap(array,store,ix);\n++store}}}else{for(var ix=begin;ix < end-1;++ix){if($B.$getattr(array[ix],\"__le__\")(piv)){array=swap(array,store,ix)\n++store}}}}else{var len=array.length\nfor(var ix=begin;ix < end-1;++ix){var x=arg(array[ix])\nif(array.length !==len){throw _b_.ValueError.$factory(\"list modified during sort\")}\nif($B.$getattr(x,\"__le__\")(arg(piv))){array=swap(array,store,ix)\n++store}}}\narray=swap(array,end-1,store)\nreturn store}\nfunction swap(_array,a,b){var tmp=_array[a]\n_array[a]=_array[b]\n_array[b]=tmp\nreturn _array}\nfunction $qsort(arg,array,begin,end){if(end-1 > begin){var pivot=begin+Math.floor(Math.random()*(end-begin))\npivot=$partition(arg,array,begin,end,pivot)\n$qsort(arg,array,begin,pivot)\n$qsort(arg,array,pivot+1,end)}}\nfunction $elts_class(self){\nif(self.length==0){return null}\nvar cl=$B.get_class(self[0]),i=self.length\nwhile(i--){if($B.get_class(self[i])!==cl){return false}}\nreturn cl}\nlist.sort=function(self){var $=$B.args(\"sort\",1,{self:null},[\"self\"],arguments,{},null,\"kw\")\ncheck_not_tuple(self,\"sort\")\nvar func=$N,reverse=false,kw_args=$.kw,keys=_b_.list.$factory(_b_.dict.keys(kw_args))\nfor(var i=0;i < keys.length;i++){if(keys[i]==\"key\"){func=kw_args.$string_dict[keys[i]][0]}else if(keys[i]==\"reverse\"){reverse=kw_args.$string_dict[keys[i]][0]}else{throw _b_.TypeError.$factory(\"'\"+keys[i]+\n\"' is an invalid keyword argument for this function\")}}\nif(self.length==0){return}\nif(func !==$N){func=$B.$call(func)}\nself.$cl=$elts_class(self)\nvar cmp=null;\nif(func===$N && self.$cl===_b_.str){if(reverse){cmp=function(b,a){return $B.$AlphabeticalCompare(a,b)}}else{cmp=function(a,b){return $B.$AlphabeticalCompare(a,b)}}}else if(func===$N && self.$cl===_b_.int){if(reverse){cmp=function(b,a){return a-b}}else{cmp=function(a,b){return a-b}}}else{if(func===$N){if(reverse){cmp=function(b,a){res=$B.$getattr(a,\"__lt__\")(b)\nif(res===_b_.NotImplemented){throw _b_.TypeError.$factory(\"unorderable types: \"+\n$B.class_name(b)+\"() < \"+\n$B.class_name(a)+\"()\")}\nif(res){if(a==b){return 0}\nreturn-1}\nreturn 1}}else{cmp=function(a,b){res=$B.$getattr(a,\"__lt__\")(b)\nif(res===_b_.NotImplemented){throw _b_.TypeError.$factory(\"unorderable types: \"+\n$B.class_name(a)+\"() < \"+\n$B.class_name(b)+\"()\")}\nif(res){if(a==b){return 0}\nreturn-1}\nreturn 1}}}else{if(reverse){cmp=function(b,a){var _a=func(a),_b=func(b)\nres=$B.$getattr(_a,\"__lt__\")(_b)\nif(res===_b_.NotImplemented){throw _b_.TypeError.$factory(\"unorderable types: \"+\n$B.class_name(b)+\"() < \"+\n$B.class_name(a)+\"()\")}\nif(res){if(_a==_b){return 0}\nreturn-1}\nreturn 1}}else{cmp=function(a,b){var _a=func(a),_b=func(b)\nres=$B.$getattr(_a,\"__lt__\")(_b)\nif(res===_b_.NotImplemented){throw _b_.TypeError.$factory(\"unorderable types: \"+\n$B.class_name(a)+\"() < \"+\n$B.class_name(b)+\"()\")}\nif(res){if(_a==_b){return 0}\nreturn-1}\nreturn 1}}}}\n$B.$TimSort(self,cmp)\nreturn(self.__brython__ ? $N :self)}\n$B.$list=function(t){t.__brython__=true\nt.__class__=_b_.list\nreturn t}\nlist.$factory=function(){if(arguments.length==0){return[]}\nvar $=$B.args(\"list\",1,{obj:null},[\"obj\"],arguments,{},null,null),obj=$.obj\nif(Array.isArray(obj)){\nobj=obj.slice()\nobj.__brython__=true;\nif(obj.__class__==tuple){var res=obj.slice()\nres.__class__=list\nreturn res}\nreturn obj}\nvar res=[],pos=0,arg=$B.$iter(obj),next_func=$B.$call($B.$getattr(arg,\"__next__\"))\nwhile(1){try{res[pos++]=next_func()}catch(err){if(!isinstance(err,_b_.StopIteration)){throw err}\nbreak}}\nres.__brython__=true \nreturn res}\n$B.set_func_names(list,\"builtins\")\nlist.__class_getitem__=_b_.classmethod.$factory(list.__class_getitem__)\nvar JSArray=$B.JSArray=$B.make_class(\"JSArray\",function(array){return{\n__class__:JSArray,js:array}}\n)\nJSArray.__repr__=JSArray.__str__=function(){return \"<JSArray object>\"}\nfunction make_args(args){var res=[args[0].js]\nfor(var i=1,len=args.length;i < len;i++){res.push(args[i])}\nreturn res}\nfor(var attr in list){if($B.JSArray[attr]!==undefined){continue}\nif(typeof list[attr]==\"function\"){$B.JSArray[attr]=(function(fname){return function(){return $B.$JS2Py(list[fname].apply(null,make_args(arguments)))}})(attr)}}\n$B.set_func_names($B.JSArray,\"builtins\")\nfunction $tuple(arg){return arg}\nvar tuple={__class__:_b_.type,__mro__:[object],$infos:{__module__:\"builtins\",__name__:\"tuple\"},$is_class:true,$native:true,$match_sequence_pattern:true,}\nvar tuple_iterator=$B.make_iterator_class(\"tuple_iterator\")\ntuple.__iter__=function(self){return tuple_iterator.$factory(self)}\ntuple.$factory=function(){var obj=list.$factory(...arguments)\nobj.__class__=tuple\nreturn obj}\n$B.fast_tuple=function(array){array.__class__=tuple\narray.__brython__=true\narray.__dict__=$B.empty_dict()\nreturn array}\nfor(var attr in list){switch(attr){case \"__delitem__\":\ncase \"__iadd__\":\ncase \"__imul__\":\ncase \"__setitem__\":\ncase \"append\":\ncase \"extend\":\ncase \"insert\":\ncase \"remove\":\ncase \"reverse\":\nbreak\ndefault:\nif(tuple[attr]===undefined){if(typeof list[attr]==\"function\"){tuple[attr]=(function(x){return function(){return list[x].apply(null,arguments)}})(attr)}}}}\ntuple.__eq__=function(self,other){\nif(other===undefined){return self===tuple}\nreturn list.__eq__(self,other)}\nfunction c_mul(a,b){s=((parseInt(a)*b)& 0xFFFFFFFF).toString(16)\nreturn parseInt(s.substr(0,s.length-1),16)}\ntuple.__hash__=function(self){\nvar x=0x3456789\nfor(var i=0,len=self.length;i < len;i++){var y=_b_.hash(self[i])\nx=c_mul(1000003,x)^ y & 0xFFFFFFFF}\nreturn x}\ntuple.__init__=function(){\nreturn $N}\ntuple.__new__=function(cls,...args){if(cls===undefined){throw _b_.TypeError.$factory(\"list.__new__(): not enough arguments\")}\nvar self=[]\nself.__class__=cls\nself.__brython__=true\nself.__dict__=$B.empty_dict()\nvar arg=$B.$iter(args[0]),next_func=$B.$call($B.$getattr(arg,\"__next__\"))\nwhile(1){try{var item=next_func()\nself.push(item)}\ncatch(err){if(err.__class__===_b_.StopIteration){break}\nelse{throw err}}}\nreturn self}\ntuple.__reduce_ex__=function(self){return $B.fast_tuple([__newobj__,$B.fast_tuple([self.__class__].concat(self.slice())),_b_.None,_b_.None])}\ntuple.__repr__=function(self){$B.builtins_repr_check(tuple,arguments)\nreturn list_repr(self)}\n$B.set_func_names(tuple,\"builtins\")\n_b_.list=list\n_b_.tuple=tuple\n_b_.object.__bases__=tuple.$factory()\n_b_.type.__bases__=$B.fast_tuple([_b_.object])})(__BRYTHON__)\n;\n;(function($B){\nvar _b_=$B.builtins\nvar $GeneratorReturn={}\n$B.generator_return=function(value){return{__class__:$GeneratorReturn,value:value}}\n$B.generator=$B.make_class(\"generator\",function(func,name){\nvar res=function(){var gen=func.apply(null,arguments)\ngen.$name=name ||'generator'\ngen.$func=func\ngen.$has_run=false\nreturn{\n__class__:$B.generator,js_gen:gen}}\nres.$infos=func.$infos\nres.$is_genfunc=true\nres.$name=name\nreturn res}\n)\n$B.generator.__iter__=function(self){return self}\n$B.generator.__next__=function(self){return $B.generator.send(self,_b_.None)}\n$B.generator.__str__=function(self){return '<'+self.$name+' object>'}\n$B.generator.close=function(self){try{$B.generator.throw(self,_b_.GeneratorExit.$factory())}catch(err){if(! $B.is_exc(err,[_b_.GeneratorExit,_b_.StopIteration])){throw _b_.RuntimeError.$factory(\"generator ignored GeneratorExit\")}}}\n$B.generator.send=function(self,value){\nvar gen=self.js_gen\ngen.$has_run=true\nif(gen.$finished){throw _b_.StopIteration.$factory(value)}\nif(gen.gi_running===true){throw _b_.ValueError.$factory(\"generator already executing\")}\ngen.gi_running=true\ntry{var res=gen.next(value)}catch(err){gen.$finished=true\nthrow err}\nif(res.value && res.value.__class__===$GeneratorReturn){gen.$finished=true\nthrow _b_.StopIteration.$factory(res.value.value)}\ngen.gi_running=false\nif(res.done){throw _b_.StopIteration.$factory(res.value)}\nreturn res.value}\n$B.generator.throw=function(self,type,value,traceback){var gen=self.js_gen,exc=type\nif(exc.$is_class){if(! _b_.issubclass(type,_b_.BaseException)){throw _b_.TypeError.$factory(\"exception value must be an \"+\n\"instance of BaseException\")}else if(value===undefined){exc=$B.$call(exc)()}else if(_b_.isinstance(value,type)){exc=value}}else{if(value===undefined){value=exc}else{exc=$B.$call(exc)(value)}}\nif(traceback !==undefined){exc.$traceback=traceback}\nvar res=gen.throw(exc)\nif(res.done){throw _b_.StopIteration.$factory(\"StopIteration\")}\nreturn res.value}\n$B.set_func_names($B.generator,\"builtins\")\n$B.async_generator=$B.make_class(\"async_generator\",function(func){var f=function(){var gen=func.apply(null,arguments)\nvar res=Object.create(null)\nres.__class__=$B.async_generator\nres.js_gen=gen\nreturn res}\nreturn f}\n)\nvar ag_closed={}\n$B.async_generator.__aiter__=function(self){return self}\n$B.async_generator.__anext__=function(self){return $B.async_generator.asend(self,_b_.None)}\n$B.async_generator.aclose=function(self){self.js_gen.$finished=true\nreturn _b_.None}\n$B.async_generator.asend=async function(self,value){var gen=self.js_gen\nif(gen.$finished){throw _b_.StopAsyncIteration.$factory(value)}\nif(gen.ag_running===true){throw _b_.ValueError.$factory(\"generator already executing\")}\ngen.ag_running=true\ntry{var res=await gen.next(value)}catch(err){gen.$finished=true\nthrow err}\nif(res.done){throw _b_.StopAsyncIteration.$factory(value)}\nif(res.value.__class__===$GeneratorReturn){gen.$finished=true\nthrow _b_.StopAsyncIteration.$factory(res.value.value)}\ngen.ag_running=false\nreturn res.value}\n$B.async_generator.athrow=async function(self,type,value,traceback){var gen=self.js_gen,exc=type\nif(exc.$is_class){if(! _b_.issubclass(type,_b_.BaseException)){throw _b_.TypeError.$factory(\"exception value must be an \"+\n\"instance of BaseException\")}else if(value===undefined){value=$B.$call(exc)()}}else{if(value===undefined){value=exc}else{exc=$B.$call(exc)(value)}}\nif(traceback !==undefined){exc.$traceback=traceback}\nawait gen.throw(value)}\n$B.set_func_names($B.async_generator,\"builtins\")\nfunction rstrip(s,strip_chars){var _chars=strip_chars ||\" \\t\\n\";\nvar nstrip=0,len=s.length;\nwhile(nstrip < len && _chars.indexOf(s.charAt(len-1-nstrip))>-1)nstrip++;\nreturn s.substr(0,len-nstrip)}})(__BRYTHON__)\n;\n;(function($B){var _b_=$B.builtins,object=_b_.object,_window=self\nfunction $getMouseOffset(target,ev){ev=ev ||_window.event;\nvar docPos=$getPosition(target);\nvar mousePos=$mouseCoords(ev);\nreturn{x:mousePos.x-docPos.x,y:mousePos.y-docPos.y};}\nfunction $getPosition(e){var left=0,top=0,width=e.width ||e.offsetWidth,height=e.height ||e.offsetHeight,scroll=document.scrollingElement.scrollTop\nwhile(e.offsetParent){left+=e.offsetLeft\ntop+=e.offsetTop\ne=e.offsetParent}\nleft+=e.offsetLeft ||0\ntop+=e.offsetTop ||0\nif(e.parentElement){\nvar parent_pos=$getPosition(e.parentElement)\nleft+=parent_pos.left\ntop+=parent_pos.top}\nreturn{left:left,top:top,width:width,height:height}}\nfunction trace(msg){var elt=document.getElementById(\"trace\")\nif(elt){elt.innerText+=msg}}\nfunction $mouseCoords(ev){if(ev.type.startsWith(\"touch\")){var res={}\nres.x=_b_.int.$factory(ev.touches[0].screenX)\nres.y=_b_.int.$factory(ev.touches[0].screenY)\nres.__getattr__=function(attr){return this[attr]}\nres.__class__=\"MouseCoords\"\nreturn res}\nvar posx=0,posy=0\nif(!ev){var ev=_window.event}\nif(ev.pageX ||ev.pageY){posx=ev.pageX\nposy=ev.pageY}else if(ev.clientX ||ev.clientY){posx=ev.clientX+document.body.scrollLeft+\ndocument.documentElement.scrollLeft\nposy=ev.clientY+document.body.scrollTop+\ndocument.documentElement.scrollTop}\nvar res={}\nres.x=_b_.int.$factory(posx)\nres.y=_b_.int.$factory(posy)\nres.__getattr__=function(attr){return this[attr]}\nres.__class__=\"MouseCoords\"\nreturn res}\nvar $DOMNodeAttrs=[\"nodeName\",\"nodeValue\",\"nodeType\",\"parentNode\",\"childNodes\",\"firstChild\",\"lastChild\",\"previousSibling\",\"nextSibling\",\"attributes\",\"ownerDocument\"]\n$B.$isNode=function(o){\nreturn(\ntypeof Node===\"object\" ? o instanceof Node :\no && typeof o===\"object\" && typeof o.nodeType===\"number\" &&\ntypeof o.nodeName===\"string\"\n)}\n$B.$isNodeList=function(nodes){\ntry{var result=Object.prototype.toString.call(nodes)\nvar re=new RegExp(\"^\\\\[object (HTMLCollection|NodeList)\\\\]$\")\nreturn(typeof nodes===\"object\" &&\nre.exec(result)!==null &&\nnodes.length !==undefined &&\n(nodes.length==0 ||\n(typeof nodes[0]===\"object\" && nodes[0].nodeType > 0))\n)}catch(err){return false}}\nvar $DOMEventAttrs_W3C=[\"NONE\",\"CAPTURING_PHASE\",\"AT_TARGET\",\"BUBBLING_PHASE\",\"type\",\"target\",\"currentTarget\",\"eventPhase\",\"bubbles\",\"cancelable\",\"timeStamp\",\"stopPropagation\",\"preventDefault\",\"initEvent\"]\nvar $DOMEventAttrs_IE=[\"altKey\",\"altLeft\",\"button\",\"cancelBubble\",\"clientX\",\"clientY\",\"contentOverflow\",\"ctrlKey\",\"ctrlLeft\",\"data\",\"dataFld\",\"dataTransfer\",\"fromElement\",\"keyCode\",\"nextPage\",\"offsetX\",\"offsetY\",\"origin\",\"propertyName\",\"reason\",\"recordset\",\"repeat\",\"screenX\",\"screenY\",\"shiftKey\",\"shiftLeft\",\"source\",\"srcElement\",\"srcFilter\",\"srcUrn\",\"toElement\",\"type\",\"url\",\"wheelDelta\",\"x\",\"y\"]\n$B.$isEvent=function(obj){var flag=true\nfor(var i=0;i < $DOMEventAttrs_W3C.length;i++){if(obj[$DOMEventAttrs_W3C[i]]===undefined){flag=false;break}}\nif(flag){return true}\nfor(var i=0;i < $DOMEventAttrs_IE.length;i++){if(obj[$DOMEventAttrs_IE[i]]===undefined){return false}}\nreturn true}\nvar $NodeTypes={1:\"ELEMENT\",2:\"ATTRIBUTE\",3:\"TEXT\",4:\"CDATA_SECTION\",5:\"ENTITY_REFERENCE\",6:\"ENTITY\",7:\"PROCESSING_INSTRUCTION\",8:\"COMMENT\",9:\"DOCUMENT\",10:\"DOCUMENT_TYPE\",11:\"DOCUMENT_FRAGMENT\",12:\"NOTATION\"}\nvar Attributes=$B.make_class(\"Attributes\",function(elt){return{__class__:Attributes,elt:elt}}\n)\nAttributes.__contains__=function(){var $=$B.args(\"__getitem__\",2,{self:null,key:null},[\"self\",\"key\"],arguments,{},null,null)\nif($.self.elt instanceof SVGElement){return $.self.elt.hasAttributeNS(null,$.key)}else if(typeof $.self.elt.hasAttribute==\"function\"){return $.self.elt.hasAttribute($.key)}\nreturn false}\nAttributes.__delitem__=function(){var $=$B.args(\"__getitem__\",2,{self:null,key:null},[\"self\",\"key\"],arguments,{},null,null)\nif(!Attributes.__contains__($.self,$.key)){throw _b_.KeyError.$factory($.key)}\nif($.self.elt instanceof SVGElement){$.self.elt.removeAttributeNS(null,$.key)\nreturn _b_.None}else if(typeof $.self.elt.hasAttribute==\"function\"){$.self.elt.removeAttribute($.key)\nreturn _b_.None}}\nAttributes.__getitem__=function(){var $=$B.args(\"__getitem__\",2,{self:null,key:null},[\"self\",\"key\"],arguments,{},null,null)\nif($.self.elt instanceof SVGElement &&\n$.self.elt.hasAttributeNS(null,$.key)){return $.self.elt.getAttributeNS(null,$.key)}else if(typeof $.self.elt.hasAttribute==\"function\" &&\n$.self.elt.hasAttribute($.key)){return $.self.elt.getAttribute($.key)}\nthrow _b_.KeyError.$factory($.key)}\nAttributes.__iter__=function(self){self.$counter=0\nvar attrs=self.elt.attributes,items=[]\nfor(var i=0;i < attrs.length;i++){items.push(attrs[i].name)}\nself.$items=items\nreturn self}\nAttributes.__next__=function(){var $=$B.args(\"__next__\",1,{self:null},[\"self\"],arguments,{},null,null)\nif($.self.$counter < $.self.$items.length){var res=$.self.$items[$.self.$counter]\n$.self.$counter++\nreturn res}else{throw _b_.StopIteration.$factory(\"\")}}\nAttributes.__setitem__=function(){var $=$B.args(\"__setitem__\",3,{self:null,key:null,value:null},[\"self\",\"key\",\"value\"],arguments,{},null,null)\nif($.self.elt instanceof SVGElement &&\ntypeof $.self.elt.setAttributeNS==\"function\"){$.self.elt.setAttributeNS(null,$.key,$.value)\nreturn _b_.None}else if(typeof $.self.elt.setAttribute==\"function\"){$.self.elt.setAttribute($.key,$.value)\nreturn _b_.None}\nthrow _b_.TypeError.$factory(\"Can't set attributes on element\")}\nAttributes.__repr__=Attributes.__str__=function(self){var attrs=self.elt.attributes,items=[]\nfor(var i=0;i < attrs.length;i++){items.push(attrs[i].name+': \"'+\nself.elt.getAttributeNS(null,attrs[i].name)+'\"')}\nreturn '{'+items.join(\", \")+'}'}\nAttributes.get=function(){var $=$B.args(\"get\",3,{self:null,key:null,deflt:null},[\"self\",\"key\",\"deflt\"],arguments,{deflt:_b_.None},null,null)\ntry{return Attributes.__getitem__($.self,$.key)}catch(err){if(err.__class__===_b_.KeyError){return $.deflt}else{throw err}}}\nAttributes.keys=function(){return Attributes.__iter__.apply(null,arguments)}\nAttributes.items=function(){var $=$B.args(\"values\",1,{self:null},[\"self\"],arguments,{},null,null),attrs=$.self.elt.attributes,values=[]\nfor(var i=0;i < attrs.length;i++){values.push([attrs[i].name,attrs[i].value])}\nreturn _b_.list.__iter__(values)}\nAttributes.values=function(){var $=$B.args(\"values\",1,{self:null},[\"self\"],arguments,{},null,null),attrs=$.self.elt.attributes,values=[]\nfor(var i=0;i < attrs.length;i++){values.push(attrs[i].value)}\nreturn _b_.list.__iter__(values)}\n$B.set_func_names(Attributes,\"<dom>\")\nvar DOMEvent=$B.DOMEvent={__class__:_b_.type,__mro__:[object],$infos:{__name__:\"DOMEvent\"}}\nDOMEvent.__new__=function(cls,evt_name){var ev=new Event(evt_name)\nev.__class__=DOMEvent\nif(ev.preventDefault===undefined){ev.preventDefault=function(){ev.returnValue=false}}\nif(ev.stopPropagation===undefined){ev.stopPropagation=function(){ev.cancelBubble=true}}\nreturn ev}\nfunction dom2svg(svg_elt,coords){\nvar pt=svg_elt.createSVGPoint()\npt.x=coords.x\npt.y=coords.y\nreturn pt.matrixTransform(svg_elt.getScreenCTM().inverse())}\nDOMEvent.__getattribute__=function(self,attr){switch(attr){case '__repr__':\ncase '__str__':\nreturn function(){return '<DOMEvent object>'}\ncase 'x':\nreturn $mouseCoords(self).x\ncase 'y':\nreturn $mouseCoords(self).y\ncase 'data':\nif(self.dataTransfer !==null){return Clipboard.$factory(self.dataTransfer)}\nreturn $B.$JS2Py(self['data'])\ncase 'target':\nif(self.target !==undefined){return DOMNode.$factory(self.target)}\ncase 'char':\nreturn String.fromCharCode(self.which)\ncase 'svgX':\nif(self.target instanceof SVGSVGElement){return Math.floor(dom2svg(self.target,$mouseCoords(self)).x)}\nthrow _b_.AttributeError.$factory(\"event target is not an SVG \"+\n\"element\")\ncase 'svgY':\nif(self.target instanceof SVGSVGElement){return Math.floor(dom2svg(self.target,$mouseCoords(self)).y)}\nthrow _b_.AttributeError.$factory(\"event target is not an SVG \"+\n\"element\")}\nvar res=self[attr]\nif(res !==undefined){if(typeof res==\"function\"){var func=function(){var args=[]\nfor(var i=0;i < arguments.length;i++){args.push($B.pyobj2jsobj(arguments[i]))}\nreturn res.apply(self,arguments)}\nfunc.$infos={__name__:res.name,__qualname__:res.name}\nreturn func}\nreturn $B.$JS2Py(res)}\nthrow $B.attr_error(attr,self)}\nDOMEvent.$factory=function(evt_name){\nreturn DOMEvent.__new__(DOMEvent,evt_name)}\nvar $DOMEvent=$B.$DOMEvent=function(ev){ev.__class__=DOMEvent\nev.$no_dict=true\nif(ev.preventDefault===undefined){ev.preventDefault=function(){ev.returnValue=false}}\nif(ev.stopPropagation===undefined){ev.stopPropagation=function(){ev.cancelBubble=true}}\nreturn ev}\n$B.set_func_names(DOMEvent,\"browser\")\nvar Clipboard={__class__:_b_.type,$infos:{__module__:\"browser\",__name__:\"Clipboard\"}}\nClipboard.__getitem__=function(self,name){return self.data.getData(name)}\nClipboard.__mro__=[object]\nClipboard.__setitem__=function(self,name,value){self.data.setData(name,value)}\nClipboard.$factory=function(data){\nreturn{\n__class__ :Clipboard,__dict__:$B.empty_dict(),data :data}}\n$B.set_func_names(Clipboard,\"<dom>\")\nfunction $EventsList(elt,evt,arg){\nthis.elt=elt\nthis.evt=evt\nif(_b_.isinstance(arg,_b_.list)){this.callbacks=arg}\nelse{this.callbacks=[arg]}\nthis.remove=function(callback){var found=false\nfor(var i=0;i < this.callbacks.length;i++){if(this.callbacks[i]===callback){found=true\nthis.callback.splice(i,1)\nthis.elt.removeEventListener(this.evt,callback,false)\nbreak}}\nif(! found){throw _b_.KeyError.$factory(\"not found\")}}}\nvar OpenFile=$B.OpenFile={__class__:_b_.type,\n__mro__:[object],$infos:{__module__:\"<pydom>\",__name__:\"OpenFile\"}}\nOpenFile.$factory=function(file,mode,encoding){var res={__class__:$OpenFileDict,file:file,reader:new FileReader()}\nif(mode===\"r\"){res.reader.readAsText(file,encoding)}else if(mode===\"rb\"){res.reader.readAsBinaryString(file)}\nreturn res}\nOpenFile.__getattr__=function(self,attr){if(self[\"get_\"+attr]!==undefined){return self[\"get_\"+attr]}\nreturn self.reader[attr]}\nOpenFile.__setattr__=function(self,attr,value){var obj=self.reader\nif(attr.substr(0,2)==\"on\"){\nvar callback=function(ev){return value($DOMEvent(ev))}\nobj.addEventListener(attr.substr(2),callback)}else if(\"set_\"+attr in obj){return obj[\"set_\"+attr](value)}else if(attr in obj){obj[attr]=value}else{_b_.setattr(obj,attr,value)}}\n$B.set_func_names(OpenFile,\"<dom>\")\nvar dom={File :function(){},FileReader :function(){}}\ndom.File.__class__=_b_.type\ndom.File.__str__=function(){return \"<class 'File'>\"}\ndom.FileReader.__class__=_b_.type\ndom.FileReader.__str__=function(){return \"<class 'FileReader'>\"}\nvar Options={__class__:_b_.type,__delitem__:function(self,key){key=$B.PyNumber_Index(key)\nif(key < 0){key+=self.parent.options.length}\nif(! self.parent.options[key]){throw _b_.KeyError.$factory(key)}\nself.parent.options.remove(key)},__getitem__:function(self,key){key=$B.PyNumber_Index(key)\nif(key < 0){key+=self.parent.options.length}\nif(! self.parent.options[key]){throw _b_.KeyError.$factory(key)}\nreturn DOMNode.$factory(self.parent.options[key])},__len__:function(self){return self.parent.options.length},__mro__:[object],__setattr__:function(self,attr,value){self.parent.options[attr]=value},__setitem__:function(self,attr,value){self.parent.options[attr]=$B.$JS2Py(value)},__str__:function(self){return \"<object Options wraps \"+self.parent.options+\">\"},append:function(self,element){self.parent.options.add(element)},insert:function(self,index,element){if(index===undefined){self.parent.options.add(element)}\nelse{self.parent.options.add(element,index)}},item:function(self,index){return self.parent.options.item(index)},namedItem:function(self,name){return self.parent.options.namedItem(name)},remove:function(self,element){self.parent.options.remove(element.index)},$infos:{__module__:\"<pydom>\",__name__:\"Options\"}}\nOptions.$factory=function(parent){return{\n__class__:Options,parent:parent}}\n$B.set_func_names(Options,\"<dom>\")\nvar DOMNode={__class__ :_b_.type,__mro__:[object],$infos:{__module__:\"browser\",__name__:\"DOMNode\"}}\nDOMNode.$factory=function(elt){return elt}\nDOMNode.__add__=function(self,other){\nvar res=TagSum.$factory()\nres.children=[self],pos=1\nif(_b_.isinstance(other,TagSum)){res.children=res.children.concat(other.children)}else if(_b_.isinstance(other,[_b_.str,_b_.int,_b_.float,_b_.list,_b_.dict,_b_.set,_b_.tuple])){res.children[pos++]=DOMNode.$factory(\ndocument.createTextNode(_b_.str.$factory(other)))}else if(_b_.isinstance(other,DOMNode)){res.children[pos++]=other}else{\ntry{res.children=res.children.concat(_b_.list.$factory(other))}\ncatch(err){throw _b_.TypeError.$factory(\"can't add '\"+\n$B.class_name(other)+\"' object to DOMNode instance\")}}\nreturn res}\nDOMNode.__bool__=function(self){return true}\nDOMNode.__contains__=function(self,key){\nif(self.nodeType==9 && typeof key==\"string\"){return document.getElementById(key)!==null}\nif(self.length !==undefined && typeof self.item==\"function\"){for(var i=0,len=self.length;i < len;i++){if(self.item(i)===key){return true}}}\nreturn false}\nDOMNode.__del__=function(self){\nif(!self.parentNode){throw _b_.ValueError.$factory(\"can't delete \"+_b_.str.$factory(self))}\nself.parentNode.removeChild(self)}\nDOMNode.__delattr__=function(self,attr){if(self[attr]===undefined){throw _b_.AttributeError.$factory(\n`cannot delete DOMNode attribute '${attr}'`)}\ndelete self[attr]\nreturn _b_.None}\nDOMNode.__delitem__=function(self,key){if(self.nodeType==9){\nvar res=self.getElementById(key)\nif(res){res.parentNode.removeChild(res)}\nelse{throw _b_.KeyError.$factory(key)}}else{\nself.parentNode.removeChild(self)}}\nDOMNode.__dir__=function(self){var res=[]\nfor(var attr in self){if(attr.charAt(0)!=\"$\"){res.push(attr)}}\nres.sort()\nreturn res}\nDOMNode.__eq__=function(self,other){return self==other}\nDOMNode.__getattribute__=function(self,attr){switch(attr){case \"attrs\":\nreturn Attributes.$factory(self)\ncase \"children\":\ncase \"child_nodes\":\ncase \"class_name\":\ncase \"html\":\ncase \"parent\":\ncase \"text\":\nreturn DOMNode[attr](self)\ncase \"height\":\ncase \"left\":\ncase \"top\":\ncase \"width\":\nif(self.tagName==\"CANVAS\" && self[attr]){return self[attr]}\nif(self instanceof SVGElement){return self[attr].baseVal.value}\nvar computed=window.getComputedStyle(self).\ngetPropertyValue(attr)\nif(computed !==undefined){var prop=Math.floor(parseFloat(computed)+0.5)\nreturn isNaN(prop)? computed :prop}else if(self.style[attr]){return parseInt(self.style[attr])}else{throw _b_.AttributeError.$factory(\"style.\"+attr+\n\" is not set for \"+_b_.str.$factory(self))}\ncase \"x\":\ncase \"y\":\nif(!(self instanceof SVGElement)){var pos=$getPosition(self)\nreturn attr==\"x\" ? pos.left :pos.top}\ncase \"clear\":\ncase \"closest\":\nreturn function(){return DOMNode[attr].call(null,self,...arguments)}\ncase \"headers\":\nif(self.nodeType==9){\nvar req=new XMLHttpRequest();\nreq.open(\"GET\",document.location,false)\nreq.send(null);\nvar headers=req.getAllResponseHeaders()\nheaders=headers.split(\"\\r\\n\")\nvar res=$B.empty_dict()\nfor(var i=0;i < headers.length;i++){var header=headers[i]\nif(header.strip().length==0){continue}\nvar pos=header.search(\":\")\nres.__setitem__(header.substr(0,pos),header.substr(pos+1).lstrip())}\nreturn res}\nbreak\ncase \"location\":\nattr=\"location\"\nbreak}\nif(attr==\"select\" && self.nodeType==1 &&\n[\"INPUT\",\"TEXTAREA\"].indexOf(self.tagName.toUpperCase())>-1){return function(selector){if(selector===undefined){self.select();return _b_.None}\nreturn DOMNode.select(self,selector)}}\nif(attr==\"query\" && self.nodeType==9){\nvar res={__class__:Query,_keys :[],_values :{}}\nvar qs=location.search.substr(1).split('&')\nif(location.search !=\"\"){for(var i=0;i < qs.length;i++){var pos=qs[i].search(\"=\"),elts=[qs[i].substr(0,pos),qs[i].substr(pos+1)],key=decodeURIComponent(elts[0]),value=decodeURIComponent(elts[1])\nif(res._keys.indexOf(key)>-1){res._values[key].push(value)}else{res._keys.push(key)\nres._values[key]=[value]}}}\nreturn res}\nvar property=self[attr]\nif(property !==undefined && self.__class__ &&\nself.__class__.__module__ !=\"browser.html\" &&\nself.__class__.__module__ !=\"browser.svg\"){\nvar bases=self.__class__.__bases__\nvar show_message=true\nfor(var base of bases){if(base.__module__==\"browser.html\"){show_message=false\nbreak}}\nif(show_message){var from_class=$B.$getattr(self.__class__,attr,_b_.None)\nif(from_class !==_b_.None){var frame=$B.last($B.frames_stack),line_info=frame[1].$line_info,line=line_info.split(',')[0]\nconsole.info(\"Warning: line \"+line+\", \"+self.tagName+\n\" element has instance attribute '\"+attr+\"' set.\"+\n\" Attribute of class \"+$B.class_name(self)+\n\" is ignored.\")}}}\nif(property===undefined){\nif(self.tagName){var ce=customElements.get(self.tagName.toLowerCase())\nif(ce !==undefined && ce.$cls !==undefined){\nvar save_class=self.__class__\nself.__class__=ce.$cls\ntry{var res=_b_.object.__getattribute__(self,attr)\nself.__class__=save_class\nreturn res}catch(err){self.__class__=save_class\nif(! $B.is_exc(err,[_b_.AttributeError])){throw err}}}}\nreturn object.__getattribute__(self,attr)}\nvar res=property\nif(res !==undefined){if(res===null){return _b_.None}\nif(typeof res===\"function\"){\nvar func=(function(f,elt){return function(){var args=[],pos=0\nfor(var i=0;i < arguments.length;i++){var arg=arguments[i]\nif(typeof arg==\"function\"){\nif(arg.$cache){var f1=arg.$cache}else{var f1=function(dest_fn){return function(){try{return dest_fn.apply(null,arguments)}catch(err){$B.handle_error(err)}}}(arg)\narg.$cache=f1}\nargs[pos++]=f1}else if(_b_.isinstance(arg,DOMNode)){args[pos++]=arg}else if(arg===_b_.None){args[pos++]=null}else if(arg.__class__==_b_.dict){args[pos++]=_b_.dict.$to_obj(arg)}else{args[pos++]=arg}}\nvar result=f.apply(elt,args)\nreturn $B.$JS2Py(result)}})(res,self)\nfunc.$infos={__name__ :attr,__qualname__:attr}\nfunc.$is_func=true\nreturn func}\nif(attr=='options'){return Options.$factory(self)}\nif(attr=='style'){return $B.JSObj.$factory(self[attr])}\nif(Array.isArray(res)){return res}\nreturn $B.$JS2Py(res)}\nreturn object.__getattribute__(self,attr)}\nDOMNode.__getitem__=function(self,key){if(self.nodeType==9){\nif(typeof key.valueOf()==\"string\"){var res=self.getElementById(key)\nif(res){return DOMNode.$factory(res)}\nthrow _b_.KeyError.$factory(key)}else{try{var elts=self.getElementsByTagName(key.$infos.__name__),res=[]\nfor(var i=0;i < elts.length;i++){res.push(DOMNode.$factory(elts[i]))}\nreturn res}catch(err){throw _b_.KeyError.$factory(_b_.str.$factory(key))}}}else{if((typeof key==\"number\" ||typeof key==\"boolean\")&&\ntypeof self.item==\"function\"){var key_to_int=_b_.int.$factory(key)\nif(key_to_int < 0){key_to_int+=self.length}\nvar res=DOMNode.$factory(self.item(key_to_int))\nif(res===undefined){throw _b_.KeyError.$factory(key)}\nreturn res}else if(typeof key==\"string\" &&\nself.attributes &&\ntypeof self.attributes.getNamedItem==\"function\"){var attr=self.attributes.getNamedItem(key)\nif(!!attr){return attr.value}\nthrow _b_.KeyError.$factory(key)}}}\nDOMNode.__hash__=function(self){return self.__hashvalue__===undefined ?\n(self.__hashvalue__=$B.$py_next_hash--):\nself.__hashvalue__}\nDOMNode.__iter__=function(self){\nif(self.length !==undefined && typeof self.item==\"function\"){var items=[]\nfor(var i=0,len=self.length;i < len;i++){items.push(DOMNode.$factory(self.item(i)))}}else if(self.childNodes !==undefined){var items=[]\nfor(var i=0,len=self.childNodes.length;i < len;i++){items.push(DOMNode.$factory(self.childNodes[i]))}}\nreturn $B.$iter(items)}\nDOMNode.__le__=function(self,other){\nif(self.nodeType==9){self=self.body}\nif(_b_.isinstance(other,TagSum)){for(var i=0;i < other.children.length;i++){self.appendChild(other.children[i])}}else if(typeof other==\"string\" ||typeof other==\"number\"){var txt=document.createTextNode(other.toString())\nself.appendChild(txt)}else if(other instanceof Node){self.appendChild(other)}else{try{\nvar items=_b_.list.$factory(other)\nitems.forEach(function(item){DOMNode.__le__(self,item)})}catch(err){throw _b_.TypeError.$factory(\"can't add '\"+\n$B.class_name(other)+\"' object to DOMNode instance\")}}\nreturn self }\nDOMNode.__len__=function(self){return self.length}\nDOMNode.__mul__=function(self,other){if(_b_.isinstance(other,_b_.int)&& other.valueOf()> 0){var res=TagSum.$factory()\nvar pos=res.children.length\nfor(var i=0;i < other.valueOf();i++){res.children[pos++]=DOMNode.clone(self)()}\nreturn res}\nthrow _b_.ValueError.$factory(\"can't multiply \"+self.__class__+\n\"by \"+other)}\nDOMNode.__ne__=function(self,other){return ! DOMNode.__eq__(self,other)}\nDOMNode.__next__=function(self){self.$counter++\nif(self.$counter < self.childNodes.length){return DOMNode.$factory(self.childNodes[self.$counter])}\nthrow _b_.StopIteration.$factory(\"StopIteration\")}\nDOMNode.__radd__=function(self,other){\nvar res=TagSum.$factory()\nvar txt=DOMNode.$factory(document.createTextNode(other))\nres.children=[txt,self]\nreturn res}\nDOMNode.__str__=DOMNode.__repr__=function(self){var attrs=self.attributes,attrs_str=\"\",items=[]\nif(attrs !==undefined){var items=[]\nfor(var i=0;i < attrs.length;i++){items.push(attrs[i].name+'=\"'+\nself.getAttributeNS(null,attrs[i].name)+'\"')}}\nvar proto=Object.getPrototypeOf(self)\nif(proto){var name=proto.constructor.name\nif(name===undefined){\nvar proto_str=proto.constructor.toString()\nname=proto_str.substring(8,proto_str.length-1)}\nitems.splice(0,0,name)\nreturn \"<\"+items.join(\" \")+\">\"}\nvar res=\"<DOMNode object type '\"\nreturn res+$NodeTypes[self.nodeType]+\"' name '\"+\nself.nodeName+\"'\"+attrs_str+\">\"}\nDOMNode.__setattr__=function(self,attr,value){\nif(attr.substr(0,2)==\"on\" && attr.length > 2){\nif(!$B.$bool(value)){\nDOMNode.unbind(self,attr.substr(2))}else{\nDOMNode.bind(self,attr.substr(2),value)}}else{switch(attr){case \"left\":\ncase \"top\":\ncase \"width\":\ncase \"height\":\nif(_b_.isinstance(value,_b_.int)&& self.nodeType==1){self.style[attr]=value+\"px\"\nreturn _b_.None}else{throw _b_.ValueError.$factory(attr+\" value should be\"+\n\" an integer, not \"+$B.class_name(value))}\nbreak}\nif(DOMNode[\"set_\"+attr]!==undefined){return DOMNode[\"set_\"+attr](self,value)}\nfunction warn(msg){console.log(msg)\nvar frame=$B.last($B.frames_stack)\nif($B.debug > 0){var info=frame[1].$line_info.split(\",\")\nconsole.log(\"module\",info[1],\"line\",info[0])\nif($B.$py_src.hasOwnProperty(info[1])){var src=$B.$py_src[info[1]]\nconsole.log(src.split(\"\\n\")[parseInt(info[0])-1])}}else{console.log(\"module\",frame[2])}}\nvar proto=Object.getPrototypeOf(self),nb=0\nwhile(!!proto && proto !==Object.prototype && nb++< 10){var descriptors=Object.getOwnPropertyDescriptors(proto)\nif(!!descriptors &&\ntypeof descriptors.hasOwnProperty==\"function\"){if(descriptors.hasOwnProperty(attr)){if(!descriptors[attr].writable &&\ndescriptors[attr].set===undefined){warn(\"Warning: property '\"+attr+\n\"' is not writable. Use element.attrs['\"+\nattr+\"'] instead.\")}\nbreak}}else{break}\nproto=Object.getPrototypeOf(proto)}\nif(self.style && self.style[attr]!==undefined){warn(\"Warning: '\"+attr+\"' is a property of element.style\")}\nself[attr]=value\nreturn _b_.None}}\nDOMNode.__setitem__=function(self,key,value){if(typeof key==\"number\"){self.childNodes[key]=value}else if(typeof key==\"string\"){if(self.attributes){if(self instanceof SVGElement){self.setAttributeNS(null,key,value)}else if(typeof self.setAttribute==\"function\"){self.setAttribute(key,value)}}}}\nDOMNode.abs_left={__get__:function(self){return $getPosition(self).left},__set__:function(){throw _b_.AttributeError.$factory(\"'DOMNode' objectattribute \"+\n\"'abs_left' is read-only\")}}\nDOMNode.abs_top={__get__:function(self){return $getPosition(self).top},__set__:function(){throw _b_.AttributeError.$factory(\"'DOMNode' objectattribute \"+\n\"'abs_top' is read-only\")}}\nDOMNode.attach=DOMNode.__le__ \nDOMNode.bind=function(self,event){\nvar $=$B.args(\"bind\",4,{self:null,event:null,func:null,options:null},[\"self\",\"event\",\"func\",\"options\"],arguments,{func:_b_.None,options:_b_.None},null,null),self=$.self,event=$.event,func=$.func,options=$.options\nif(func===_b_.None){\nreturn function(f){return DOMNode.bind(self,event,f)}}\nvar callback=(function(f){return function(ev){try{return f($DOMEvent(ev))}catch(err){if(err.__class__ !==undefined){$B.handle_error(err)}else{try{$B.$getattr($B.stderr,\"write\")(err)}\ncatch(err1){console.log(err)}}}}}\n)(func)\ncallback.$infos=func.$infos\ncallback.$attrs=func.$attrs ||{}\ncallback.$func=func\nif(typeof options==\"boolean\"){self.addEventListener(event,callback,options)}else if(options.__class__===_b_.dict){self.addEventListener(event,callback,_b_.dict.$to_obj(options))}else if(options===_b_.None){self.addEventListener(event,callback,false)}\nself.$events=self.$events ||{}\nself.$events[event]=self.$events[event]||[]\nself.$events[event].push([func,callback])\nreturn self}\nDOMNode.children=function(self){var res=[]\nif(self.nodeType==9){self=self.body}\nfor(var child of self.children){res.push(DOMNode.$factory(child))}\nreturn res}\nDOMNode.child_nodes=function(self){var res=[]\nif(self.nodeType==9){self=self.body}\nfor(child of self.childNodes){res.push(DOMNode.$factory(child))}\nreturn res}\nDOMNode.clear=function(self){\nvar $=$B.args(\"clear\",1,{self:null},[\"self\"],arguments,{},null,null)\nif(self.nodeType==9){self=self.body}\nwhile(self.firstChild){self.removeChild(self.firstChild)}}\nDOMNode.Class=function(self){if(self.className !==undefined){return self.className}\nreturn _b_.None}\nDOMNode.class_name=function(self){return DOMNode.Class(self)}\nDOMNode.clone=function(self){var res=DOMNode.$factory(self.cloneNode(true))\nvar events=self.$events ||{}\nfor(var event in events){var evt_list=events[event]\nevt_list.forEach(function(evt){var func=evt[0]\nDOMNode.bind(res,event,func)})}\nreturn res}\nDOMNode.closest=function(self,selector){\nvar $=$B.args(\"closest\",2,{self:null,selector:null},[\"self\",\"selector\"],arguments,{},null,null)\nvar res=self.closest(selector)\nif(res===null){throw _b_.KeyError.$factory(\"no parent with selector \"+selector)}\nreturn DOMNode.$factory(res)}\nDOMNode.bindings=function(self){\nvar res=$B.empty_dict()\nfor(var key in self.$events){_b_.dict.$setitem(res,key,self.$events[key].map(x=> x[1]))}\nreturn res}\nDOMNode.events=function(self,event){self.$events=self.$events ||{}\nvar evt_list=self.$events[event]=self.$events[event]||[],callbacks=[]\nevt_list.forEach(function(evt){callbacks.push(evt[1])})\nreturn callbacks}\nfunction make_list(node_list){var res=[]\nfor(var i=0;i < node_list.length;i++){res.push(DOMNode.$factory(node_list[i]))}\nreturn res}\nDOMNode.get=function(self){\nvar args=[]\nfor(var i=1;i < arguments.length;i++){args.push(arguments[i])}\nvar $ns=$B.args(\"get\",0,{},[],args,{},null,\"kw\"),$dict={},items=_b_.list.$factory(_b_.dict.items($ns[\"kw\"]))\nitems.forEach(function(item){$dict[item[0]]=item[1]})\nif($dict[\"name\"]!==undefined){if(self.getElementsByName===undefined){throw _b_.TypeError.$factory(\"DOMNode object doesn't support \"+\n\"selection by name\")}\nreturn make_list(self.getElementsByName($dict['name']))}\nif($dict[\"tag\"]!==undefined){if(self.getElementsByTagName===undefined){throw _b_.TypeError.$factory(\"DOMNode object doesn't support \"+\n\"selection by tag name\")}\nreturn make_list(self.getElementsByTagName($dict[\"tag\"]))}\nif($dict[\"classname\"]!==undefined){if(self.getElementsByClassName===undefined){throw _b_.TypeError.$factory(\"DOMNode object doesn't support \"+\n\"selection by class name\")}\nreturn make_list(self.getElementsByClassName($dict['classname']))}\nif($dict[\"id\"]!==undefined){if(self.getElementById===undefined){throw _b_.TypeError.$factory(\"DOMNode object doesn't support \"+\n\"selection by id\")}\nvar id_res=document.getElementById($dict['id'])\nif(! id_res){return[]}\nreturn[DOMNode.$factory(id_res)]}\nif($dict[\"selector\"]!==undefined){if(self.querySelectorAll===undefined){throw _b_.TypeError.$factory(\"DOMNode object doesn't support \"+\n\"selection by selector\")}\nreturn make_list(self.querySelectorAll($dict['selector']))}\nreturn res}\nDOMNode.getContext=function(self){\nif(!(\"getContext\" in self)){throw _b_.AttributeError.$factory(\"object has no attribute 'getContext'\")}\nreturn function(ctx){return $B.JSObj.$factory(self.getContext(ctx))}}\nDOMNode.getSelectionRange=function(self){\nif(self[\"getSelectionRange\"]!==undefined){return self.getSelectionRange.apply(null,arguments)}}\nDOMNode.html=function(self){var res=self.innerHTML\nif(res===undefined){if(self.nodeType==9 && self.body){res=self.body.innerHTML}else{res=_b_.None}}\nreturn res}\nDOMNode.index=function(self,selector){var items\nif(selector===undefined){items=self.parentElement.childNodes}else{items=self.parentElement.querySelectorAll(selector)}\nvar rank=-1\nfor(var i=0;i < items.length;i++){if(items[i]===self){rank=i;break}}\nreturn rank}\nDOMNode.inside=function(self,other){\nvar elt=self\nwhile(true){if(other===elt){return true}\nelt=elt.parentNode\nif(! elt){return false}}}\nDOMNode.options=function(self){\nreturn new $OptionsClass(self)}\nDOMNode.parent=function(self){if(self.parentElement){return DOMNode.$factory(self.parentElement)}\nreturn _b_.None}\nDOMNode.reset=function(self){\nreturn function(){self.reset()}}\nDOMNode.scrolled_left={__get__:function(self){return $getPosition(self).left-\ndocument.scrollingElement.scrollLeft},__set__:function(){throw _b_.AttributeError.$factory(\"'DOMNode' objectattribute \"+\n\"'scrolled_left' is read-only\")}}\nDOMNode.scrolled_top={__get__:function(self){return $getPosition(self).top-\ndocument.scrollingElement.scrollTop},__set__:function(){throw _b_.AttributeError.$factory(\"'DOMNode' objectattribute \"+\n\"'scrolled_top' is read-only\")}}\nDOMNode.select=function(self,selector){\nif(self.querySelectorAll===undefined){throw _b_.TypeError.$factory(\"DOMNode object doesn't support \"+\n\"selection by selector\")}\nreturn make_list(self.querySelectorAll(selector))}\nDOMNode.select_one=function(self,selector){\nif(self.querySelector===undefined){throw _b_.TypeError.$factory(\"DOMNode object doesn't support \"+\n\"selection by selector\")}\nvar res=self.querySelector(selector)\nif(res===null){return _b_.None}\nreturn DOMNode.$factory(res)}\nDOMNode.setSelectionRange=function(self){\nif(this[\"setSelectionRange\"]!==undefined){return(function(obj){return function(){return obj.setSelectionRange.apply(obj,arguments)}})(this)}else if(this[\"createTextRange\"]!==undefined){return(function(obj){return function(start_pos,end_pos){if(end_pos==undefined){end_pos=start_pos}\nvar range=obj.createTextRange()\nrange.collapse(true)\nrange.moveEnd(\"character\",start_pos)\nrange.moveStart(\"character\",end_pos)\nrange.select()}})(this)}}\nDOMNode.set_class_name=function(self,arg){self.setAttribute(\"class\",arg)}\nDOMNode.set_html=function(self,value){if(self.nodeType==9){self=self.body}\nself.innerHTML=_b_.str.$factory(value)}\nDOMNode.set_style=function(self,style){\nif(typeof style==='string'){self.style=style}else if(!_b_.isinstance(style,_b_.dict)){throw _b_.TypeError.$factory(\"style must be str or dict, not \"+\n$B.class_name(style))}\nvar items=_b_.list.$factory(_b_.dict.items(style))\nfor(var i=0;i < items.length;i++){var key=items[i][0],value=items[i][1]\nif(key.toLowerCase()==\"float\"){self.style.cssFloat=value\nself.style.styleFloat=value}else{switch(key){case \"top\":\ncase \"left\":\ncase \"width\":\ncase \"height\":\ncase \"borderWidth\":\nif(_b_.isinstance(value,_b_.int)){value=value+\"px\"}}\nself.style[key]=value}}}\nDOMNode.set_text=function(self,value){if(self.nodeType==9){self=self.body}\nself.innerText=_b_.str.$factory(value)\nself.textContent=_b_.str.$factory(value)}\nDOMNode.set_value=function(self,value){self.value=_b_.str.$factory(value)}\nDOMNode.submit=function(self){\nreturn function(){self.submit()}}\nDOMNode.text=function(self){if(self.nodeType==9){self=self.body}\nvar res=self.innerText ||self.textContent\nif(res===null){res=_b_.None}\nreturn res}\nDOMNode.toString=function(self){if(self===undefined){return 'DOMNode'}\nreturn self.nodeName}\nDOMNode.trigger=function(self,etype){\nif(self.fireEvent){self.fireEvent(\"on\"+etype)}else{var evObj=document.createEvent(\"Events\")\nevObj.initEvent(etype,true,false)\nself.dispatchEvent(evObj)}}\nDOMNode.unbind=function(self,event){\nself.$events=self.$events ||{}\nif(self.$events==={}){return _b_.None}\nif(event===undefined){for(var event in self.$events){DOMNode.unbind(self,event)}\nreturn _b_.None}\nif(self.$events[event]===undefined ||\nself.$events[event].length==0){return _b_.None}\nvar events=self.$events[event]\nif(arguments.length==2){\nfor(var i=0;i < events.length;i++){var callback=events[i][1]\nself.removeEventListener(event,callback,false)}\nself.$events[event]=[]\nreturn _b_.None}\nfor(var i=2;i < arguments.length;i++){var callback=arguments[i],flag=false,func=callback.$func\nif(func===undefined){\nvar found=false\nfor(var j=0;j < events.length;j++){if(events[j][0]===callback){var func=callback,found=true\nbreak}}\nif(!found){throw _b_.TypeError.$factory(\"function is not an event callback\")}}\nfor(var j=0;j < events.length;j++){if($B.$getattr(func,'__eq__')(events[j][0])){var callback=events[j][1]\nself.removeEventListener(event,callback,false)\nevents.splice(j,1)\nflag=true\nbreak}}\nif(!flag){throw _b_.KeyError.$factory('missing callback for event '+event)}}}\n$B.set_func_names(DOMNode,\"browser\")\nvar Query={__class__:_b_.type,__mro__:[_b_.object],$infos:{__name__:\"query\"}}\nQuery.__contains__=function(self,key){return self._keys.indexOf(key)>-1}\nQuery.__getitem__=function(self,key){\nvar result=self._values[key]\nif(result===undefined){throw _b_.KeyError.$factory(key)}else if(result.length==1){return result[0]}\nreturn result}\nvar Query_iterator=$B.make_iterator_class(\"query string iterator\")\nQuery.__iter__=function(self){return Query_iterator.$factory(self._keys)}\nQuery.__setitem__=function(self,key,value){self._values[key]=[value]\nreturn _b_.None}\nQuery.__str__=Query.__repr__=function(self){\nvar elts=[]\nfor(var key in self._values){for(const val of self._values[key]){elts.push(encodeURIComponent(key)+\"=\"+encodeURIComponent(val))}}\nif(elts.length==0){return \"\"}else{return \"?\"+elts.join(\"&\")}}\nQuery.getfirst=function(self,key,_default){\nvar result=self._values[key]\nif(result===undefined){if(_default===undefined){return _b_.None}\nreturn _default}\nreturn result[0]}\nQuery.getlist=function(self,key){\nvar result=self._values[key]\nif(result===undefined){return[]}\nreturn result}\nQuery.getvalue=function(self,key,_default){try{return Query.__getitem__(self,key)}\ncatch(err){if(_default===undefined){return _b_.None}\nreturn _default}}\nQuery.keys=function(self){return self._keys}\n$B.set_func_names(Query,\"<dom>\")\nvar TagSum={__class__ :_b_.type,__mro__:[object],$infos:{__module__:\"<pydom>\",__name__:\"TagSum\"}}\nTagSum.appendChild=function(self,child){self.children.push(child)}\nTagSum.__add__=function(self,other){if($B.get_class(other)===TagSum){self.children=self.children.concat(other.children)}else if(_b_.isinstance(other,[_b_.str,_b_.int,_b_.float,_b_.dict,_b_.set,_b_.list])){self.children=self.children.concat(\nDOMNode.$factory(document.createTextNode(other)))}else{self.children.push(other)}\nreturn self}\nTagSum.__radd__=function(self,other){var res=TagSum.$factory()\nres.children=self.children.concat(\nDOMNode.$factory(document.createTextNode(other)))\nreturn res}\nTagSum.__repr__=function(self){var res=\"<object TagSum> \"\nfor(var i=0;i < self.children.length;i++){res+=self.children[i]\nif(self.children[i].toString()==\"[object Text]\"){res+=\" [\"+self.children[i].textContent+\"]\\n\"}}\nreturn res}\nTagSum.__str__=TagSum.toString=TagSum.__repr__\nTagSum.clone=function(self){var res=TagSum.$factory()\nfor(var i=0;i < self.children.length;i++){res.children.push(self.children[i].cloneNode(true))}\nreturn res}\nTagSum.$factory=function(){return{\n__class__:TagSum,children:[],toString:function(){return \"(TagSum)\"}}}\n$B.set_func_names(TagSum,\"<dom>\")\n$B.TagSum=TagSum \nvar win=$B.JSObj.$factory(_window)\nwin.get_postMessage=function(msg,targetOrigin){if(_b_.isinstance(msg,dict)){var temp={__class__:\"dict\"},items=_b_.list.$factory(_b_.dict.items(msg))\nitems.forEach(function(item){temp[item[0]]=item[1]})\nmsg=temp}\nreturn _window.postMessage(msg,targetOrigin)}\n$B.DOMNode=DOMNode\n$B.win=win})(__BRYTHON__)\n;\n\n$B.pattern_match=function(subject,pattern){var _b_=$B.builtins,frame=$B.last($B.frames_stack),locals=frame[1]\nfunction bind(pattern,subject){if(pattern.alias){locals[pattern.alias]=subject}}\nif(pattern.sequence){\nif(_b_.isinstance(subject,[_b_.str,_b_.bytes,_b_.bytearray])){\nreturn false}\nvar Sequence\nif($B.imported['collections.abc']){Sequence=$B.imported['collections.abc'].Sequence}\nvar deque\nif($B.imported['collections']){deque=$B.imported['collections'].deque}\nvar supported=false\nvar klass=subject.__class__ ||$B.get_class(subject)\nfor(var base of[klass].concat(klass.__bases__ ||[])){if(base.$match_sequence_pattern){\nsupported=true\nbreak}else if(base===Sequence ||base==deque){supported=true\nbreak}}\nif((! supported)&& Sequence){\nsupported=_b_.issubclass(klass,Sequence)}\nif(! supported){return false}\nif(pattern.sequence.length==1 &&\npattern.sequence[0].capture_starred=='_'){return true}\nvar subject_length=_b_.len(subject)\nvar nb_fixed_length=0\nfor(var item of pattern.sequence){if(! item.capture_starred){nb_fixed_length++}}\nif(subject_length < nb_fixed_length){\nreturn false}else if(subject_length==0 && pattern.sequence.length==0){\nreturn true}\nvar it=_b_.iter(subject),nxt=$B.$getattr(it,'__next__'),store_starred=[],nb_matched_in_subject=0\nfor(var i=0,len=pattern.sequence.length;i < len;i++){if(pattern.sequence[i].capture_starred){\nif(pattern.sequence[i].capture_starred=='_' &&\ni==len-1){bind(pattern,subject)\nreturn true}\nvar starred_match_length=subject_length-\nnb_matched_in_subject-len+i+1\nfor(var j=0;j < starred_match_length;j++){store_starred.push(nxt())}\nlocals[pattern.sequence[i].capture_starred]=store_starred\nnb_matched_in_subject+=starred_match_length}else{var subject_item=nxt()\nvar m=$B.pattern_match(subject_item,pattern.sequence[i])\nif(! m){return false}\nnb_matched_in_subject++}}\nif(nb_matched_in_subject !=subject_length){return false}\nbind(pattern,subject)\nreturn true}\nif(pattern.group){if(pattern.group.length==1){\nif($B.pattern_match(subject,pattern.group[0])){bind(pattern,subject)\nreturn true}}else{\npattern.sequence=pattern.group\nreturn $B.pattern_match(subject,pattern)}}\nif(pattern.or){\nfor(var item of pattern.or){if($B.pattern_match(subject,item)){bind(pattern,subject)\nreturn true}}\nreturn false}\nif(pattern.mapping){\nvar supported=false\nvar Mapping\nif($B.imported['collections.abc']){Mapping=$B.imported['collections.abc'].Mapping}\nvar klass=subject.__class__ ||$B.get_class(subject)\nfor(var base of[klass].concat(klass.__bases__ ||[])){\nif(base.$match_mapping_pattern ||base===Mapping){supported=true\nbreak}}\nif((! supported)&& Mapping){supported=_b_.issubclass(klass,Mapping)}\nif(! supported){return false}\nvar matched=[],keys=[]\nfor(var item of pattern.mapping){var key_pattern=item[0],value_pattern=item[1]\nif(key_pattern.hasOwnProperty('literal')){var key=key_pattern.literal}else if(key_pattern.hasOwnProperty('value')){var key=key_pattern.value}\nif(_b_.list.__contains__(keys,key)){throw _b_.ValueError.$factory('mapping pattern checks '+\n'duplicate key ('+\n_b_.str.$factory(key)+')')}\nkeys.push(key)\nvar missing=$B.make_class('missing',function(){return{\n__class__:missing}}\n)\ntry{var v=$B.$call($B.$getattr(subject,\"get\"))(key,missing)\nif(v===missing){\nreturn false}\nif(! $B.pattern_match(v,value_pattern)){return false}\nmatched.push(key)}catch(err){if($B.is_exc(err,[_b_.KeyError])){return false}\nthrow err}}\nif(pattern.rest){var rest=$B.empty_dict(),it=_b_.iter(subject)\nwhile(true){try{var next_key=_b_.next(it)}catch(err){if($B.is_exc(err,[_b_.StopIteration])){locals[pattern.rest]=rest\nreturn true}\nthrow err}\nif(! _b_.list.__contains__(matched,next_key)){_b_.dict.__setitem__(rest,next_key,$B.$getitem(subject,next_key))}}}\nreturn true}\nif(pattern.class){var klass=pattern.class\nif(! _b_.isinstance(klass,_b_.type)){throw _b_.TypeError.$factory('called match pattern must be a type')}\nif(! _b_.isinstance(subject,klass)){return false}\nif(pattern.args.length > 0){if([_b_.bool,_b_.bytearray,_b_.bytes,_b_.dict,_b_.float,_b_.frozenset,_b_.int,_b_.list,_b_.set,_b_.str,_b_.tuple].indexOf(klass)>-1){\nif(pattern.args.length > 1){throw _b_.TypeError.$factory('for builtin type '+\n$B.class_name(subject)+', a single positional '+\n'subpattern is accepted')}\nreturn $B.pattern_match(subject,pattern.args[0])}else{\nvar match_args=$B.$getattr(klass,'__match_args__',$B.fast_tuple([]))\nif(! _b_.isinstance(match_args,_b_.tuple)){throw _b_.TypeError.$factory(\n'__match_args__() did not return a tuple')}\nif(pattern.args.length > match_args.length){throw _b_.TypeError.$factory(\n'__match_args__() returns '+match_args.length+\n' names but '+pattern.args.length+' positional '+\n'arguments were passed')}\nfor(var i=0,len=pattern.args.length;i < len;i++){\nvar pattern_arg=pattern.args[i],klass_arg=match_args[i]\nif(typeof klass_arg !==\"string\"){throw _b_.TypeError.$factory('item in __match_args__ '+\n'is not a string: '+klass_arg)}\nif(pattern.keywords.hasOwnProperty(klass_arg)){throw _b_.TypeError.$factory('__match_arg__ item '+\nklass_arg+' was passed as keyword pattern')}\npattern.keywords[klass_arg]=pattern_arg}}}\nfor(var key in pattern.keywords){var v=$B.$getattr(subject,key,null)\nif(v===null){return false}else if(! $B.pattern_match(v,pattern.keywords[key])){return false}}\nbind(pattern,subject)\nreturn true}\nif(pattern.capture){if(pattern.capture !='_'){\nlocals[pattern.capture]=subject}\nbind(pattern,subject)\nreturn true}else if(pattern.capture_starred){\nlocals[pattern.capture_starred]=$B.$list(subject)\nreturn true}else if(pattern.hasOwnProperty('literal')){var literal=pattern.literal\nif(literal===_b_.None ||literal===_b_.True ||\nliteral===_b_.False){\nreturn $B.$is(subject,literal)}\nif($B.rich_comp('__eq__',subject,literal)){bind(pattern,subject)\nreturn true}\nreturn false}else if(pattern.hasOwnProperty('value')){if($B.rich_comp('__eq__',subject,pattern.value)){bind(pattern,subject)\nreturn true}}else if(subject==pattern){return true}\nreturn false}\n;\n ;(function($B){var _b_=$B.builtins\nvar update=$B.update_obj=function(mod,data){for(attr in data){mod[attr]=data[attr]}}\nvar _window=self;\nvar modules={}\nvar browser={$package:true,$is_package:true,__initialized__:true,__package__:'browser',__file__:$B.brython_path.replace(/\\/*$/g,'')+\n'/Lib/browser/__init__.py',bind:function(){\nvar $=$B.args(\"bind\",3,{elt:null,evt:null,options:null},[\"elt\",\"evt\",\"options\"],arguments,{options:_b_.None},null,null)\nvar options=$.options\nif(typeof options==\"boolean\"){}\nelse if(options.__class__===_b_.dict){options=options.$string_dict}else{options==false}\nreturn function(callback){if($B.get_class($.elt)===$B.JSObj){\nfunction f(ev){try{return callback($B.JSObj.$factory(ev))}catch(err){$B.handle_error(err)}}\n$.elt.addEventListener($.evt,f,options)\nreturn callback}else if(_b_.isinstance($.elt,$B.DOMNode)){\n$B.DOMNode.bind($.elt,$.evt,callback,options)\nreturn callback}else if(_b_.isinstance($.elt,_b_.str)){\nvar items=document.querySelectorAll($.elt)\nfor(var i=0;i < items.length;i++){$B.DOMNode.bind($B.DOMNode.$factory(items[i]),$.evt,callback,options)}\nreturn callback}\ntry{var it=$B.$iter($.elt)\nwhile(true){try{var elt=_b_.next(it)\n$B.DOMNode.bind(elt,$.evt,callback)}catch(err){if(_b_.isinstance(err,_b_.StopIteration)){break}\nthrow err}}}catch(err){if(_b_.isinstance(err,_b_.AttributeError)){$B.DOMNode.bind($.elt,$.evt,callback)}\nthrow err}\nreturn callback}},console:self.console && $B.JSObj.$factory(self.console),self:$B.win,win:$B.win,\"window\":$B.win,}\nbrowser.__path__=browser.__file__\nif($B.isNode){delete browser.window\ndelete browser.win}else if($B.isWebWorker){browser.is_webworker=true\ndelete browser.window\ndelete browser.win\nbrowser.self.send=self.postMessage}else{\nbrowser.is_webworker=false\nupdate(browser,{\"alert\":function(message){window.alert($B.builtins.str.$factory(message ||\"\"))},confirm:$B.JSObj.$factory(window.confirm),\"document\":$B.DOMNode.$factory(document),doc:$B.DOMNode.$factory(document),\nDOMEvent:$B.DOMEvent,DOMNode:$B.DOMNode,load:function(script_url){\nvar file_obj=$B.builtins.open(script_url)\nvar content=$B.$getattr(file_obj,'read')()\neval(content)},mouseCoords:function(ev){return $B.JSObj.$factory($mouseCoords(ev))},prompt:function(message,default_value){return $B.JSObj.$factory(window.prompt(message,default_value||''))},reload:function(){\nvar scripts=document.getElementsByTagName('script'),js_scripts=[]\nscripts.forEach(function(script){if(script.type===undefined ||\nscript.type=='text/javascript'){js_scripts.push(script)\nif(script.src){console.log(script.src)}}})\nconsole.log(js_scripts)\nfor(var mod in $B.imported){if($B.imported[mod].$last_modified){console.log('check',mod,$B.imported[mod].__file__,$B.imported[mod].$last_modified)}else{console.log('no date for mod',mod)}}},run_script:function(){var $=$B.args(\"run_script\",2,{src:null,name:null},[\"src\",\"name\"],arguments,{name:\"script_\"+$B.UUID()},null,null)\n$B.run_script($.src,$.name,$B.script_path,true)},URLParameter:function(name){name=name.replace(/[\\[]/,\"\\\\[\").replace(/[\\]]/,\"\\\\]\");\nvar regex=new RegExp(\"[\\\\?&]\"+name+\"=([^&#]*)\"),results=regex.exec(location.search);\nresults=results===null ? \"\" :\ndecodeURIComponent(results[1].replace(/\\+/g,\" \"));\nreturn $B.builtins.str.$factory(results);}})\nmodules['browser.html']=(function($B){var _b_=$B.builtins\nvar TagSum=$B.TagSum\nfunction makeTagDict(tagName){\nvar dict={__class__:_b_.type,$infos:{__name__:tagName,__module__:\"browser.html\",__qualname__:tagName}}\ndict.__init__=function(){var $ns=$B.args('pow',1,{self:null},['self'],arguments,{},'args','kw'),self=$ns['self'],args=$ns['args']\nif(args.length==1){var first=args[0]\nif(_b_.isinstance(first,[_b_.str,_b_.int,_b_.float])){\nself.innerHTML=_b_.str.$factory(first)}else if(first.__class__===TagSum){for(var i=0,len=first.children.length;i < len;i++){self.appendChild(first.children[i])}}else{if(_b_.isinstance(first,$B.DOMNode)){self.appendChild(first)}else{try{\nvar items=_b_.list.$factory(first)\nitems.forEach(function(item){$B.DOMNode.__le__(self,item)})}catch(err){if($B.debug > 1){console.log(err,err.__class__,err.args)\nconsole.log(\"first\",first)\nconsole.log(arguments)}\nthrow err}}}}\nvar items=_b_.list.$factory(_b_.dict.items($ns['kw']))\nfor(var i=0,len=items.length;i < len;i++){\nvar arg=items[i][0],value=items[i][1]\nif(arg.toLowerCase().substr(0,2)==\"on\"){\nvar js='$B.DOMNode.bind(self,\"'+\narg.toLowerCase().substr(2)\neval(js+'\",function(){'+value+'})')}else if(arg.toLowerCase()==\"style\"){$B.DOMNode.set_style(self,value)}else{if(value !==false){\ntry{\narg=$B.imported[\"browser.html\"].\nattribute_mapper(arg)\nself.setAttribute(arg,value)}catch(err){throw _b_.ValueError.$factory(\n\"can't set attribute \"+arg)}}}}}\ndict.__mro__=[$B.DOMNode,$B.builtins.object]\ndict.__new__=function(cls){\nvar res=document.createElement(tagName)\nif(cls !==html[tagName]){\nres.__class__=cls}\nreturn res}\n$B.set_func_names(dict,\"browser.html\")\nreturn dict}\nfunction makeFactory(klass){\nvar factory=function(){if(klass.$infos.__name__=='SVG'){var res=$B.DOMNode.$factory(\ndocument.createElementNS(\"http://www.w3.org/2000/svg\",\"svg\"),true)}else{var res=document.createElement(klass.$infos.__name__)}\nvar init=$B.$getattr(klass,\"__init__\",null)\nif(init !==null){init(res,...arguments)}\nreturn res}\nreturn factory}\nvar tags=['A','ABBR','ACRONYM','ADDRESS','APPLET','AREA','B','BASE','BASEFONT','BDO','BIG','BLOCKQUOTE','BODY','BR','BUTTON','CAPTION','CENTER','CITE','CODE','COL','COLGROUP','DD','DEL','DFN','DIR','DIV','DL','DT','EM','FIELDSET','FONT','FORM','FRAME','FRAMESET','H1','H2','H3','H4','H5','H6','HEAD','HR','HTML','I','IFRAME','IMG','INPUT','INS','ISINDEX','KBD','LABEL','LEGEND','LI','LINK','MAP','MENU','META','NOFRAMES','NOSCRIPT','OBJECT','OL','OPTGROUP','OPTION','P','PARAM','PRE','Q','S','SAMP','SCRIPT','SELECT','SMALL','SPAN','STRIKE','STRONG','STYLE','SUB','SUP','SVG','TABLE','TBODY','TD','TEXTAREA','TFOOT','TH','THEAD','TITLE','TR','TT','U','UL','VAR',\n'ARTICLE','ASIDE','AUDIO','BDI','CANVAS','COMMAND','DATA','DATALIST','EMBED','FIGCAPTION','FIGURE','FOOTER','HEADER','KEYGEN','MAIN','MARK','MATH','METER','NAV','OUTPUT','PROGRESS','RB','RP','RT','RTC','RUBY','SECTION','SOURCE','TEMPLATE','TIME','TRACK','VIDEO','WBR',\n'DETAILS','DIALOG','MENUITEM','PICTURE','SUMMARY']\nvar html={}\nhtml.tags=$B.jsobj_as_pydict.$factory(html,function(attr){return tags.indexOf(attr)==-1}\n)\nfunction maketag(tagName){\nif(!(typeof tagName=='string')){throw _b_.TypeError.$factory(\"html.maketag expects a string as argument\")}\nif(html[tagName]!==undefined){throw _b_.ValueError.$factory(\"cannot reset class for \"\n+tagName)}\nvar klass=makeTagDict(tagName)\nklass.$factory=makeFactory(klass)\nhtml[tagName]=klass\nreturn klass}\nfor(var tagName of tags){maketag(tagName)}\nhtml.maketag=maketag\nhtml.attribute_mapper=function(attr){return attr.replace(/_/g,'-')}\nreturn html})(__BRYTHON__)}\nmodules['browser']=browser\n$B.UndefinedClass=$B.make_class(\"Undefined\",function(){return $B.Undefined}\n)\n$B.UndefinedClass.__mro__=[_b_.object]\n$B.UndefinedClass.__bool__=function(self){return false}\n$B.UndefinedClass.__repr__=$B.UndefinedClass.__str__=function(self){return \"<Javascript undefined>\"}\n$B.Undefined={__class__:$B.UndefinedClass}\n$B.set_func_names($B.UndefinedClass,\"javascript\")\nvar super_class=$B.make_class(\"JavascriptSuper\",function(){\nvar b_super=_b_.super.$factory(),b_self=b_super.__self_class__,proto=Object.getPrototypeOf(b_self),parent=proto.constructor.$parent\nvar factory=function(){var p=parent.bind(b_self),res\nif(parent.toString().startsWith(\"class\")){res=new p(...arguments)}else{res=p(...arguments)}\nfor(key in res){b_self[key]=res[key]}\nreturn res}\nreturn{\n__class__:super_class,__init__:factory,__self_class__:b_self}}\n)\nsuper_class.__getattribute__=function(self,attr){if(attr==\"__init__\" ||attr==\"__call__\"){return self.__init__}\nreturn $B.$getattr(self.__self_class__,attr)}\n$B.set_func_names(super_class,\"javascript\")\nmodules['javascript']={\"this\":function(){\nif($B.js_this===undefined){return $B.builtins.None}\nreturn $B.JSObj.$factory($B.js_this)},\"Date\":self.Date && $B.JSObj.$factory(self.Date),\"extends\":function(js_constr){return function(obj){if(obj.$is_class){var factory=function(){var init=$B.$getattr(obj,\"__init__\",_b_.None)\nif(init !==_b_.None){init.bind(this,this).apply(this,arguments)}\nreturn this}\nfactory.prototype=Object.create(js_constr.prototype)\nfactory.prototype.constructor=factory\nfactory.$parent=js_constr.$js_func\nfactory.$is_class=true \nfactory.$infos=obj.$infos\nfor(var key in obj){if(typeof obj[key]==\"function\"){factory.prototype[key]=(function(x){return function(){\nreturn obj[x].bind(this,this).apply(this,arguments)}})(key)}}\nreturn factory}}},JSON:{__class__:$B.make_class(\"JSON\"),parse:function(){return $B.structuredclone2pyobj(\nJSON.parse.apply(this,arguments))},stringify:function(obj,replacer,space){return JSON.stringify($B.pyobj2structuredclone(obj,false),$B.JSObj.$factory(replacer),space)}},jsobj2pyobj:function(obj){return $B.jsobj2pyobj(obj)},load:function(script_url){console.log('\"javascript.load\" is deprecrated. '+\n'Use browser.load instead.')\nvar file_obj=$B.builtins.open(script_url)\nvar content=$B.$getattr(file_obj,'read')()\neval(content)},\"Math\":self.Math && $B.JSObj.$factory(self.Math),NULL:null,\"Number\":self.Number && $B.JSObj.$factory(self.Number),py2js:function(src,module_name){if(module_name===undefined){module_name='__main__'+$B.UUID()}\nvar js=$B.py2js(src,module_name,module_name,$B.builtins_scope).to_js()\nreturn $B.format_indent(js,0)},pyobj2jsobj:function(obj){return $B.pyobj2jsobj(obj)},\"RegExp\":self.RegExp && $B.JSObj.$factory(self.RegExp),\"String\":self.String && $B.JSObj.$factory(self.String),\"super\":super_class,UNDEFINED:$B.Undefined,UndefinedType:$B.UndefinedClass}\nvar arraybuffers=[\"Int8Array\",\"Uint8Array\",\"Uint8ClampedArray\",\"Int16Array\",\"Uint16Array\",\"Int32Array\",\"Uint32Array\",\"Float32Array\",\"Float64Array\",\"BigInt64Array\",\"BigUint64Array\"]\narraybuffers.forEach(function(ab){if(self[ab]!==undefined){modules['javascript'][ab]=$B.JSObj.$factory(self[ab])}})\nvar _b_=$B.builtins\nmodules['_sys']={\nGetframe :function(){var $=$B.args(\"_getframe\",1,{depth:null},['depth'],arguments,{depth:0},null,null),depth=$.depth\nreturn $B._frame.$factory($B.frames_stack,$B.frames_stack.length-depth-1)},breakpointhook:function(){var hookname=$B.$options.breakpoint,modname,dot,funcname,hook\nif(hookname===undefined){hookname=\"pdb.set_trace\"}\n[modname,dot,funcname]=_b_.str.rpartition(hookname,'.')\nif(dot==\"\"){modname=\"builtins\"}\ntry{$B.$import(modname)\nhook=$B.$getattr($B.imported[modname],funcname)}catch(err){console.warn(\"cannot import breakpoint\",hookname)\nreturn _b_.None}\nreturn $B.$call(hook).apply(null,arguments)},exc_info:function(){for(var i=$B.frames_stack.length-1;i >=0;i--){var frame=$B.frames_stack[i],exc=frame[1].$current_exception\nif(exc){return _b_.tuple.$factory([exc.__class__,exc,$B.$getattr(exc,\"__traceback__\")])}}\nreturn _b_.tuple.$factory([_b_.None,_b_.None,_b_.None])},excepthook:function(exc_class,exc_value,traceback){$B.handle_error(exc_value)},gettrace:function(){return $B.tracefunc ||_b_.None},max_string_length:$B.max_string_length,\nmodules:_b_.property.$factory(\nfunction(){return $B.obj_dict($B.imported)},function(self,value){throw _b_.TypeError.$factory(\"Read only property 'sys.modules'\")}\n),path:_b_.property.$factory(\nfunction(){return $B.path},function(self,value){$B.path=value;}\n),meta_path:_b_.property.$factory(\nfunction(){return $B.meta_path},function(self,value){$B.meta_path=value}\n),path_hooks:_b_.property.$factory(\nfunction(){return $B.path_hooks},function(self,value){$B.path_hooks=value}\n),path_importer_cache:_b_.property.$factory(\nfunction(){return _b_.dict.$factory($B.JSObj.$factory($B.path_importer_cache))},function(self,value){throw _b_.TypeError.$factory(\"Read only property\"+\n\" 'sys.path_importer_cache'\")}\n),settrace:function(){var $=$B.args(\"settrace\",1,{tracefunc:null},['tracefunc'],arguments,{},null,null)\n$B.tracefunc=$.tracefunc\n$B.last($B.frames_stack)[1].$f_trace=$B.tracefunc\n$B.tracefunc.$current_frame_id=$B.last($B.frames_stack)[0]\nreturn _b_.None},stderr:_b_.property.$factory(\nfunction(){return $B.stderr},function(self,value){$B.stderr=value}\n),stdout:_b_.property.$factory(\nfunction(){return $B.stdout},function(self,value){$B.stdout=value}\n),stdin:_b_.property.$factory(\nfunction(){return $B.stdin},function(self,value){$B.stdin=value}\n),vfs:_b_.property.$factory(\nfunction(){if($B.hasOwnProperty(\"VFS\")){return $B.obj_dict($B.VFS)}else{return _b_.None}},function(){throw _b_.TypeError.$factory(\"Read only property 'sys.vfs'\")}\n)}\nmodules._sys.__breakpointhook__=modules._sys.breakpointhook\nvar WarningMessage=$B.make_class(\"WarningMessage\",function(){var $=$B.make_args(\"WarningMessage\",8,{message:null,category:null,filename:null,lineno:null,file:null,line:null,source:null},['message','category','filename','lineno','file','line','source'],arguments,{file:_b_.None,line:_b_.None,source:_b_.None},null,null)\nreturn{\n__class__:WarningMessage,message:$.message,category:$.category,filename:$.filename,lineno:$.lineno,file:$.file,line:$.line,source:$.source,_category_name:_b_.bool.$factory($.category)?\n$B.$getattr($.category,\"__name__\"):_b_.None}}\n)\nmodules._warnings={_defaultaction:\"default\",_filters_mutated:function(){},_onceregistry:$B.empty_dict(),filters:[$B.fast_tuple(['default',_b_.None,_b_.DeprecationWarning,'__main__',0]),$B.fast_tuple(['ignore',_b_.None,_b_.DeprecationWarning,_b_.None,0]),$B.fast_tuple(['ignore',_b_.None,_b_.PendingDeprecationWarning,_b_.None,0]),$B.fast_tuple(['ignore',_b_.None,_b_.ImportWarning,_b_.None,0]),$B.fast_tuple(['ignore',_b_.None,_b_.ResourceWarning,_b_.None,0])\n],warn:function(message){\nvar filters\nif($B.imported.warnings){filters=$B.imported.warnings.filters}else{filters=modules._warnings.filters}\nif(filters[0][0]=='error'){var syntax_error=_b_.SyntaxError.$factory(message.args[0])\nsyntax_error.args[1]=[message.filename,message.lineno,message.offset,message.line]\nsyntax_error.filename=message.filename\nsyntax_error.lineno=message.lineno\nsyntax_error.offset=message.offset\nsyntax_error.line=message.line\nthrow syntax_error}\nvar frame=$B.imported._sys.Getframe()\nwarning_message={__class__:WarningMessage,message:message,category:message.__class__,filename:message.filename ||frame.f_code.co_filename,lineno:message.lineno ||frame.f_lineno,file:_b_.None,line:_b_.None,source:_b_.None,_category_name:message.__class__.__name__}\nif($B.imported.warnings){$B.imported.warnings._showwarnmsg_impl(warning_message)}else{var trace=$B.class_name(message)+': '+message.args[0]\n$B.$getattr($B.stderr,'write')(trace+'\\n')\nvar flush=$B.$getattr($B.stderr,'flush',_b_.None)\nif(flush !==_b_.None){flush()}}},warn_explicit:function(){\nconsole.log(\"warn_explicit\",arguments)}}\nfunction load(name,module_obj){\nmodule_obj.__class__=$B.module\nmodule_obj.__name__=name\n$B.imported[name]=module_obj\nfor(var attr in module_obj){if(typeof module_obj[attr]=='function'){module_obj[attr].$infos={__module__:name,__name__:attr,__qualname__:name+'.'+attr}}}}\nfor(var attr in modules){load(attr,modules[attr])}\nif(!($B.isWebWorker ||$B.isNode)){modules['browser'].html=modules['browser.html']}\nvar _b_=$B.builtins\n_b_.__builtins__=$B.module.$factory('__builtins__','Python builtins')\nfor(var attr in _b_){_b_.__builtins__[attr]=_b_[attr]\n$B.builtins_scope.binding[attr]=true\nif(_b_[attr].$is_class){if(_b_[attr].__bases__){_b_[attr].__bases__.__class__=_b_.tuple}else{_b_[attr].__bases__=$B.fast_tuple([_b_.object])}}}\n_b_.__builtins__.__setattr__=function(attr,value){_b_[attr]=value}\n$B.method_descriptor.__getattribute__=$B.Function.__getattribute__\n$B.wrapper_descriptor.__getattribute__=$B.Function.__getattribute__\nfor(var name in _b_){if(_b_[name].__class__===_b_.type){$B.builtin_classes.push(_b_[name])\nfor(var key in _b_[name]){var value=_b_[name][key]\nif(value===undefined){continue}\nelse if(value.__class__){continue}\nelse if(typeof value !=\"function\"){continue}\nelse if(key==\"__new__\"){value.__class__=$B.builtin_function}else if(key.startsWith(\"__\")){value.__class__=$B.wrapper_descriptor}else{value.__class__=$B.method_descriptor}\nvalue.__objclass__=_b_[name]}}}\nfor(var attr in $B){if(Array.isArray($B[attr])){$B[attr].__class__=_b_.list}}\n$B.cell=$B.make_class(\"cell\",function(value){return{\n__class__:$B.cell,$cell_contents:value}}\n)\n$B.cell.cell_contents=$B.$call(_b_.property)(\nfunction(self){if(self.$cell_contents===null){throw _b_.ValueError.$factory(\"empty cell\")}\nreturn self.$cell_contents},function(self,value){self.$cell_contents=value}\n)\nvar $comps=Object.values($B.$comps).concat([\"eq\",\"ne\"])\n$comps.forEach(function(comp){var op=\"__\"+comp+\"__\"\n$B.cell[op]=(function(op){return function(self,other){if(! _b_.isinstance(other,$B.cell)){return _b_.NotImplemented}\nif(self.$cell_contents===null){if(other.$cell_contents===null){return op==\"__eq__\"}else{return[\"__ne__\",\"__lt__\",\"__le__\"].indexOf(op)>-1}}else if(other.$cell_contents===null){return[\"__ne__\",\"__gt__\",\"__ge__\"].indexOf(op)>-1}\nreturn $B.rich_comp(op,self.$cell_contents,other.$cell_contents)}})(op)})\n$B.set_func_names($B.cell,\"builtins\")\n$B.AST={__class__:_b_.type,__getattr__:function(self,attr){var res=self.js_node[attr]\nif(res===undefined){throw $B.attr_error(attr,self)}\nreturn $B.AST.$convert(res)},__mro__:[_b_.object],$infos:{__qualname__:'AST',__name__:'AST'},$is_class:true,$convert:function(js_node){if(js_node===undefined){return _b_.None}\nvar constr=js_node.constructor\nif(constr && constr.$name){return $B.python_ast_classes[constr.$name].$factory(js_node)}else if(Array.isArray(js_node)){return js_node.map($B.AST.$convert)}else if(js_node.type){\nswitch(js_node.type){case 'int':\nvar res=parseInt(js_node.value[1],js_node.value[0])\nif(res < $B.min_int ||res > $B.max_int){return $B.long_int.$factory(js_node.value[1],js_node.value[0])}\nreturn res\ncase 'float':\nreturn new Number(js_node.value)\ncase 'imaginary':\nreturn $B.make_complex(0,$B.AST.$convert(js_node.value))\ncase 'ellipsis':\nreturn _b_.Ellipsis}}else if(['string','number'].indexOf(typeof js_node)>-1){return js_node}else if(js_node.$name){\nreturn js_node.$name+'()'}else if([_b_.None,_b_.True,_b_.False].indexOf(js_node)>-1){return js_node}else if(js_node.__class__){return js_node}else{console.log('cannot handle',js_node)\nreturn js_node}}}})(__BRYTHON__)\n;\n;(function($B){var _b_=$B.builtins\nvar coroutine=$B.coroutine=$B.make_class(\"coroutine\")\ncoroutine.close=function(self){}\ncoroutine.send=function(self){return self.$func.apply(null,self.$args)}\ncoroutine.__repr__=coroutine.__str__=function(self){if(self.$func.$infos){return \"<coroutine \"+self.$func.$infos.__name__+\">\"}else{return \"<coroutine object>\"}}\n$B.set_func_names(coroutine,\"builtins\")\n$B.make_async=func=>{\nif(func.$is_genfunc){return func}\nvar f=function(){var args=arguments,stack=$B.deep_copy($B.frames_stack)\nreturn{\n__class__:coroutine,$args:args,$func:func,$stack:stack}}\nf.$infos=func.$infos\nreturn f}\n$B.promise=function(obj){if(obj.__class__===coroutine){return coroutine.send(obj)}\nif(typeof obj==\"function\"){return obj()}\nreturn obj}})(__BRYTHON__)\n;\n\n\n//# sourceURL=webpack:///./node_modules/brython/brython.js?");

/***/ }),

/***/ "./node_modules/codemirror/addon/comment/comment.js":
/*!**********************************************************!*\
  !*** ./node_modules/codemirror/addon/comment/comment.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ \"./node_modules/codemirror/lib/codemirror.js\"));\n  else {}\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var noOptions = {};\n  var nonWS = /[^\\s\\u00a0]/;\n  var Pos = CodeMirror.Pos, cmp = CodeMirror.cmpPos;\n\n  function firstNonWS(str) {\n    var found = str.search(nonWS);\n    return found == -1 ? 0 : found;\n  }\n\n  CodeMirror.commands.toggleComment = function(cm) {\n    cm.toggleComment();\n  };\n\n  CodeMirror.defineExtension(\"toggleComment\", function(options) {\n    if (!options) options = noOptions;\n    var cm = this;\n    var minLine = Infinity, ranges = this.listSelections(), mode = null;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      if (from.line >= minLine) continue;\n      if (to.line >= minLine) to = Pos(minLine, 0);\n      minLine = from.line;\n      if (mode == null) {\n        if (cm.uncomment(from, to, options)) mode = \"un\";\n        else { cm.lineComment(from, to, options); mode = \"line\"; }\n      } else if (mode == \"un\") {\n        cm.uncomment(from, to, options);\n      } else {\n        cm.lineComment(from, to, options);\n      }\n    }\n  });\n\n  // Rough heuristic to try and detect lines that are part of multi-line string\n  function probablyInsideString(cm, pos, line) {\n    return /\\bstring\\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\\'\\\"\\`]/.test(line)\n  }\n\n  function getMode(cm, pos) {\n    var mode = cm.getMode()\n    return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos)\n  }\n\n  CodeMirror.defineExtension(\"lineComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var firstLine = self.getLine(from.line);\n    if (firstLine == null || probablyInsideString(self, from, firstLine)) return;\n\n    var commentString = options.lineComment || mode.lineComment;\n    if (!commentString) {\n      if (options.blockCommentStart || mode.blockCommentStart) {\n        options.fullLines = true;\n        self.blockComment(from, to, options);\n      }\n      return;\n    }\n\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);\n    var pad = options.padding == null ? \" \" : options.padding;\n    var blankLines = options.commentBlankLines || from.line == to.line;\n\n    self.operation(function() {\n      if (options.indent) {\n        var baseString = null;\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i);\n          var whitespace = line.slice(0, firstNonWS(line));\n          if (baseString == null || baseString.length > whitespace.length) {\n            baseString = whitespace;\n          }\n        }\n        for (var i = from.line; i < end; ++i) {\n          var line = self.getLine(i), cut = baseString.length;\n          if (!blankLines && !nonWS.test(line)) continue;\n          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);\n          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));\n        }\n      } else {\n        for (var i = from.line; i < end; ++i) {\n          if (blankLines || nonWS.test(self.getLine(i)))\n            self.replaceRange(commentString + pad, Pos(i, 0));\n        }\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"blockComment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) {\n      if ((options.lineComment || mode.lineComment) && options.fullLines != false)\n        self.lineComment(from, to, options);\n      return;\n    }\n    if (/\\bcomment\\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))) return\n\n    var end = Math.min(to.line, self.lastLine());\n    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;\n\n    var pad = options.padding == null ? \" \" : options.padding;\n    if (from.line > end) return;\n\n    self.operation(function() {\n      if (options.fullLines != false) {\n        var lastLineHasText = nonWS.test(self.getLine(end));\n        self.replaceRange(pad + endString, Pos(end));\n        self.replaceRange(startString + pad, Pos(from.line, 0));\n        var lead = options.blockCommentLead || mode.blockCommentLead;\n        if (lead != null) for (var i = from.line + 1; i <= end; ++i)\n          if (i != end || lastLineHasText)\n            self.replaceRange(lead + pad, Pos(i, 0));\n      } else {\n        var atCursor = cmp(self.getCursor(\"to\"), to) == 0, empty = !self.somethingSelected()\n        self.replaceRange(endString, to);\n        if (atCursor) self.setSelection(empty ? to : self.getCursor(\"from\"), to)\n        self.replaceRange(startString, from);\n      }\n    });\n  });\n\n  CodeMirror.defineExtension(\"uncomment\", function(from, to, options) {\n    if (!options) options = noOptions;\n    var self = this, mode = getMode(self, from);\n    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self.lastLine()), start = Math.min(from.line, end);\n\n    // Try finding line comments\n    var lineString = options.lineComment || mode.lineComment, lines = [];\n    var pad = options.padding == null ? \" \" : options.padding, didSomething;\n    lineComment: {\n      if (!lineString) break lineComment;\n      for (var i = start; i <= end; ++i) {\n        var line = self.getLine(i);\n        var found = line.indexOf(lineString);\n        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;\n        if (found == -1 && nonWS.test(line)) break lineComment;\n        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;\n        lines.push(line);\n      }\n      self.operation(function() {\n        for (var i = start; i <= end; ++i) {\n          var line = lines[i - start];\n          var pos = line.indexOf(lineString), endPos = pos + lineString.length;\n          if (pos < 0) continue;\n          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;\n          didSomething = true;\n          self.replaceRange(\"\", Pos(i, pos), Pos(i, endPos));\n        }\n      });\n      if (didSomething) return true;\n    }\n\n    // Try block comments\n    var startString = options.blockCommentStart || mode.blockCommentStart;\n    var endString = options.blockCommentEnd || mode.blockCommentEnd;\n    if (!startString || !endString) return false;\n    var lead = options.blockCommentLead || mode.blockCommentLead;\n    var startLine = self.getLine(start), open = startLine.indexOf(startString)\n    if (open == -1) return false\n    var endLine = end == start ? startLine : self.getLine(end)\n    var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);\n    var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1)\n    if (close == -1 ||\n        !/comment/.test(self.getTokenTypeAt(insideStart)) ||\n        !/comment/.test(self.getTokenTypeAt(insideEnd)) ||\n        self.getRange(insideStart, insideEnd, \"\\n\").indexOf(endString) > -1)\n      return false;\n\n    // Avoid killing block comments completely outside the selection.\n    // Positions of the last startString before the start of the selection, and the first endString after it.\n    var lastStart = startLine.lastIndexOf(startString, from.ch);\n    var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);\n    if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch) return false;\n    // Positions of the first endString after the end of the selection, and the last startString before it.\n    firstEnd = endLine.indexOf(endString, to.ch);\n    var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);\n    lastStart = (firstEnd == -1 || almostLastStart == -1) ? -1 : to.ch + almostLastStart;\n    if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch) return false;\n\n    self.operation(function() {\n      self.replaceRange(\"\", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),\n                        Pos(end, close + endString.length));\n      var openEnd = open + startString.length;\n      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;\n      self.replaceRange(\"\", Pos(start, open), Pos(start, openEnd));\n      if (lead) for (var i = start + 1; i <= end; ++i) {\n        var line = self.getLine(i), found = line.indexOf(lead);\n        if (found == -1 || nonWS.test(line.slice(0, found))) continue;\n        var foundEnd = found + lead.length;\n        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;\n        self.replaceRange(\"\", Pos(i, found), Pos(i, foundEnd));\n      }\n    });\n    return true;\n  });\n});\n\n\n//# sourceURL=webpack:///./node_modules/codemirror/addon/comment/comment.js?");

/***/ }),

/***/ "./node_modules/codemirror/addon/mode/simple.js":
/*!******************************************************!*\
  !*** ./node_modules/codemirror/addon/mode/simple.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ \"./node_modules/codemirror/lib/codemirror.js\"));\n  else {}\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineSimpleMode = function(name, states) {\n    CodeMirror.defineMode(name, function(config) {\n      return CodeMirror.simpleMode(config, states);\n    });\n  };\n\n  CodeMirror.simpleMode = function(config, states) {\n    ensureState(states, \"start\");\n    var states_ = {}, meta = states.meta || {}, hasIndentation = false;\n    for (var state in states) if (state != meta && states.hasOwnProperty(state)) {\n      var list = states_[state] = [], orig = states[state];\n      for (var i = 0; i < orig.length; i++) {\n        var data = orig[i];\n        list.push(new Rule(data, states));\n        if (data.indent || data.dedent) hasIndentation = true;\n      }\n    }\n    var mode = {\n      startState: function() {\n        return {state: \"start\", pending: null,\n                local: null, localState: null,\n                indent: hasIndentation ? [] : null};\n      },\n      copyState: function(state) {\n        var s = {state: state.state, pending: state.pending,\n                 local: state.local, localState: null,\n                 indent: state.indent && state.indent.slice(0)};\n        if (state.localState)\n          s.localState = CodeMirror.copyState(state.local.mode, state.localState);\n        if (state.stack)\n          s.stack = state.stack.slice(0);\n        for (var pers = state.persistentStates; pers; pers = pers.next)\n          s.persistentStates = {mode: pers.mode,\n                                spec: pers.spec,\n                                state: pers.state == state.localState ? s.localState : CodeMirror.copyState(pers.mode, pers.state),\n                                next: s.persistentStates};\n        return s;\n      },\n      token: tokenFunction(states_, config),\n      innerMode: function(state) { return state.local && {mode: state.local.mode, state: state.localState}; },\n      indent: indentFunction(states_, meta)\n    };\n    if (meta) for (var prop in meta) if (meta.hasOwnProperty(prop))\n      mode[prop] = meta[prop];\n    return mode;\n  };\n\n  function ensureState(states, name) {\n    if (!states.hasOwnProperty(name))\n      throw new Error(\"Undefined state \" + name + \" in simple mode\");\n  }\n\n  function toRegex(val, caret) {\n    if (!val) return /(?:)/;\n    var flags = \"\";\n    if (val instanceof RegExp) {\n      if (val.ignoreCase) flags = \"i\";\n      if (val.unicode) flags += \"u\"\n      val = val.source;\n    } else {\n      val = String(val);\n    }\n    return new RegExp((caret === false ? \"\" : \"^\") + \"(?:\" + val + \")\", flags);\n  }\n\n  function asToken(val) {\n    if (!val) return null;\n    if (val.apply) return val\n    if (typeof val == \"string\") return val.replace(/\\./g, \" \");\n    var result = [];\n    for (var i = 0; i < val.length; i++)\n      result.push(val[i] && val[i].replace(/\\./g, \" \"));\n    return result;\n  }\n\n  function Rule(data, states) {\n    if (data.next || data.push) ensureState(states, data.next || data.push);\n    this.regex = toRegex(data.regex);\n    this.token = asToken(data.token);\n    this.data = data;\n  }\n\n  function tokenFunction(states, config) {\n    return function(stream, state) {\n      if (state.pending) {\n        var pend = state.pending.shift();\n        if (state.pending.length == 0) state.pending = null;\n        stream.pos += pend.text.length;\n        return pend.token;\n      }\n\n      if (state.local) {\n        if (state.local.end && stream.match(state.local.end)) {\n          var tok = state.local.endToken || null;\n          state.local = state.localState = null;\n          return tok;\n        } else {\n          var tok = state.local.mode.token(stream, state.localState), m;\n          if (state.local.endScan && (m = state.local.endScan.exec(stream.current())))\n            stream.pos = stream.start + m.index;\n          return tok;\n        }\n      }\n\n      var curState = states[state.state];\n      for (var i = 0; i < curState.length; i++) {\n        var rule = curState[i];\n        var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);\n        if (matches) {\n          if (rule.data.next) {\n            state.state = rule.data.next;\n          } else if (rule.data.push) {\n            (state.stack || (state.stack = [])).push(state.state);\n            state.state = rule.data.push;\n          } else if (rule.data.pop && state.stack && state.stack.length) {\n            state.state = state.stack.pop();\n          }\n\n          if (rule.data.mode)\n            enterLocalMode(config, state, rule.data.mode, rule.token);\n          if (rule.data.indent)\n            state.indent.push(stream.indentation() + config.indentUnit);\n          if (rule.data.dedent)\n            state.indent.pop();\n          var token = rule.token\n          if (token && token.apply) token = token(matches)\n          if (matches.length > 2 && rule.token && typeof rule.token != \"string\") {\n            for (var j = 2; j < matches.length; j++)\n              if (matches[j])\n                (state.pending || (state.pending = [])).push({text: matches[j], token: rule.token[j - 1]});\n            stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));\n            return token[0];\n          } else if (token && token.join) {\n            return token[0];\n          } else {\n            return token;\n          }\n        }\n      }\n      stream.next();\n      return null;\n    };\n  }\n\n  function cmp(a, b) {\n    if (a === b) return true;\n    if (!a || typeof a != \"object\" || !b || typeof b != \"object\") return false;\n    var props = 0;\n    for (var prop in a) if (a.hasOwnProperty(prop)) {\n      if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop])) return false;\n      props++;\n    }\n    for (var prop in b) if (b.hasOwnProperty(prop)) props--;\n    return props == 0;\n  }\n\n  function enterLocalMode(config, state, spec, token) {\n    var pers;\n    if (spec.persistent) for (var p = state.persistentStates; p && !pers; p = p.next)\n      if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode) pers = p;\n    var mode = pers ? pers.mode : spec.mode || CodeMirror.getMode(config, spec.spec);\n    var lState = pers ? pers.state : CodeMirror.startState(mode);\n    if (spec.persistent && !pers)\n      state.persistentStates = {mode: mode, spec: spec.spec, state: lState, next: state.persistentStates};\n\n    state.localState = lState;\n    state.local = {mode: mode,\n                   end: spec.end && toRegex(spec.end),\n                   endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),\n                   endToken: token && token.join ? token[token.length - 1] : token};\n  }\n\n  function indexOf(val, arr) {\n    for (var i = 0; i < arr.length; i++) if (arr[i] === val) return true;\n  }\n\n  function indentFunction(states, meta) {\n    return function(state, textAfter, line) {\n      if (state.local && state.local.mode.indent)\n        return state.local.mode.indent(state.localState, textAfter, line);\n      if (state.indent == null || state.local || meta.dontIndentStates && indexOf(state.state, meta.dontIndentStates) > -1)\n        return CodeMirror.Pass;\n\n      var pos = state.indent.length - 1, rules = states[state.state];\n      scan: for (;;) {\n        for (var i = 0; i < rules.length; i++) {\n          var rule = rules[i];\n          if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {\n            var m = rule.regex.exec(textAfter);\n            if (m && m[0]) {\n              pos--;\n              if (rule.next || rule.push) rules = states[rule.next || rule.push];\n              textAfter = textAfter.slice(m[0].length);\n              continue scan;\n            }\n          }\n        }\n        break;\n      }\n      return pos < 0 ? 0 : state.indent[pos];\n    };\n  }\n});\n\n\n//# sourceURL=webpack:///./node_modules/codemirror/addon/mode/simple.js?");

/***/ }),

/***/ "./node_modules/codemirror/lib/codemirror.js":
/*!***************************************************!*\
  !*** ./node_modules/codemirror/lib/codemirror.js ***!
  \***************************************************/
/***/ (function(module) {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// This is CodeMirror (https://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n  var android = /Android/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) { presto_version = Number(presto_version[1]); }\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\n  var rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      { e.removeChild(e.firstChild); }\n    return e\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e)\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) { e.className = className; }\n    if (style) { e.style.cssText = style; }\n    if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n    return e\n  }\n  // wrapper for elt, which removes the elt from the accessibility tree\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e\n  }\n\n  var range;\n  if (document.createRange) { range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r\n  }; }\n  else { range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r\n  }; }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      { child = child.parentNode; }\n    if (parent.contains)\n      { return parent.contains(child) }\n    do {\n      if (child.nodeType == 11) { child = child.host; }\n      if (child == parent) { return true }\n    } while (child = child.parentNode)\n  }\n\n  function activeElt() {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n    try {\n      activeElement = document.activeElement;\n    } catch(e) {\n      activeElement = document.body || null;\n    }\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      { activeElement = activeElement.shadowRoot.activeElement; }\n    return activeElement\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n  }\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n    return b\n  }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\n  else if (ie) // Suppress mysterious IE10 errors\n    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args)}\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) { target = {}; }\n    for (var prop in obj)\n      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        { target[prop] = obj[prop]; } }\n    return target\n  }\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) { end = string.length; }\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        { return n + (end - i) }\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function() {\n    this.id = null;\n    this.f = null;\n    this.time = 0;\n    this.handler = bind(this.onTimeout, this);\n  };\n  Delayed.prototype.onTimeout = function (self) {\n    self.id = 0;\n    if (self.time <= +new Date) {\n      self.f();\n    } else {\n      setTimeout(self.handler, self.time - +new Date);\n    }\n  };\n  Delayed.prototype.set = function (ms, f) {\n    this.f = f;\n    var time = +new Date + ms;\n    if (!this.id || time < this.time) {\n      clearTimeout(this.id);\n      this.id = setTimeout(this.handler, ms);\n      this.time = time;\n    }\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      { if (array[i] == elt) { return i } }\n    return -1\n  }\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 50;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) { nextTab = string.length; }\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        { return pos + Math.min(skipped, goal - col) }\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) { return pos }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      { spaceStrs.push(lst(spaceStrs) + \" \"); }\n    return spaceStrs[n]\n  }\n\n  function lst(arr) { return arr[arr.length-1] }\n\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n    return out\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0, priority = score(value);\n    while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) { copyObj(props, inst); }\n    return inst\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n  }\n  function isWordChar(ch, helper) {\n    if (!helper) { return isWordCharBasic(ch) }\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n    return helper.test(ch)\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n    return true\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n    return pos\n  }\n\n  // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n    for (;;) {\n      if (from == to) { return from }\n      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n      if (mid == from) { return pred(mid) ? from : to }\n      if (pred(mid)) { to = mid; }\n      else { from = mid + dir; }\n    }\n  }\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) { return f(from, to, \"ltr\", 0) }\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n    if (!found) { f(from, to, \"ltr\"); }\n  }\n\n  var bidiOther = null;\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < ch && cur.to > ch) { return i }\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n    }\n    return found != null ? found : bidiOther\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6f9\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n    function charType(code) {\n      if (code <= 0xf7) { return lowTypes.charAt(code) }\n      else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n      else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n      else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n      else if (code == 0x200c) { return \"b\" }\n      else { return \"L\" }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n      var len = str.length, types = [];\n      for (var i = 0; i < len; ++i)\n        { types.push(charType(str.charCodeAt(i))); }\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n        if (type == \"m\") { types[i$1] = prev; }\n        else { prev = type; }\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n        if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n        if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n        else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n                 (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n        prev$1 = type$2;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n        if (type$3 == \",\") { types[i$4] = \"N\"; }\n        else if (type$3 == \"%\") {\n          var end = (void 0);\n          for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i$4; j < end; ++j) { types[j] = replace; }\n          i$4 = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n        if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n        else if (isStrong.test(type$4)) { cur$1 = type$4; }\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = (void 0);\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n          var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n          var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n          i$6 = end$1 - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7, at = order.length, isRTL = direction == \"rtl\" ? 1 : 0;\n          for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }\n              var nstart = j$2;\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              at += isRTL;\n              pos = j$2;\n            } else { ++j$2; }\n          }\n          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n        }\n      }\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order\n    }\n  })();\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line, direction) {\n    var order = line.order;\n    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n    return order\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var noHandlers = [];\n\n  var on = function(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      map[type] = (map[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers, arr = map && map[type];\n      if (arr) {\n        var index = indexOf(arr, f);\n        if (index > -1)\n          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n      }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type);\n    if (!handlers.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) { return }\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n      { set.push(arr[i]); } }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) { e.stopPropagation(); }\n    else { e.cancelBubble = true; }\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\n  function e_target(e) {return e.target || e.srcElement}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) { b = 1; }\n      else if (e.button & 2) { b = 3; }\n      else if (e.button & 4) { b = 2; }\n    }\n    if (mac && e.ctrlKey && b == 1) { b = 3; }\n    return b\n  }\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) { return false }\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) { return badBidiRects }\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right < 3)\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) { nl = string.length; }\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result\n  } : function (string) { return string.split(/\\r\\n?|\\n/); };\n\n  var hasSelection = window.getSelection ? function (te) {\n    try { return te.selectionStart != te.selectionEnd }\n    catch(e) { return false }\n  } : function (te) {\n    var range;\n    try {range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) { return false }\n    return range.compareEndPoints(\"StartToEnd\", range) != 0\n  };\n\n  var hasCopyEvent = (function () {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) { return true }\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\"\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) { return badZoomedRects }\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n  }\n\n  // Known modes, by name and by MIME\n  var modes = {}, mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  function defineMode(name, mode) {\n    if (arguments.length > 2)\n      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  }\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") { found = {name: found}; }\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\")\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\")\n    }\n    if (typeof spec == \"string\") { return {name: spec} }\n    else { return spec || {name: \"null\"} }\n  }\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) { return getMode(options, \"text/plain\") }\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) { continue }\n        if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) { modeObj.helperType = spec.helperType; }\n    if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n      { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n    return modeObj\n  }\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = {};\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) { return state }\n    if (mode.copyState) { return mode.copyState(state) }\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) { val = val.concat([]); }\n      nstate[n] = val;\n    }\n    return nstate\n  }\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  function innerMode(mode, state) {\n    var info;\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n      if (!info || info.mode == mode) { break }\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state}\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true\n  }\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = function(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {return this.pos >= this.string.length};\n  StringStream.prototype.sol = function () {return this.pos == this.lineStart};\n  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length)\n      { return this.string.charAt(this.pos++) }\n  };\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n    if (typeof match == \"string\") { ok = ch == match; }\n    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n    if (ok) {++this.pos; return ch}\n  };\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start\n  };\n  StringStream.prototype.eatSpace = function () {\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }\n    return this.pos > start\n  };\n  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true}\n  };\n  StringStream.prototype.backUp = function (n) {this.pos -= n;};\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) { this.pos += pattern.length; }\n        return true\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) { return null }\n      if (match && consume !== false) { this.pos += match[0].length; }\n      return match\n    }\n  };\n  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n    try { return inner() }\n    finally { this.lineStart -= n; }\n  };\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n)\n  };\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos)\n  };\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n    var chunk = doc;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n]\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n      if (n == end.line) { text = text.slice(0, end.ch); }\n      if (n == start.line) { text = text.slice(start.ch); }\n      out.push(text);\n      ++n;\n    });\n    return out\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n    return out\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) { return null }\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) { break }\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1], ch = child.height;\n        if (h < ch) { chunk = child; continue outer }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n\n    } while (!chunk.lines)\n    var i = 0;\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) { break }\n      h -= lh;\n    }\n    return n + i\n  }\n\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber))\n  }\n\n  // A Pos instance represents a position within the text.\n  function Pos(line, ch, sticky) {\n    if ( sticky === void 0 ) sticky = null;\n\n    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  }\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\n  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\n  function copyPos(x) {return Pos(x.line, x.ch)}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) { return Pos(doc.first, 0) }\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n    return clipToLen(pos, getLine(doc, pos.line).text.length)\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n    else if (ch < 0) { return Pos(pos.line, 0) }\n    else { return pos }\n  }\n  function clipPosArray(doc, array) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n    return out\n  }\n\n  var SavedContext = function(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n    return line\n  };\n\n  Context.prototype.baseToken = function (n) {\n    if (!this.baseTokens) { return null }\n    while (this.baseTokens[this.baseTokenPos] <= n)\n      { this.baseTokenPos += 2; }\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n            size: this.baseTokens[this.baseTokenPos] - n}\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n    if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext)\n      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n    else\n      { return new Context(doc, copyState(doc.mode, saved), line) }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n  };\n\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n            lineClasses, forceToEnd);\n    var state = context.state;\n\n    // Run overlays, adjust style array.\n    var loop = function ( o ) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            { st.splice(i, 1, end, st[i+1], i_end); }\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) { return }\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n      if (resetState) { context.state = resetState; }\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n      if (result.classes) { line.styleClasses = result.classes; }\n      else if (line.styleClasses) { line.styleClasses = null; }\n      if (updateFrontier === cm.doc.highlightFrontier)\n        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n    }\n    return line.styles\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) { return new Context(doc, true, n) }\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n    if (precise) { doc.modeFrontier = context.line; }\n    return context\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") { callBlankLine(mode, context.state); }\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) { return mode.blankLine(state) }\n    if (!mode.innerMode) { return }\n    var inner = innerMode(mode, state);\n    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) { inner[0] = innerMode(mode, state).mode; }\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) { return style }\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n  }\n\n  var Token = function(stream, type, state) {\n    this.start = stream.start; this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  };\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n    if (asArray) { tokens = []; }\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n    }\n    return asArray ? tokens : new Token(stream, style, context.state)\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) { for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) { break }\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        { output[prop] = lineClass[2]; }\n      else if (!(new RegExp(\"(?:^|\\\\s)\" + lineClass[2] + \"(?:$|\\\\s)\")).test(output[prop]))\n        { output[prop] += \" \" + lineClass[2]; }\n    } }\n    return type\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) { return doc.first }\n      var line = getLine(doc, search - 1), after = line.stateAfter;\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n        { return search }\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n    if (doc.highlightFrontier < n - 10) { return }\n    var start = doc.first;\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter;\n      // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break\n      }\n    }\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  }\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) { return span }\n    } }\n  }\n\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    var r;\n    for (var i = 0; i < spans.length; ++i)\n      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n    return r\n  }\n\n  // Add a span to a line.\n  function addMarkedSpan(line, span, op) {\n    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet));\n    if (inThisOp && inThisOp.has(line.markedSpans)) {\n      line.markedSpans.push(span);\n    } else {\n      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n      if (inThisOp) { inThisOp.add(line.markedSpans); }\n    }\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    } }\n    return nw\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    } }\n    return nw\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) { return null }\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) { return null }\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) { span.to = startCh; }\n          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n        if (span$1.to != null) { span$1.to += offset; }\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n          if (!found$1) {\n            span$1.from = offset;\n            if (sameLine) { (first || (first = [])).push(span$1); }\n          }\n        } else {\n          span$1.from += offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) { first = clearEmptySpans(first); }\n    if (last && last != first) { last = clearEmptySpans(last); }\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        { for (var i$2 = 0; i$2 < first.length; ++i$2)\n          { if (first[i$2].to == null)\n            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n      for (var i$3 = 0; i$3 < gap; ++i$3)\n        { newMarkers.push(gapMarkers); }\n      newMarkers.push(last);\n    }\n    return newMarkers\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        { spans.splice(i--, 1); }\n    }\n    if (!spans.length) { return null }\n    return spans\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          { (markers || (markers = [])).push(mark); }\n      } }\n    });\n    if (!markers) { return null }\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          { newParts.push({from: p.from, to: m.from}); }\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          { newParts.push({from: m.to, to: p.to}); }\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n    return parts\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.detachLine(line); }\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.attachLine(line); }\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) { return lenDiff }\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) { return -fromCmp }\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) { return toCmp }\n    return b.id - a.id\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        { found = sp.marker; }\n    } }\n    return found\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }\n    } }\n    return found\n  }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n        { return true }\n    } }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      { line = merged.find(-1, true).line; }\n    return line\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return line\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line\n      ;(lines || (lines = [])).push(line);\n    }\n    return lines\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) { return lineN }\n    return lineNo(vis)\n  }\n\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) { return lineN }\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) { return lineN }\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return lineNo(line) + 1\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      if (sp.from == null) { return true }\n      if (sp.marker.widgetNode) { continue }\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        { return true }\n    } }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      { return true }\n    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) { return true }\n    }\n  }\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) { break }\n      else { h += line.height; }\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n        if (cur == chunk) { break }\n        else { h += cur.height; }\n      }\n    }\n    return h\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) { return 0 }\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n    return len\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () { return lineNo(this) };\n  eventMixin(Line);\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n    if (line.order != null) { line.order = null; }\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) { return null }\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n        if (line.styleClasses.textClass)\n          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild;\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n        { builder.content.className = \"cm-tab-wrap-hack\"; }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n    return builder\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) { return }\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    var content;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) { mustWrap = true; }\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n          else { content.appendChild(txt); }\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) { break }\n        pos += skipped + 1;\n        var txt$1 = (void 0);\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n          else { content.appendChild(txt$1); }\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n    if (style || startStyle || endStyle || mustWrap || css || attributes) {\n      var fullStyle = style || \"\";\n      if (startStyle) { fullStyle += startStyle; }\n      if (endStyle) { fullStyle += endStyle; }\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (attributes) {\n        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\")\n          { token.setAttribute(attr, attributes[attr]); } }\n      }\n      return builder.content.appendChild(token)\n    }\n    builder.content.appendChild(content);\n  }\n\n  // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) { return text }\n    var spaceBefore = trailingBefore, result = \"\";\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        { ch = \"\\u00a0\"; }\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = (void 0);\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n          if (part.to > start && part.from <= start) { break }\n        }\n        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    }\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        { widget = builder.content.appendChild(document.createElement(\"span\")); }\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n      return\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles = (void 0);\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) { spanStyle += \" \" + m.className; }\n            if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n            if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n            // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n            if (m.title) { (attributes || (attributes = {})).title = m.title; }\n            if (m.attributes) {\n              for (var attr in m.attributes)\n                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }\n            }\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              { collapsed = sp; }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) { return }\n          if (collapsed.to == pos) { collapsed = false; }\n        }\n      }\n      if (pos >= len) { break }\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        { callbacks[i].call(null); }\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n      }\n    } while (i < callbacks.length)\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n    if (!group) { return }\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type);\n    if (!arr.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    var loop = function ( i ) {\n      list.push(function () { return arr[i].apply(null, args); });\n    };\n\n    for (var i = 0; i < arr.length; ++i)\n      loop( i );\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") { updateLineText(cm, lineView); }\n      else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n      else if (type == \"class\") { updateLineClasses(cm, lineView); }\n      else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n    }\n    return lineView.node\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) { cls += \" CodeMirror-linebackground\"; }\n    if (lineView.background) {\n      if (cls) { lineView.background.className = cls; }\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built\n    }\n    return buildLineContent(cm, lineView)\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) { lineView.node = built.pre; }\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n    if (lineView.line.wrapClass)\n      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n    else if (lineView.node != lineView.text)\n      { lineView.node.className = \"\"; }\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n      gutterWrap.setAttribute(\"aria-hidden\", \"true\");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        { lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                     (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n      } }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) { lineView.alignable = null; }\n    var isWidget = classTest(\"CodeMirror-linewidget\");\n    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n      next = node.nextSibling;\n      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) { lineView.bgClass = built.bgClass; }\n    if (built.textClass) { lineView.textClass = built.textClass; }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) { return }\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\" + (widget.className ? \" \" + widget.className : \"\"));\n      if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n      else\n        { wrap.appendChild(node); }\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n  (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) { return widget.height }\n    var cm = widget.doc.cm;\n    if (!cm) { return 0 }\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n      if (widget.noHScroll)\n        { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight\n  }\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        { return true }\n    }\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\n  function paddingH(display) {\n    if (display.cachedPaddingH) { return display.cachedPaddingH }\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\", \"CodeMirror-line-like\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n    return data\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n    for (var i = 0; i < lineView.rest.length; i++)\n      { if (lineView.rest[i] == line)\n        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n      { if (lineNo(lineView.rest[i$1]) > lineN)\n        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      { return cm.display.view[findViewIndex(cm, lineN)] }\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      { return ext }\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      { view = updateExternalMeasurement(cm, line); }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    }\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) { ch = -1; }\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) { prepared.cache[key] = found; }\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom}\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      mStart = map[i];\n      mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) { collapse = \"right\"; }\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          { collapse = bias; }\n        if (bias == \"left\" && start == 0)\n          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          } }\n        if (bias == \"right\" && start == mEnd - mStart)\n          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          } }\n        break\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n    if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) { break }\n    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n      if ((rect = rects[i$1]).left != rect.right) { break }\n    } }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n          { rect = node.parentNode.getBoundingClientRect(); }\n        else\n          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n        if (rect.left || rect.right || start == 0) { break }\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) { collapse = bias = \"right\"; }\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n      else\n        { rect = node.getBoundingClientRect(); }\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n      else\n        { rect = nullRect; }\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n    for (; i < heights.length - 1; i++)\n      { if (mid < heights[i]) { break } }\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) { result.bogus = true; }\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      { return rect }\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n        { lineView.measure.caches[i] = {}; } }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      { clearLineMeasurementCacheFor(cm.display.view[i]); }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n  }\n  function pageScrollY() {\n    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop\n  }\n\n  function widgetTopHeight(lineObj) {\n    var height = 0;\n    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n      { height += widgetHeight(lineObj.widgets[i]); } } }\n    return height\n  }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height; rect.bottom += height;\n    }\n    if (context == \"line\") { return rect }\n    if (!context) { context = \"local\"; }\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") { yOff += paddingTop(cm.display); }\n    else { yOff -= cm.display.viewOffset; }\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") { return coords }\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) { m.left = m.right; } else { m.right = m.left; }\n      return intoCoordSystem(cm, lineObj, m, context)\n    }\n    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n    if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos], right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert)\n    }\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n    if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n    return val\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height}\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n    if (outside) { pos.outside = outside; }\n    return pos\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }\n    if (x < 0) { x = 0; }\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n      if (!collapsed) { return found }\n      var rangeEnd = collapsed.find(1);\n      if (rangeEnd.line == lineN) { return rangeEnd }\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n    return {begin: begin, end: end}\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n  }\n\n  // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    // Move y into line-local coordinate space\n    y -= heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n    var widgetHeight = widgetTopHeight(lineObj);\n    var begin = 0, end = lineObj.text.length, ltr = true;\n\n    var order = getOrder(lineObj, cm.doc.direction);\n    // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);\n      ltr = part.level != 1;\n      // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    }\n\n    // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n    var chAround = null, boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight; box.bottom += widgetHeight;\n      if (!boxIsAfter(box, x, y, false)) { return false }\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n      return true\n    }, begin, end);\n\n    var baseX, sticky, outside = false;\n    // If a box around the coordinates was found, use that\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) { ch++; }\n      // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?\n        \"after\" : \"before\";\n      // Now get accurate coordinates for this place, in order to get a\n      // base X position\n      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), \"line\", lineObj, preparedMeasure);\n      baseX = coords.left;\n      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i], ltr = part.level != 1;\n      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                     \"line\", lineObj, preparedMeasure), x, y, true)\n    }, 0, order.length - 1);\n    var part = order[index];\n    // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n    if (index > 0) {\n      var ltr = part.level != 1;\n      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                               \"line\", lineObj, preparedMeasure);\n      if (boxIsAfter(start, x, y, true) && start.top > y)\n        { part = order[index - 1]; }\n    }\n    return part\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n    var part = null, closestDist = null;\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n      if (p.from >= end || p.to <= begin) { continue }\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n      // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n    if (!part) { part = order[order.length - 1]; }\n    // Clip the part to the wrapped line.\n    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n    return part\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n    if (measureText == null) {\n      measureText = elt(\"pre\", null, \"CodeMirror-line-like\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) { display.cachedTextHeight = height; }\n    removeChildren(display.measure);\n    return height || 1\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor], \"CodeMirror-line-like\");\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) { display.cachedCharWidth = width; }\n    return width || 10\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      var id = cm.display.gutterSpecs[i].className;\n      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[id] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth}\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) { return 0 }\n\n      var widgetsHeight = 0;\n      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n      } }\n\n      if (wrapping)\n        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n      else\n        { return widgetsHeight + th }\n    }\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n    });\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e$1) { return null }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) { return null }\n    n -= cm.display.viewFrom;\n    if (n < 0) { return null }\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) { return i }\n    }\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) { from = cm.doc.first; }\n    if (to == null) { to = cm.doc.first + cm.doc.size; }\n    if (!lendiff) { lendiff = 0; }\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      { display.updateLineNumbers = from; }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        { resetView(cm); }\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        { ext.lineN += lendiff; }\n      else if (from < ext.lineN + ext.size)\n        { display.externalMeasured = null; }\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n\n    if (line < display.viewFrom || line >= display.viewTo) { return }\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) { return }\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) { arr.push(type); }\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      { return {index: index, lineN: newN} }\n    var n = cm.display.viewFrom;\n    for (var i = 0; i < index; i++)\n      { n += view[i].size; }\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) { return null }\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN}\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n      else if (display.viewFrom < from)\n        { display.view = display.view.slice(findViewIndex(cm, from)); }\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n      else if (display.viewTo > to)\n        { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n    }\n    return dirty\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if ( primary === void 0 ) primary = true;\n\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) { continue }\n      var range = doc.sel.ranges[i];\n      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }\n      var collapsed = range.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        { drawSelectionCursor(cm, range.head, curFragment); }\n      if (!collapsed)\n        { drawSelectionRange(cm, range, selFragment); }\n    }\n    return result\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) { top = 0; }\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop]\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n        var first = i == 0, last = !order || i == order.length - 1;\n        if (toPos.top - fromPos.top <= 3) { // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else { // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n        if (cmpCoords(toPos, start) < 0) { start = toPos; }\n        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n        if (cmpCoords(toPos, end) < 0) { end = toPos; }\n      });\n      return {start: start, end: end}\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) { return }\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      { display.blinker = setInterval(function () {\n        if (!cm.hasFocus()) { onBlur(cm); }\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate); }\n    else if (cm.options.cursorBlinkRate < 0)\n      { display.cursorDiv.style.visibility = \"hidden\"; }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.hasFocus()) {\n      cm.display.input.focus();\n      if (!cm.state.focused) { onFocus(cm); }\n    }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { if (cm.state.delayingBlurEvent) {\n      cm.state.delayingBlurEvent = false;\n      if (cm.state.focused) { onBlur(cm); }\n    } }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }\n\n    if (cm.options.readOnly == \"nocursor\") { return }\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) { return }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], wrapping = cm.options.lineWrapping;\n      var height = (void 0), width = 0;\n      if (cur.hidden) { continue }\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n        // Check that lines don't extend past the right of the current\n        // editor width\n        if (!wrapping && cur.text.firstChild)\n          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }\n      }\n      var diff = cur.line.height - height;\n      if (diff > .005 || diff < -.005) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n          { updateWidgetHeight(cur.rest[j]); } }\n      }\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\n      var w = line.widgets[i], parent = w.node.parentNode;\n      if (parent) { w.height = parent.offsetHeight; }\n    } }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)}\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (rect.top + box.top < 0) { doScroll = true; }\n    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) { margin = 0; }\n    var rect;\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n    }\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n      var coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      rect = {left: Math.min(coords.left, endCoords.left),\n              top: Math.min(coords.top, endCoords.top) - margin,\n              right: Math.max(coords.left, endCoords.left),\n              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n      }\n      if (!changed) { break }\n    }\n    return rect\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (rect.top < 0) { rect.top = 0; }\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n      if (newTop != screentop) { result.scrollTop = newTop; }\n    }\n\n    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n    var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n    var tooWide = rect.right - rect.left > screenw;\n    if (tooWide) { rect.right = rect.left + screenw; }\n    if (rect.left < 10)\n      { result.scrollLeft = 0; }\n    else if (rect.left < screenleft)\n      { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }\n    else if (rect.right > screenw + screenleft - 3)\n      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n    return result\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollTop(cm, top) {\n    if (top == null) { return }\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) { resolveScrollToPos(cm); }\n    if (x != null) { cm.curOp.scrollLeft = x; }\n    if (y != null) { cm.curOp.scrollTop = y; }\n  }\n\n  function scrollToRange(cm, range) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range;\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      scrollToCoordsRange(cm, from, to, range.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  }\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n    if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n    setScrollTop(cm, val, true);\n    if (gecko) { updateDisplaySimple(cm); }\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n  }\n\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    }\n  }\n\n  var NativeScrollbars = function(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      this.vert.firstChild.style.height =\n        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width =\n        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) { this.zeroWidthHack(); }\n      this.checkedZeroWidth = true;\n    }\n\n    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n    this.disableHoriz = new Delayed;\n    this.disableVert = new Delayed;\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.pointerEvents = \"auto\";\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n      if (elt != bar) { bar.style.pointerEvents = \"none\"; }\n      else { delay.set(1000, maybeDisable); }\n    }\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function () {};\n\n  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\n  NullScrollbars.prototype.setScrollLeft = function () {};\n  NullScrollbars.prototype.setScrollTop = function () {};\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) { measure = measureForScrollbars(cm); }\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        { updateHeightsInViewport(cm); }\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else { d.scrollbarFiller.style.display = \"\"; }\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else { d.gutterFiller.style.display = \"\"; }\n  }\n\n  var scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n      else { updateScrollTop(cm, pos); }\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: 0,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId,          // Unique ID\n      markArrays: null         // Used by addMarkedSpan\n    };\n    pushOperation(cm.curOp);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp;\n    if (op) { finishOperation(op, function (group) {\n      for (var i = 0; i < group.ops.length; i++)\n        { group.ops[i].cm.curOp = null; }\n      endOperations(group);\n    }); }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      { endOperation_R1(ops[i]); }\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n      { endOperation_W1(ops[i$1]); }\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n      { endOperation_R2(ops[i$2]); }\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n      { endOperation_W2(ops[i$3]); }\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n      { endOperation_finish(ops[i$4]); }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) { findMaxLine(cm); }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      { op.preparedSelection = display.input.prepareSelection(); }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt();\n    if (op.preparedSelection)\n      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      { updateScrollbars(cm, op.barMeasure); }\n    if (op.updatedDisplay)\n      { setDocumentHeight(cm, op.barMeasure); }\n\n    if (op.selectionChanged) { restartBlink(cm); }\n\n    if (cm.state.focused && op.updateInput)\n      { cm.display.input.reset(op.typing); }\n    if (takeFocus) { ensureFocus(op.cm); }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      { display.wheelStartX = display.wheelStartY = null; }\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) { for (var i = 0; i < hidden.length; ++i)\n      { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n    if (display.wrapper.offsetHeight)\n      { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      { signal(cm, \"changes\", cm, op.changeObjs); }\n    if (op.update)\n      { op.update.finish(); }\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) { return f() }\n    startOperation(cm);\n    try { return f() }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) { return f.apply(cm, arguments) }\n      startOperation(cm);\n      try { return f.apply(cm, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) { return f.apply(this, arguments) }\n      startOperation(this);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(this); }\n    }\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) { return f.apply(this, arguments) }\n      startOperation(cm);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo)\n      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.highlightFrontier >= cm.display.viewTo) { return }\n    var end = +new Date + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n        if (resetState) { context.state = resetState; }\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) { line.styleClasses = newCls; }\n        else if (oldCls) { line.styleClasses = null; }\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n        if (ischange) { changedLines.push(context.line); }\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          { processLine(cm, line.text, context); }\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n    if (changedLines.length) { runInOp(cm, function () {\n      for (var i = 0; i < changedLines.length; i++)\n        { regLineChange(cm, changedLines[i], \"text\"); }\n    }); }\n  }\n\n  // DISPLAY DRAWING\n\n  var DisplayUpdate = function(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type))\n      { this.events.push(arguments); }\n  };\n  DisplayUpdate.prototype.finish = function () {\n    for (var i = 0; i < this.events.length; i++)\n      { signal.apply(null, this.events[i]); }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) { return null }\n    var active = activeElt();\n    if (!active || !contains(cm.display.lineDiv, active)) { return null }\n    var result = {activeElt: active};\n    if (window.getSelection) {\n      var sel = window.getSelection();\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n    return result\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n    snapshot.activeElt.focus();\n    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&\n        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var sel = window.getSelection(), range = document.createRange();\n      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      { return false }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      { return false }\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var selSnapshot = selectionSnapshot(cm);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    restoreSelection(selSnapshot);\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          { break }\n      } else if (first) {\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n      }\n      if (!updateDisplayIfNeeded(cm, update)) { break }\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        { node.style.display = \"none\"; }\n      else\n        { node.parentNode.removeChild(node); }\n      return next\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) { cur = rm(cur); }\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) { cur = rm(cur); }\n  }\n\n  function updateGutterSpace(display) {\n    var width = display.gutters.offsetWidth;\n    display.sizer.style.marginLeft = width + \"px\";\n    // Send an event to consumers responding to changes in gutter width.\n    signalLater(display, \"gutterChanged\", display);\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n  }\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n      if (cm.options.fixedGutter) {\n        if (view[i].gutter)\n          { view[i].gutter.style.left = left; }\n        if (view[i].gutterBackground)\n          { view[i].gutterBackground.style.left = left; }\n      }\n      var align = view[i].alignable;\n      if (align) { for (var j = 0; j < align.length; j++)\n        { align[j].style.left = left; } }\n    } }\n    if (cm.options.fixedGutter)\n      { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) { return false }\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm.display);\n      return true\n    }\n    return false\n  }\n\n  function getGutters(gutters, lineNumbers) {\n    var result = [], sawLineNumbers = false;\n    for (var i = 0; i < gutters.length; i++) {\n      var name = gutters[i], style = null;\n      if (typeof name != \"string\") { style = name.style; name = name.className; }\n      if (name == \"CodeMirror-linenumbers\") {\n        if (!lineNumbers) { continue }\n        else { sawLineNumbers = true; }\n      }\n      result.push({className: name, style: style});\n    }\n    if (lineNumbers && !sawLineNumbers) { result.push({className: \"CodeMirror-linenumbers\", style: null}); }\n    return result\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function renderGutters(display) {\n    var gutters = display.gutters, specs = display.gutterSpecs;\n    removeChildren(gutters);\n    display.lineGutter = null;\n    for (var i = 0; i < specs.length; ++i) {\n      var ref = specs[i];\n      var className = ref.className;\n      var style = ref.style;\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + className));\n      if (style) { gElt.style.cssText = style; }\n      if (className == \"CodeMirror-linenumbers\") {\n        display.lineGutter = gElt;\n        gElt.style.width = (display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = specs.length ? \"\" : \"none\";\n    updateGutterSpace(display);\n  }\n\n  function updateGutters(cm) {\n    renderGutters(cm.display);\n    regChange(cm);\n    alignHorizontally(cm);\n  }\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input, options) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [lines], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n    if (place) {\n      if (place.appendChild) { place.appendChild(d.wrapper); }\n      else { place(d.wrapper); }\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n    renderGutters(d);\n\n    input.init(d);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) { wheelPixelsPerUnit = -.53; }\n  else if (gecko) { wheelPixelsPerUnit = 15; }\n  else if (chrome) { wheelPixelsPerUnit = -.7; }\n  else if (safari) { wheelPixelsPerUnit = -1/3; }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n    else if (dy == null) { dy = e.wheelDelta; }\n    return {x: dx, y: dy}\n  }\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta\n  }\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        { e_preventDefault(e); }\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) { return }\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) { return }\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  var Selection = function(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\n  Selection.prototype.equals = function (other) {\n    if (other == this) { return true }\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this.ranges[i], there = other.ranges[i];\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n    }\n    return true\n  };\n\n  Selection.prototype.deepCopy = function () {\n    var out = [];\n    for (var i = 0; i < this.ranges.length; i++)\n      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }\n    return new Selection(out, this.primIndex)\n  };\n\n  Selection.prototype.somethingSelected = function () {\n    for (var i = 0; i < this.ranges.length; i++)\n      { if (!this.ranges[i].empty()) { return true } }\n    return false\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n    if (!end) { end = pos; }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this.ranges[i];\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n        { return i }\n    }\n    return -1\n  };\n\n  var Range = function(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  };\n\n  Range.prototype.from = function () { return minPos(this.anchor, this.head) };\n  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };\n  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) { --primIndex; }\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex)\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0)\n  }\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  function changeEnd(change) {\n    if (!change.text) { return change.to }\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n  }\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) { return pos }\n    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n    return Pos(line, ch)\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex)\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n    else\n      { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex)\n  }\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) { line.stateAfter = null; }\n      if (line.styles) { line.styles = null; }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) { regChange(cm); }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      var result = [];\n      for (var i = start; i < end; ++i)\n        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }\n      return result\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) { doc.remove(from.line, nlines); }\n      if (added.length) { doc.insert(from.line, added); }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) { continue }\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) { continue }\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      } }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) { throw new Error(\"This document is already in use.\") }\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n    cm.options.direction = doc.direction;\n    if (!cm.options.lineWrapping) { findMaxLine(cm); }\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(prev) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = prev ? prev.undoDepth : Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n    return histChange\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) { array.pop(); }\n      else { break }\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done)\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done)\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done)\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n    var last;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        { pushSelectionToHistory(doc.sel, hist.done); }\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) { hist.done.shift(); }\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) { signal(doc, \"historyAdded\"); }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      { hist.done[hist.done.length - 1] = sel; }\n    else\n      { pushSelectionToHistory(sel, hist.done); }\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      { clearSelectionEvents(hist.undone); }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      { dest.push(sel); }\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans)\n        { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) { return null }\n    var out;\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n      else if (out) { out.push(spans[i]); }\n    }\n    return !out ? spans : out.length ? out : null\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) { return null }\n    var nw = [];\n    for (var i = 0; i < change.text.length; ++i)\n      { nw.push(removeClearedSpans(found[i])); }\n    return nw\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) { return stretched }\n    if (!stretched) { return old }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            { if (oldCur[k].marker == span.marker) { continue spans } }\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m = (void 0);\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        } } }\n      }\n    }\n    return copy\n  }\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head)\n    } else {\n      return new Range(other || head, head)\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    for (var i = 0; i < doc.sel.ranges.length; i++)\n      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head)); }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }\n    else { return sel }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      { sel = filterSelectionChange(doc, sel, options); }\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption(\"readOnly\") != \"nocursor\")\n      { ensureCursorVisible(doc.cm); }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) { return }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) { out = sel.ranges.slice(0, i); }\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n\n      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker\n      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it\n      // is with selectLeft/Right\n      var preventCursorLeft = (\"selectLeft\" in m) ? !m.selectLeft : m.inclusiveLeft;\n      var preventCursorRight = (\"selectRight\" in m) ? !m.selectRight : m.inclusiveRight;\n\n      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) { break }\n            else {--i; continue}\n          }\n        }\n        if (!m.atomic) { continue }\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n          if (dir < 0 ? preventCursorRight : preventCursorLeft)\n            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? preventCursorLeft : preventCursorRight)\n          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n      }\n    } }\n    return pos\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0)\n    }\n    return found\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n      else { return null }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n      else { return null }\n    } else {\n      return new Pos(pos.line, pos.ch + dir)\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  }\n\n  // UPDATING\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function () { return obj.canceled = true; }\n    };\n    if (update) { obj.update = function (from, to, text, origin) {\n      if (from) { obj.from = clipPos(doc, from); }\n      if (to) { obj.to = clipPos(doc, to); }\n      if (text) { obj.text = text; }\n      if (origin !== undefined) { obj.origin = origin; }\n    }; }\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n    if (obj.canceled) {\n      if (doc.cm) { doc.cm.curOp.updateInput = 2; }\n      return null\n    }\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n      if (doc.cm.state.suppressEdits) { return }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) { return }\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n    if (suppress && !allowSelectionOnly) { return }\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    var i = 0;\n    for (; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        { break }\n    }\n    if (i == source.length) { return }\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return\n        }\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return\n      } else { break }\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function ( i ) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {}\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop( i$1 );\n\n      if ( returned ) return returned.v;\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) { return }\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n      Pos(range.anchor.line + distance, range.anchor.ch),\n      Pos(range.head.line + distance, range.head.ch)\n    ); }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        { regLineChange(doc.cm, l, \"gutter\"); }\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return\n    }\n    if (change.from.line > doc.lastLine()) { return }\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n    else { updateDoc(doc, change, spans); }\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\n    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))\n      { doc.cantEdit = false; }\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      { signalCursorActivity(cm); }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      { regChange(cm); }\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      { regLineChange(cm, from.line, \"text\"); }\n    else\n      { regChange(cm, from.line, to.line + 1, lendiff); }\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) { to = from; }\n    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }\n    if (typeof code == \"string\") { code = doc.splitLines(code); }\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue\n      }\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n    else { no = lineNo(handle); }\n    if (no == null) { return null }\n    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n    return line\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length },\n\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }\n    },\n\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        { if (op(this.lines[at])) { return true } }\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size },\n\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }\n    },\n\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this.children.splice(++i, 0, leaf);\n              leaf.parent = this;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this.maybeSpill();\n          }\n          break\n        }\n        at -= sz;\n      }\n    },\n\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) { return }\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10)\n      me.parent.maybeSpill();\n    },\n\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) { return true }\n          if ((n -= used) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n    }\n  };\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function(doc, node, options) {\n    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n      { this[opt] = options[opt]; } } }\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) { return }\n    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }\n    if (!ws.length) { line.widgets = null; }\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n      var this$1 = this;\n\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) { return }\n    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      { addToScrollTop(cm, diff); }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) { widgets.push(widget); }\n      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) { addToScrollTop(cm, widget.height); }\n        cm.curOp.forceUpdate = true;\n      }\n      return true\n    });\n    if (cm) { signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle)); }\n    return widget\n  }\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  var TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) { startOperation(cm); }\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) { signalLater(this, \"clear\", found.from, found.to); }\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n      else if (cm) {\n        if (span.to != null) { max = lineNo(line); }\n        if (span.from != null) { min = lineNo(line); }\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        { updateLineHeight(line, textHeight(cm.display)); }\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    } }\n\n    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) { reCheckSelection(cm.doc); }\n    }\n    if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n    if (withOp) { endOperation(cm); }\n    if (this.parent) { this.parent.clear(); }\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function (side, lineObj) {\n    if (side == null && this.type == \"bookmark\") { side = 1; }\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) { return from }\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) { return to }\n      }\n    }\n    return from && {from: from, to: to}\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function () {\n      var this$1 = this;\n\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) { return }\n    runInOp(cm, function () {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          { updateLineHeight(line, line.height + dHeight); }\n      }\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n    }\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp\n      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n  eventMixin(TextMarker);\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) { copyObj(options, marker, false); }\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      { return marker }\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory)\n      { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        { updateMaxLine = true; }\n      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n    }); }\n\n    if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n      if (doc.history.done.length || doc.history.undone.length)\n        { doc.clearHistory(); }\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n      if (marker.collapsed)\n        { regChange(cm, from.line, to.line + 1); }\n      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||\n               marker.attributes || marker.title)\n        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n      if (marker.atomic) { reCheckSelection(cm.doc); }\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      { markers[i].parent = this; }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      { this.markers[i].clear(); }\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj)\n  };\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) { options.widgetNode = widget.cloneNode(true); }\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        { if (doc.linked[i].isParent) { return } }\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary)\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function ( i ) {\n      var marker = markers[i], linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) loop( i );\n  }\n\n  var nextDocId = 0;\n  var Doc = function(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n    if (firstLine == null) { firstLine = 0; }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") { text = this.splitLines(text); }\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) { this.iterN(from - this.first, to - from, op); }\n      else { this.iterN(this.first, this.first + this.size, from); }\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) { return lines }\n      if (lineSep === '') { return lines.join('') }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n    getLineNumber: function(line) {return lineNo(line)},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") { line = getLine(this, line); }\n      return visualLine(line)\n    },\n\n    lineCount: function() {return this.size},\n    firstLine: function() {return this.first},\n    lastLine: function() {return this.first + this.size - 1},\n\n    clipPos: function(pos) {return clipPos(this, pos)},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") { pos = range.head; }\n      else if (start == \"anchor\") { pos = range.anchor; }\n      else if (start == \"end\" || start == \"to\" || start === false) { pos = range.to(); }\n      else { pos = range.from(); }\n      return pos\n    },\n    listSelections: function() { return this.sel.ranges },\n    somethingSelected: function() {return this.sel.somethingSelected()},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) { return }\n      var out = [];\n      for (var i = 0; i < ranges.length; i++)\n        { out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head || ranges[i].anchor)); }\n      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) { return lines }\n      else { return lines.join(lineSep || this.lineSeparator()) }\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }\n        parts[i] = sel;\n      }\n      return parts\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        { dup[i] = code; }\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n        { makeChange(this, changes[i$1]); }\n      if (newSel) { setSelectionReplaceHistory(this, newSel); }\n      else if (this.cm) { ensureCursorVisible(this.cm); }\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n      return {undo: done, redo: undone}\n    },\n    clearHistory: function() {\n      var this$1 = this;\n\n      this.history = new History(this.history);\n      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);\n    },\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n      return this.history.generation\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration)\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)}\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    setGutterMarker: docMethodOp(function(line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n        return true\n      })\n    }),\n\n    clearGutter: docMethodOp(function(gutterID) {\n      var this$1 = this;\n\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n            return true\n          });\n        }\n      });\n    }),\n\n    lineInfo: function(line) {\n      var n;\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) { return null }\n        n = line;\n        line = getLine(this, line);\n        if (!line) { return null }\n      } else {\n        n = lineNo(line);\n        if (n == null) { return null }\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets}\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) { line[prop] = cls; }\n        else if (classTest(cls).test(line[prop])) { return false }\n        else { line[prop] += \" \" + cls; }\n        return true\n      })\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) { return false }\n        else if (cls == null) { line[prop] = null; }\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) { return false }\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true\n      })\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options)\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\")\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          { markers.push(span.marker.parent || span.marker); }\n      } }\n      return markers\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n        if (spans) { for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\n                span.from == null && lineNo != from.line ||\n                span.from != null && lineNo == to.line && span.from >= to.ch) &&\n              (!filter || filter(span.marker)))\n            { found.push(span.marker.parent || span.marker); }\n        } }\n        ++lineNo;\n      });\n      return found\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n        if (sps) { for (var i = 0; i < sps.length; ++i)\n          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n      });\n      return markers\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n        if (sz > off) { ch = off; return true }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch))\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) { return 0 }\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc\n    },\n\n    linkedDoc: function(options) {\n      if (!options) { options = {}; }\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) { from = options.from; }\n      if (options.to != null && options.to < to) { to = options.to; }\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n      if (options.sharedHist) { copy.history = this.history\n      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) { other = other.doc; }\n      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) { continue }\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break\n      } }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode},\n    getEditor: function() {return this.cm},\n\n    splitLines: function(str) {\n      if (this.lineSep) { return str.split(this.lineSep) }\n      return splitLinesAuto(str)\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") { dir = \"ltr\"; }\n      if (dir == this.direction) { return }\n      this.direction = dir;\n      this.iter(function (line) { return line.order = null; });\n      if (this.cm) { directionChanged(this.cm); }\n    })\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      { return }\n    e_preventDefault(e);\n    if (ie) { lastDrop = +new Date; }\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) { return }\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var markAsReadAndPasteIfAllFilesAreRead = function () {\n        if (++read == n) {\n          operation(cm, function () {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(\n                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));\n          })();\n        }\n      };\n      var readTextFromFile = function (file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n          markAsReadAndPasteIfAllFilesAreRead();\n          return\n        }\n        var reader = new FileReader;\n        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };\n        reader.onload = function () {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n            markAsReadAndPasteIfAllFilesAreRead();\n            return\n          }\n          text[i] = content;\n          markAsReadAndPasteIfAllFilesAreRead();\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function () { return cm.display.input.focus(); }, 20);\n        return\n      }\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n        if (text$1) {\n          var selected;\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\n            { selected = cm.listSelections(); }\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n            { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e$1){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\";\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) { img.parentNode.removeChild(img); }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) { return }\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) { return }\n    var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) { editors.push(cm); }\n    }\n    if (editors.length) { editors[0].operation(function () {\n      for (var i = 0; i < editors.length; i++) { f(editors[i]); }\n    }); }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) { return }\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100); }\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n  }\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 145: \"ScrollLock\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 224: \"Mod\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n\n  // Number keys\n  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n  // Alphabetic keys\n  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n  // Function keys\n  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\n  var keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\", \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\",\n    \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\",\n    \"Ctrl-T\": \"transposeChars\", \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n      else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n      else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n      else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n    }\n    if (alt) { name = \"Alt-\" + name; }\n    if (ctrl) { name = \"Ctrl-\" + name; }\n    if (cmd) { name = \"Cmd-\" + name; }\n    if (shift) { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n      if (value == \"...\") { delete keymap[keyname]; continue }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val = (void 0), name = (void 0);\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) { copy[name] = val; }\n        else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n      }\n      delete keymap[keyname];\n    } }\n    for (var prop in copy) { keymap[prop] = copy[prop]; }\n    return keymap\n  }\n\n  function lookupKey(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n    if (found === false) { return \"nothing\" }\n    if (found === \"...\") { return \"multi\" }\n    if (found != null && handle(found)) { return \"handled\" }\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n        { return lookupKey(key, map.fallthrough, handle, context) }\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n        if (result) { return result }\n      }\n    }\n  }\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n    if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Mod\") { name = \"Cmd-\" + name; }\n    if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // Look up the name of a key as indicated by an event object.\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) { return false }\n    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n    if (event.keyCode == 3 && event.code) { name = event.code; }\n    return addModifierNames(name, event, noShift)\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      if (cm.doc.direction == \"rtl\") { dir = -dir; }\n      var order = getOrder(lineObj, cm.doc.direction);\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = (dir < 0) == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch;\n        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n        if (part.level > 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n          if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n        } else { ch = dir < 0 ? part.to : part.from; }\n        return new Pos(lineNo, ch, sticky)\n      }\n    }\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n    if (!bidi) { return moveLogically(line, start, dir) }\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n    if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir)\n    }\n\n    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n    var prep;\n    var getWrappedLineExtent = function (ch) {\n      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch)\n    };\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = (part.level == 1) == (dir < 0);\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky)\n      }\n    }\n\n    // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n        ? new Pos(start.line, mv(ch, 1), \"before\")\n        : new Pos(start.line, ch, \"after\"); };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = (dir > 0) == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n      }\n    };\n\n    // Case 3a: Look for other bidi parts on the same visual line\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n    if (res) { return res }\n\n    // Case 3b: Look for other bidi parts on the next visual line\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n      if (res) { return res }\n    }\n\n    // Case 4: Nowhere to move\n    return null\n  }\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n    killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n      if (range.empty()) {\n        var len = getLine(cm.doc, range.head.line).text.length;\n        if (range.head.ch == len && range.head.line < cm.lastLine())\n          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n        else\n          { return {from: range.head, to: Pos(range.head.line, len)} }\n      } else {\n        return {from: range.from(), to: range.to()}\n      }\n    }); },\n    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0),\n      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n    }); }); },\n    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0), to: range.from()\n    }); }); },\n    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n      return {from: leftPos, to: range.from()}\n    }); },\n    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      return {from: range.from(), to: rightPos }\n    }); },\n    undo: function (cm) { return cm.undo(); },\n    redo: function (cm) { return cm.redo(); },\n    undoSelection: function (cm) { return cm.undoSelection(); },\n    redoSelection: function (cm) { return cm.redoSelection(); },\n    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n      {origin: \"+move\", bias: -1}\n    ); },\n    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: 0, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n      if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n      return pos\n    }, sel_move); },\n    goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n    goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n    goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n    goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n    goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n    goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n    goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n    goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n    goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n    goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n    goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n    goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n    delCharBefore: function (cm) { return cm.deleteH(-1, \"codepoint\"); },\n    delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n    delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n    delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n    delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n    delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n    indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n    indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n    indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n    insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n    insertSoftTab: function (cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function (cm) {\n      if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n      else { cm.execCommand(\"insertTab\"); }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function (cm) { return runInOp(cm, function () {\n      var ranges = cm.listSelections(), newSel = [];\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty()) { continue }\n        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n        if (line) {\n          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n          if (cur.ch > 0) {\n            cur = new Pos(cur.line, cur.ch + 1);\n            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                            Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n          } else if (cur.line > cm.doc.first) {\n            var prev = getLine(cm.doc, cur.line - 1).text;\n            if (prev) {\n              cur = new Pos(cur.line, 1);\n              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                              prev.charAt(prev.length - 1),\n                              Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n            }\n          }\n        }\n        newSel.push(new Range(cur, cur));\n      }\n      cm.setSelections(newSel);\n    }); },\n    newlineAndIndent: function (cm) { return runInOp(cm, function () {\n      var sels = cm.listSelections();\n      for (var i = sels.length - 1; i >= 0; i--)\n        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n      sels = cm.listSelections();\n      for (var i$1 = 0; i$1 < sels.length; i$1++)\n        { cm.indentLine(sels[i$1].from().line, null, true); }\n      ensureCursorVisible(cm);\n    }); },\n    openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n  };\n\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, visual, lineN, 1)\n  }\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, line, lineN, -1)\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n    }\n    return start\n  }\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) { return false }\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      if (dropShift) { cm.display.shift = false; }\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) { return result }\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm)\n  }\n\n  // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n  var stopSeq = new Delayed;\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) { return \"handled\" }\n      if (/\\'$/.test(name))\n        { cm.state.keySeq = null; }\n      else\n        { stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        }); }\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\n    }\n    return dispatchKeyInner(cm, name, e, handle)\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      { cm.state.keySeq = name; }\n    if (result == \"handled\")\n      { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) { return false }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n          || dispatchKey(cm, name, e, function (b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 { return doHandleBinding(cm, b) }\n             })\n    } else {\n      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) { return }\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        { cm.replaceSelection(\"\", null, \"cut\"); }\n    }\n    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)\n      { document.execCommand(\"cut\"); }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      { showCrossHair(cm); }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) { this.doc.sel.shift = false; }\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    // Some browsers fire keypress events for backspace\n    if (ch == \"\\x08\") { return }\n    if (handleCharBinding(cm, e, ch)) { return }\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time &&\n      cmp(pos, this.pos) == 0 && button == this.button\n  };\n\n  var lastClick, lastDoubleClick;\n  function clickRepeat(pos, button) {\n    var now = +new Date;\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\"\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\"\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\"\n    }\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () { return display.scroller.draggable = true; }, 100);\n      }\n      return\n    }\n    if (clickInGutter(cm, e)) { return }\n    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n    window.focus();\n\n    // #3261: make sure, that we're not starting a second selection\n    if (button == 1 && cm.state.selectingText)\n      { cm.state.selectingText(e); }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n    if (button == 1) {\n      if (pos) { leftButtonDown(cm, pos, repeat, e); }\n      else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n    } else if (button == 2) {\n      if (pos) { extendSelection(cm.doc, pos); }\n      setTimeout(function () { return display.input.focus(); }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) { cm.display.input.onContextMenu(e); }\n      else { delayBlurEvent(cm); }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n    if (repeat == \"double\") { name = \"Double\" + name; }\n    else if (repeat == \"triple\") { name = \"Triple\" + name; }\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") { bound = commands[bound]; }\n      if (!bound) { return false }\n      var done = false;\n      try {\n        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n      return done\n    })\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n    return value\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n    else { cm.curOp.focus = activeElt(); }\n\n    var behavior = configureMouse(cm, repeat, event);\n\n    var sel = cm.doc.sel, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n      { leftButtonStartDrag(cm, event, pos, behavior); }\n    else\n      { leftButtonSelect(cm, event, pos, behavior); }\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display, moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) { display.scroller.draggable = false; }\n      cm.state.draggingText = false;\n      if (cm.state.delayingBlurEvent) {\n        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }\n        else { delayBlurEvent(cm); }\n      }\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n      if (!moved) {\n        e_preventDefault(e);\n        if (!behavior.addNew)\n          { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if ((webkit && !safari) || ie && ie_version == 9)\n          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }\n        else\n          { display.input.focus(); }\n      }\n    });\n    var mouseMove = function(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n    var dragStart = function () { return moved = true; };\n    // Let the drag handler handle this.\n    if (webkit) { display.scroller.draggable = true; }\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { return display.input.focus(); }, 20);\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") { return new Range(pos, pos) }\n    if (unit == \"word\") { return cm.findWordAt(pos) }\n    if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to)\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, event, start, behavior) {\n    if (ie) { delayBlurEvent(cm); }\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(event);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        { ourRange = ranges[ourIndex]; }\n      else\n        { ourRange = new Range(start, start); }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) { ourRange = new Range(start, start); }\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range = rangeForUnit(cm, start, behavior.unit);\n      if (behavior.extend)\n        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }\n      else\n        { ourRange = range; }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) { return }\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n          else if (text.length > leftPos)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n        }\n        if (!ranges.length) { ranges.push(new Range(start, start)); }\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor, head;\n        if (cmp(range.anchor, anchor) > 0) {\n          head = range.head;\n          anchor = minPos(oldRange.from(), range.anchor);\n        } else {\n          head = range.anchor;\n          anchor = maxPos(oldRange.to(), range.head);\n        }\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n      if (!cur) { return }\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) { setTimeout(operation(cm, function () {\n          if (counter != curCount) { return }\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50); }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      // If e is null or undefined we interpret this as someone trying\n      // to explicitly cancel the selection rather than the user\n      // letting go of the mouse button.\n      if (e) {\n        e_preventDefault(e);\n        display.input.focus();\n      }\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) { done(e); }\n      else { extend(e); }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  }\n\n  // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n  function bidiSimplify(cm, range) {\n    var anchor = range.anchor;\n    var head = range.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }\n    var order = getOrder(anchorLine);\n    if (!order) { return range }\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n    if (part.from != anchor.ch && part.to != anchor.ch) { return range }\n    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n    if (boundary == 0 || boundary == order.length) { return range }\n\n    // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n    var leftSide;\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n      if (headIndex == boundary - 1 || headIndex == boundary)\n        { leftSide = dir < 0; }\n      else\n        { leftSide = dir > 0; }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)\n  }\n\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try { mX = e.clientX; mY = e.clientY; }\n      catch(e$1) { return false }\n    }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n    if (prevent) { e_preventDefault(e); }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.display.gutterSpecs[i];\n        signal(cm, type, cm, line, gutter.className, e);\n        return e_defaultPrevented(e)\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true)\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n    if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n    if (!captureRightClick) { cm.display.input.onContextMenu(e); }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n    return gutterEvent(cm, e, \"gutterContextMenu\", false)\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {toString: function(){return \"CodeMirror.Init\"}};\n\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n      if (handle) { optionHandlers[name] =\n        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n    }\n\n    CodeMirror.defineOption = option;\n\n    // Passed to option handlers when there is no old value.\n    CodeMirror.Init = Init;\n\n    // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n    option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n      if (!val) { return }\n      var newBreaks = [], lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n          if (found == -1) { break }\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n        lineNo++;\n      });\n      for (var i = newBreaks.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n      if (old != Init) { cm.refresh(); }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n    option(\"autocorrect\", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);\n    option(\"autocapitalize\", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      updateGutters(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n      if (prev && prev.detach) { prev.detach(cm, next); }\n      if (next.attach) { next.attach(cm, prev || null); }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm, val) {\n      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n      updateGutters(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm, val) {\n      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n      updateGutters(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, updateGutters, true);\n    option(\"lineNumberFormatter\", function (integer) { return integer; }, updateGutters, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n      cm.display.input.readOnlyChanged(val);\n    });\n\n    option(\"screenReaderLabel\", null, function (cm, val) {\n      val = (val === '') ? null : val;\n      cm.display.input.screenReaderLabelChanged(val);\n    });\n\n    option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) { cm.display.input.resetPosition(); }\n    });\n\n    option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n    option(\"phrases\", null);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () { return updateScrollbars(cm); }, 100);\n  }\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n    else if (options.mode) { doc.modeOption = options.mode; }\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input, options);\n    display.wrapper.CodeMirror = this;\n    themeChanged(this);\n    if (options.lineWrapping)\n      { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) { display.input.focus(); }\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || this.hasFocus())\n      { setTimeout(function () {\n        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }\n      }, 20); }\n    else\n      { onBlur(this); }\n\n    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n      { optionHandlers[opt](this, options[opt], Init); } }\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) { options.finishInit(this); }\n    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      { display.lineDiv.style.textRendering = \"auto\"; }\n  }\n\n  // The default configuration options.\n  CodeMirror.defaults = defaults;\n  // Functions to run when options are changed.\n  CodeMirror.optionHandlers = optionHandlers;\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) { return }\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      })); }\n    else\n      { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); });\n    on(d.input.getField(), \"contextmenu\", function (e) {\n      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }\n    });\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    }\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) { return false }\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1\n    }\n    function farAway(touch, other) {\n      if (other.left == null) { return true }\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20\n    }\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) { d.activeTouch.moved = true; }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          { range = new Range(pos, pos); }\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          { range = cm.findWordAt(pos); }\n        else // Triple tap\n          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n    on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function (e) { return onDragStart(cm, e); },\n      drop: operation(cm, onDrop),\n      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n    on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n  }\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) { how = \"add\"; }\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) { how = \"prev\"; }\n      else { state = getContextBefore(cm, n).state; }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) { line.stateAfter = null; }\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) { return }\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n      else { indentation = 0; }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n    if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break\n        }\n      }\n    }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) { sel = doc.sel; }\n\n    var recent = +new Date - 200;\n    var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n    var textLines = splitLinesAuto(inserted), multiPaste = null;\n    // When pasting N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.text.length; i++)\n            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) { return [l]; });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput;\n    // Normal behavior is to insert the new text into every selection\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range = sel.ranges[i$1];\n      var from = range.from(), to = range.to();\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          { from = Pos(from.line, from.ch - deleted); }\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == textLines.join(\"\\n\"))\n          { from = to = Pos(from.line, 0); }\n      }\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      { triggerElectric(cm, inserted); }\n\n    ensureCursorVisible(cm);\n    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput)\n        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n      return true\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break\n          } }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n          { indented = indentLine(cm, range.head.line, \"smart\"); }\n      }\n      if (indented) { signalLater(cm, \"electricInput\", cm, range.head.line); }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges}\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute(\"autocorrect\", autocorrect ? \"\" : \"off\");\n    field.setAttribute(\"autocapitalize\", autocapitalize ? \"\" : \"off\");\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) { te.style.width = \"1000px\"; }\n    else { te.setAttribute(\"wrap\", \"off\"); }\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) { te.style.border = \"1px solid black\"; }\n    disableBrowserMagic(te);\n    return div\n  }\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    var helpers = CodeMirror.helpers = {};\n\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function(){window.focus(); this.display.input.focus();},\n\n      setOption: function(option, value) {\n        var options = this.options, old = options[option];\n        if (options[option] == value && option != \"mode\") { return }\n        options[option] = value;\n        if (optionHandlers.hasOwnProperty(option))\n          { operation(this, optionHandlers[option])(this, value, old); }\n        signal(this, \"optionChange\", this, option);\n      },\n\n      getOption: function(option) {return this.options[option]},\n      getDoc: function() {return this.doc},\n\n      addKeyMap: function(map, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n      },\n      removeKeyMap: function(map) {\n        var maps = this.state.keyMaps;\n        for (var i = 0; i < maps.length; ++i)\n          { if (maps[i] == map || maps[i].name == map) {\n            maps.splice(i, 1);\n            return true\n          } }\n      },\n\n      addOverlay: methodOp(function(spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n        if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n        insertSorted(this.state.overlays,\n                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                      priority: (options && options.priority) || 0},\n                     function (overlay) { return overlay.priority; });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function(spec) {\n        var overlays = this.state.overlays;\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n          if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this.state.modeGen++;\n            regChange(this);\n            return\n          }\n        }\n      }),\n\n      indentLine: methodOp(function(n, dir, aggressive) {\n        if (typeof dir != \"string\" && typeof dir != \"number\") {\n          if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n          else { dir = dir ? \"add\" : \"subtract\"; }\n        }\n        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n      }),\n      indentSelection: methodOp(function(how) {\n        var ranges = this.doc.sel.ranges, end = -1;\n        for (var i = 0; i < ranges.length; i++) {\n          var range = ranges[i];\n          if (!range.empty()) {\n            var from = range.from(), to = range.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n            for (var j = start; j < end; ++j)\n              { indentLine(this, j, how); }\n            var newRanges = this.doc.sel.ranges;\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n          } else if (range.head.line > end) {\n            indentLine(this, range.head.line, how, true);\n            end = range.head.line;\n            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }\n          }\n        }\n      }),\n\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function(pos, precise) {\n        return takeToken(this, pos, precise)\n      },\n\n      getLineTokens: function(line, precise) {\n        return takeToken(this, Pos(line), precise, true)\n      },\n\n      getTokenTypeAt: function(pos) {\n        pos = clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n        var type;\n        if (ch == 0) { type = styles[2]; }\n        else { for (;;) {\n          var mid = (before + after) >> 1;\n          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n          else { type = styles[mid * 2 + 2]; break }\n        } }\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n      },\n\n      getModeAt: function(pos) {\n        var mode = this.doc.mode;\n        if (!mode.innerMode) { return mode }\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n      },\n\n      getHelper: function(pos, type) {\n        return this.getHelpers(pos, type)[0]\n      },\n\n      getHelpers: function(pos, type) {\n        var found = [];\n        if (!helpers.hasOwnProperty(type)) { return found }\n        var help = helpers[type], mode = this.getModeAt(pos);\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) { found.push(help[mode[type]]); }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n            if (val) { found.push(val); }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n            { found.push(cur.val); }\n        }\n        return found\n      },\n\n      getStateAfter: function(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n        return getContextBefore(this, line + 1, precise).state\n      },\n\n      cursorCoords: function(start, mode) {\n        var pos, range = this.doc.sel.primary();\n        if (start == null) { pos = range.head; }\n        else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n        else { pos = start ? range.from() : range.to(); }\n        return cursorCoords(this, pos, mode || \"page\")\n      },\n\n      charCoords: function(pos, mode) {\n        return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n      },\n\n      coordsChar: function(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return coordsChar(this, coords.left, coords.top)\n      },\n\n      lineAtHeight: function(height, mode) {\n        height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n        return lineAtHeight(this.doc, height + this.display.viewOffset)\n      },\n      heightAtLine: function(line, mode, includeWidgets) {\n        var end = false, lineObj;\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n          if (line < this.doc.first) { line = this.doc.first; }\n          else if (line > last) { line = last; end = true; }\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n          (end ? this.doc.height - heightAtLine(lineObj) : 0)\n      },\n\n      defaultTextHeight: function() { return textHeight(this.display) },\n      defaultCharWidth: function() { return charWidth(this.display) },\n\n      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = cursorCoords(this, clipPos(this.doc, pos));\n        var top = pos.bottom, left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n          // Default to positioning above (if specified and possible); otherwise default to positioning below\n          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n            { top = pos.top - node.offsetHeight; }\n          else if (pos.bottom + node.offsetHeight <= vspace)\n            { top = pos.bottom; }\n          if (left + node.offsetWidth > hspace)\n            { left = hspace - node.offsetWidth; }\n        }\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") { left = 0; }\n          else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n          node.style.left = left + \"px\";\n        }\n        if (scroll)\n          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n      },\n\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n\n      execCommand: function(cmd) {\n        if (commands.hasOwnProperty(cmd))\n          { return commands[cmd].call(null, this) }\n      },\n\n      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n      findPosH: function(from, amount, unit, visually) {\n        var dir = 1;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          cur = findPosH(this.doc, cur, dir, unit, visually);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveH: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        this.extendSelectionsBy(function (range) {\n          if (this$1.display.shift || this$1.doc.extend || range.empty())\n            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }\n          else\n            { return dir < 0 ? range.from() : range.to() }\n        }, sel_move);\n      }),\n\n      deleteH: methodOp(function(dir, unit) {\n        var sel = this.doc.sel, doc = this.doc;\n        if (sel.somethingSelected())\n          { doc.replaceSelection(\"\", null, \"+delete\"); }\n        else\n          { deleteNearSelection(this, function (range) {\n            var other = findPosH(doc, range.head, dir, unit, false);\n            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}\n          }); }\n      }),\n\n      findPosV: function(from, amount, unit, goalColumn) {\n        var dir = 1, x = goalColumn;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          var coords = cursorCoords(this, cur, \"div\");\n          if (x == null) { x = coords.left; }\n          else { coords.left = x; }\n          cur = findPosV(this, coords, dir, unit);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveV: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        var doc = this.doc, goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range) {\n          if (collapse)\n            { return dir < 0 ? range.from() : range.to() }\n          var headPos = cursorCoords(this$1, range.head, \"div\");\n          if (range.goalColumn != null) { headPos.left = range.goalColumn; }\n          goals.push(headPos.left);\n          var pos = findPosV(this$1, headPos, dir, unit);\n          if (unit == \"page\" && range == doc.sel.primary())\n            { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n          return pos\n        }, sel_move);\n        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n          { doc.sel.ranges[i].goalColumn = goals[i]; } }\n      }),\n\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function(pos) {\n        var doc = this.doc, line = getLine(doc, pos.line).text;\n        var start = pos.ch, end = pos.ch;\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n          if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper)\n            ? function (ch) { return isWordChar(ch, helper); }\n            : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n            : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n          while (start > 0 && check(line.charAt(start - 1))) { --start; }\n          while (end < line.length && check(line.charAt(end))) { ++end; }\n        }\n        return new Range(Pos(pos.line, start), Pos(pos.line, end))\n      },\n\n      toggleOverwrite: function(value) {\n        if (value != null && value == this.state.overwrite) { return }\n        if (this.state.overwrite = !this.state.overwrite)\n          { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n        else\n          { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function() { return this.display.input.getField() == activeElt() },\n      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n      getScrollInfo: function() {\n        var scroller = this.display.scroller;\n        return {left: scroller.scrollLeft, top: scroller.scrollTop,\n                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n      },\n\n      scrollIntoView: methodOp(function(range, margin) {\n        if (range == null) {\n          range = {from: this.doc.sel.primary().head, to: null};\n          if (margin == null) { margin = this.options.cursorScrollMargin; }\n        } else if (typeof range == \"number\") {\n          range = {from: Pos(range, 0), to: null};\n        } else if (range.from == null) {\n          range = {from: range, to: null};\n        }\n        if (!range.to) { range.to = range.from; }\n        range.margin = margin || 0;\n\n        if (range.from.line != null) {\n          scrollToRange(this, range);\n        } else {\n          scrollToCoordsRange(this, range.from, range.to, range.margin);\n        }\n      }),\n\n      setSize: methodOp(function(width, height) {\n        var this$1 = this;\n\n        var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n        if (width != null) { this.display.wrapper.style.width = interpret(width); }\n        if (height != null) { this.display.wrapper.style.height = interpret(height); }\n        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n        var lineNo = this.display.viewFrom;\n        this.doc.iter(lineNo, this.display.viewTo, function (line) {\n          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, \"widget\"); break } } }\n          ++lineNo;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n\n      operation: function(f){return runInOp(this, f)},\n      startOperation: function(){return startOperation(this)},\n      endOperation: function(){return endOperation(this)},\n\n      refresh: methodOp(function() {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this.display);\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)\n          { estimateLineHeights(this); }\n        signal(this, \"refresh\", this);\n      }),\n\n      swapDoc: methodOp(function(doc) {\n        var old = this.doc;\n        old.cm = null;\n        // Cancel the current text selection if any (#5821)\n        if (this.state.selectingText) { this.state.selectingText(); }\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old\n      }),\n\n      phrase: function(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText\n      },\n\n      getInputField: function(){return this.display.input.getField()},\n      getWrapperElement: function(){return this.display.wrapper},\n      getScrollerElement: function(){return this.display.scroller},\n      getGutterElement: function(){return this.display.gutters}\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function(type, name, value) {\n      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n      helpers[type][name] = value;\n    };\n    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n      helpers[type]._global.push({pred: predicate, val: value});\n    };\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"codepoint\", \"char\", \"column\" (like char, but\n  // doesn't cross line boundaries), \"word\" (across next word), or\n  // \"group\" (to the start of next group of word or\n  // non-word-non-whitespace chars). The visually param controls\n  // whether, in right-to-left text, direction 1 means to move towards\n  // the next index in the string, or towards the character to the right\n  // of the current position. The resulting position will have a\n  // hitSide=true property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    var lineDir = visually && doc.direction == \"rtl\" ? -dir : dir;\n    function findNextLine() {\n      var l = pos.line + lineDir;\n      if (l < doc.first || l >= doc.first + doc.size) { return false }\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l)\n    }\n    function moveOnce(boundToLine) {\n      var next;\n      if (unit == \"codepoint\") {\n        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));\n        if (isNaN(ch)) {\n          next = null;\n        } else {\n          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;\n          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);\n        }\n      } else if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n      if (next == null) {\n        if (!boundToLine && findNextLine())\n          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }\n        else\n          { return false }\n      } else {\n        pos = next;\n      }\n      return true\n    }\n\n    if (unit == \"char\" || unit == \"codepoint\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) { break }\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) { type = \"s\"; }\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n          break\n        }\n\n        if (type) { sawType = type; }\n        if (dir > 0 && !moveOnce(!first)) { break }\n      }\n    }\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n    return result\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    var target;\n    for (;;) {\n      target = coordsChar(cm, x, y);\n      if (!target.outside) { break }\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n      y += dir * 5;\n    }\n    return target\n  }\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  var ContentEditableInput = function(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = input.cm;\n    var div = input.div = display.lineDiv;\n    div.contentEditable = true;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n\n    function belongsToInput(e) {\n      for (var t = e.target; t; t = t.parentNode) {\n        if (t == div) { return true }\n        if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) { break }\n      }\n      return false\n    }\n\n    on(div, \"paste\", function (e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n      // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n    });\n\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {data: e.data, done: false};\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n        this$1.composing.done = true;\n      }\n    });\n\n    on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n    on(div, \"input\", function () {\n      if (!this$1.composing) { this$1.readFromDOMSoon(); }\n    });\n\n    function onCopyCut(e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n        if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\");\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        e.clipboardData.setData(\"Text\", content);\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return\n        }\n      }\n      // Old-fashioned briefly-focus-a-textarea hack\n      var kludge = hiddenTextarea(), te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = activeElt();\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n        if (hadFocus == div) { input.showPrimarySelection(); }\n      }, 50);\n    }\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.div.setAttribute('aria-label', label);\n    } else {\n      this.div.removeAttribute('aria-label');\n    }\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = activeElt() == this.div;\n    return result\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) { return }\n    if (info.focus || takeFocus) { this.showPrimarySelection(); }\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection()\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n    var from = prim.from(), to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n        cmp(minPos(curAnchor, curFocus), from) == 0 &&\n        cmp(maxPos(curAnchor, curFocus), to) == 0)\n      { return }\n\n    var view = cm.display.view;\n    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n        {node: view[0].measure.map[2], offset: 0};\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0), rng;\n    try { rng = range(start.node, start.offset, end.offset, end.node); }\n    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n      if (old && sel.anchorNode == null) { sel.addRange(old); }\n      else if (gecko) { this.startGracePeriod(); }\n    }\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n      var this$1 = this;\n\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n      if (this$1.selectionChanged())\n        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n    if (!sel.rangeCount) { return false }\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node)\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor() || activeElt() != this.div)\n        { this.showSelection(this.prepareSelection(), true); }\n      this.div.focus();\n    }\n  };\n  ContentEditableInput.prototype.blur = function () { this.div.blur(); };\n  ContentEditableInput.prototype.getField = function () { return this.div };\n\n  ContentEditableInput.prototype.supportsTouch = function () { return true };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n    var input = this;\n    if (this.selectionInEditor())\n      { this.pollSelection(); }\n    else\n      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n    var sel = this.getSelection(), cm = this.cm;\n    // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n      this.blur();\n      this.focus();\n      return\n    }\n    if (this.composing) { return }\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (anchor && head) { runInOp(cm, function () {\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n    }); }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n    var from = sel.from(), to = sel.to();\n    if (from.ch == 0 && from.line > cm.firstLine())\n      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n      { to = Pos(to.line + 1, 0); }\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n    var fromIndex, fromLine, fromNode;\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) { return false }\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n      else { break }\n    }\n\n    var cutFront = 0, cutEnd = 0;\n    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n      { ++cutFront; }\n    var newBot = lst(newText), oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                             oldBot.length - (oldText.length == 1 ? cutFront : 0));\n    while (cutEnd < maxCutEnd &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n      { ++cutEnd; }\n    // Try to move start of change to start of selection if ambiguous\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n      return true\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) { return }\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n      var this$1 = this;\n\n    if (this.readDOMTimeout != null) { return }\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n      if (this$1.composing) {\n        if (this$1.composing.done) { this$1.composing = null; }\n        else { return }\n      }\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n      var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent())\n      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) { return }\n    e.preventDefault();\n    if (!this.cm.isReadOnly())\n      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) { return null }\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line, cm.doc.direction), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode)\n      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n    return false\n  }\n\n  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n    function close() {\n      if (closing) {\n        text += lineSep;\n        if (extraLinebreak) { text += lineSep; }\n        closing = extraLinebreak = false;\n      }\n    }\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText) {\n          addText(cmText);\n          return\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range = found[0].find(0)))\n            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }\n          return\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }\n\n        if (isBlock) { close(); }\n        for (var i = 0; i < node.childNodes.length; i++)\n          { walk(node.childNodes[i]); }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }\n        if (isBlock) { closing = true; }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) { break }\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n    return text\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        { return locateNodeInLineView(lineView, node, offset) }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad)\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) { offset = textNode.nodeValue.length; }\n    }\n    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }\n            return Pos(line, ch)\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) { return badPos(found, bad) }\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        { return badPos(Pos(found.line, found.ch - dist), bad) }\n      else\n        { dist += after.textContent.length; }\n    }\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n      else\n        { dist$1 += before.textContent.length; }\n    }\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  var TextareaInput = function(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n    if (ios) { te.style.width = \"0px\"; }\n\n    on(te, \"input\", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n      input.poll();\n    });\n\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n      cm.state.pasteIncoming = +new Date;\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n      if (e.type == \"cut\") { cm.state.cutIncoming = +new Date; }\n    }\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date;\n        input.focus();\n        return\n      }\n\n      // Pass the `paste` event to the textarea so it's handled by its event listener.\n      var event = new Event(\"paste\");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    });\n\n    // Prevent normal selection in the editor (we handle our own)\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) { e_preventDefault(e); }\n    });\n\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n      if (input.composing) { input.composing.range.clear(); }\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea();\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.textarea.setAttribute('aria-label', label);\n    } else {\n      this.textarea.removeAttribute('aria-label');\n    }\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm, display = cm.display, doc = cm.doc;\n    var result = prepareSelection(cm);\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm, display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  };\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing) { return }\n    var cm = this.cm;\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n      if (cm.state.focused) { selectInput(this.textarea); }\n      if (ie && ie_version >= 9) { this.hasSelection = content; }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n      if (ie && ie_version >= 9) { this.hasSelection = null; }\n    }\n  };\n\n  TextareaInput.prototype.getField = function () { return this.textarea };\n\n  TextareaInput.prototype.supportsTouch = function () { return false };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n      try { this.textarea.focus(); }\n      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n    }\n  };\n\n  TextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  TextareaInput.prototype.slowPoll = function () {\n      var this$1 = this;\n\n    if (this.pollingFast) { return }\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n      if (this$1.cm.state.focused) { this$1.slowPoll(); }\n    });\n  };\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false, input = this;\n    input.pollingFast = true;\n    function p() {\n      var changed = input.poll();\n      if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n      else {input.pollingFast = false; input.slowPoll();}\n    }\n    input.polling.set(20, p);\n  };\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  TextareaInput.prototype.poll = function () {\n      var this$1 = this;\n\n    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (this.contextMenuPending || !cm.state.focused ||\n        (hasSelection(input) && !prevInput && !this.composing) ||\n        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n      { return false }\n\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput && !cm.somethingSelected()) { return false }\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie && ie_version >= 9 && this.hasSelection === text ||\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n      if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n      if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n    }\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same,\n                     null, this$1.composing ? \"*compose\" : null);\n\n      // Don't leave long text in the textarea, since it makes further polling slow\n      if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n      else { this$1.prevInput = text; }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                           {className: \"CodeMirror-composing\"});\n      }\n    });\n    return true\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n    if (input.contextMenuPending) { input.contextMenuPending(); }\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) { return } // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && cm.doc.sel.contains(pos) == -1)\n      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n    display.input.focus();\n    if (webkit) { window.scrollTo(null, oldScrollY); }\n    display.input.reset();\n    // Adds \"Select all\" to context menu in FF\n    if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200b\" + (selected ? te.value : \"\");\n        te.value = \"\\u21da\"; // Used to catch context-menu undo\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200b\";\n        te.selectionStart = 1; te.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      if (input.contextMenuPending != rehide) { return }\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n      // Try to detect the user choosing select-all\n      if (te.selectionStart != null) {\n        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n        var i = 0, poll = function () {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n              te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function () {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) { this.reset(); }\n    this.textarea.disabled = val == \"nocursor\";\n    this.textarea.readOnly = !!val;\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      { options.tabindex = textarea.tabIndex; }\n    if (!options.placeholder && textarea.placeholder)\n      { options.placeholder = textarea.placeholder; }\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n\n    var realSubmit;\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n      cm.getTextArea = function () { return textarea; };\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == \"function\")\n            { textarea.form.submit = realSubmit; }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n      options);\n    return cm\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  }\n\n  // EDITOR CONSTRUCTOR\n\n  defineOptions(CodeMirror);\n\n  addEditorMethods(CodeMirror);\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    { CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments)}\n    })(Doc.prototype[prop]); } }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name/*, mode, */) {\n    if (!CodeMirror.defaults.mode && name != \"null\") { CodeMirror.defaults.mode = name; }\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME;\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n\n  addLegacyProps(CodeMirror);\n\n  CodeMirror.version = \"5.62.0\";\n\n  return CodeMirror;\n\n})));\n\n\n//# sourceURL=webpack:///./node_modules/codemirror/lib/codemirror.js?");

/***/ }),

/***/ "./node_modules/codemirror/mode/python/python.js":
/*!*******************************************************!*\
  !*** ./node_modules/codemirror/mode/python/python.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ \"./node_modules/codemirror/lib/codemirror.js\"));\n  else {}\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\n  var commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\",\n                        \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\",\n                        \"for\", \"from\", \"global\", \"if\", \"import\",\n                        \"lambda\", \"pass\", \"raise\", \"return\",\n                        \"try\", \"while\", \"with\", \"yield\", \"in\"];\n  var commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\",\n                        \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\",\n                        \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\",\n                        \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\",\n                        \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\",\n                        \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\",\n                        \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\",\n                        \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\",\n                        \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\",\n                        \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\",\n                        \"Ellipsis\", \"__debug__\"];\n  CodeMirror.registerHelper(\"hintWords\", \"python\", commonKeywords.concat(commonBuiltins));\n\n  function top(state) {\n    return state.scopes[state.scopes.length - 1];\n  }\n\n  CodeMirror.defineMode(\"python\", function(conf, parserConf) {\n    var ERRORCLASS = \"error\";\n\n    var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.\\\\]/;\n    //               (Backwards-compatibility with old, cumbersome config system)\n    var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters,\n                     parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@]|\\.\\.\\.)/]\n    for (var i = 0; i < operators.length; i++) if (!operators[i]) operators.splice(i--, 1)\n\n    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;\n\n    var myKeywords = commonKeywords, myBuiltins = commonBuiltins;\n    if (parserConf.extra_keywords != undefined)\n      myKeywords = myKeywords.concat(parserConf.extra_keywords);\n\n    if (parserConf.extra_builtins != undefined)\n      myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n\n    var py3 = !(parserConf.version && Number(parserConf.version) < 3)\n    if (py3) {\n      // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n      var identifiers = parserConf.identifiers|| /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n      myKeywords = myKeywords.concat([\"nonlocal\", \"False\", \"True\", \"None\", \"async\", \"await\"]);\n      myBuiltins = myBuiltins.concat([\"ascii\", \"bytes\", \"exec\", \"print\"]);\n      var stringPrefixes = new RegExp(\"^(([rbuf]|(br)|(fr))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    } else {\n      var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;\n      myKeywords = myKeywords.concat([\"exec\", \"print\"]);\n      myBuiltins = myBuiltins.concat([\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\",\n                                      \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\",\n                                      \"unichr\", \"unicode\", \"xrange\", \"False\", \"True\", \"None\"]);\n      var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    }\n    var keywords = wordRegexp(myKeywords);\n    var builtins = wordRegexp(myBuiltins);\n\n    // tokenizers\n    function tokenBase(stream, state) {\n      var sol = stream.sol() && state.lastToken != \"\\\\\"\n      if (sol) state.indent = stream.indentation()\n      // Handle scope changes\n      if (sol && top(state).type == \"py\") {\n        var scopeOffset = top(state).offset;\n        if (stream.eatSpace()) {\n          var lineOffset = stream.indentation();\n          if (lineOffset > scopeOffset)\n            pushPyScope(state);\n          else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\")\n            state.errorToken = true;\n          return null;\n        } else {\n          var style = tokenBaseInner(stream, state);\n          if (scopeOffset > 0 && dedent(stream, state))\n            style += \" \" + ERRORCLASS;\n          return style;\n        }\n      }\n      return tokenBaseInner(stream, state);\n    }\n\n    function tokenBaseInner(stream, state, inFormat) {\n      if (stream.eatSpace()) return null;\n\n      // Handle Comments\n      if (!inFormat && stream.match(/^#.*/)) return \"comment\";\n\n      // Handle Number Literals\n      if (stream.match(/^[0-9\\.]/, false)) {\n        var floatLiteral = false;\n        // Floats\n        if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) { floatLiteral = true; }\n        if (stream.match(/^[\\d_]+\\.\\d*/)) { floatLiteral = true; }\n        if (stream.match(/^\\.\\d+/)) { floatLiteral = true; }\n        if (floatLiteral) {\n          // Float literals may be \"imaginary\"\n          stream.eat(/J/i);\n          return \"number\";\n        }\n        // Integers\n        var intLiteral = false;\n        // Hex\n        if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;\n        // Binary\n        if (stream.match(/^0b[01_]+/i)) intLiteral = true;\n        // Octal\n        if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;\n        // Decimal\n        if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n          // Decimal literals may be \"imaginary\"\n          stream.eat(/J/i);\n          // TODO - Can you have imaginary longs?\n          intLiteral = true;\n        }\n        // Zero by itself with no other piece of number.\n        if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n        if (intLiteral) {\n          // Integer literals may be \"long\"\n          stream.eat(/L/i);\n          return \"number\";\n        }\n      }\n\n      // Handle Strings\n      if (stream.match(stringPrefixes)) {\n        var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;\n        if (!isFmtString) {\n          state.tokenize = tokenStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        } else {\n          state.tokenize = formatStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        }\n      }\n\n      for (var i = 0; i < operators.length; i++)\n        if (stream.match(operators[i])) return \"operator\"\n\n      if (stream.match(delimiters)) return \"punctuation\";\n\n      if (state.lastToken == \".\" && stream.match(identifiers))\n        return \"property\";\n\n      if (stream.match(keywords) || stream.match(wordOperators))\n        return \"keyword\";\n\n      if (stream.match(builtins))\n        return \"builtin\";\n\n      if (stream.match(/^(self|cls)\\b/))\n        return \"variable-2\";\n\n      if (stream.match(identifiers)) {\n        if (state.lastToken == \"def\" || state.lastToken == \"class\")\n          return \"def\";\n        return \"variable\";\n      }\n\n      // Handle non-detected items\n      stream.next();\n      return inFormat ? null :ERRORCLASS;\n    }\n\n    function formatStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n        delimiter = delimiter.substr(1);\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenNestedExpr(depth) {\n        return function(stream, state) {\n          var inner = tokenBaseInner(stream, state, true)\n          if (inner == \"punctuation\") {\n            if (stream.current() == \"{\") {\n              state.tokenize = tokenNestedExpr(depth + 1)\n            } else if (stream.current() == \"}\") {\n              if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1)\n              else state.tokenize = tokenString\n            }\n          }\n          return inner\n        }\n      }\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\{\\}\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol())\n              return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else if (stream.match('{{')) {\n            // ignore {{ in f-str\n            return OUTCLASS;\n          } else if (stream.match('{', false)) {\n            // switch to nested mode\n            state.tokenize = tokenNestedExpr(0)\n            if (stream.current()) return OUTCLASS;\n            else return state.tokenize(stream, state)\n          } else if (stream.match('}}')) {\n            return OUTCLASS;\n          } else if (stream.match('}')) {\n            // single } in f-string is an error\n            return ERRORCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors)\n            return ERRORCLASS;\n          else\n            state.tokenize = tokenOuter;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function tokenStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n        delimiter = delimiter.substr(1);\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol())\n              return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors)\n            return ERRORCLASS;\n          else\n            state.tokenize = tokenOuter;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function pushPyScope(state) {\n      while (top(state).type != \"py\") state.scopes.pop()\n      state.scopes.push({offset: top(state).offset + conf.indentUnit,\n                         type: \"py\",\n                         align: null})\n    }\n\n    function pushBracketScope(stream, state, type) {\n      var align = stream.match(/^[\\s\\[\\{\\(]*(?:#|$)/, false) ? null : stream.column() + 1\n      state.scopes.push({offset: state.indent + hangingIndent,\n                         type: type,\n                         align: align})\n    }\n\n    function dedent(stream, state) {\n      var indented = stream.indentation();\n      while (state.scopes.length > 1 && top(state).offset > indented) {\n        if (top(state).type != \"py\") return true;\n        state.scopes.pop();\n      }\n      return top(state).offset != indented;\n    }\n\n    function tokenLexer(stream, state) {\n      if (stream.sol()) {\n        state.beginningOfLine = true;\n        state.dedent = false;\n      }\n\n      var style = state.tokenize(stream, state);\n      var current = stream.current();\n\n      // Handle decorators\n      if (state.beginningOfLine && current == \"@\")\n        return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n\n      if (/\\S/.test(current)) state.beginningOfLine = false;\n\n      if ((style == \"variable\" || style == \"builtin\")\n          && state.lastToken == \"meta\")\n        style = \"meta\";\n\n      // Handle scope changes.\n      if (current == \"pass\" || current == \"return\")\n        state.dedent = true;\n\n      if (current == \"lambda\") state.lambda = true;\n      if (current == \":\" && !state.lambda && top(state).type == \"py\" && stream.match(/^\\s*(?:#|$)/, false))\n        pushPyScope(state);\n\n      if (current.length == 1 && !/string|comment/.test(style)) {\n        var delimiter_index = \"[({\".indexOf(current);\n        if (delimiter_index != -1)\n          pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n\n        delimiter_index = \"])}\".indexOf(current);\n        if (delimiter_index != -1) {\n          if (top(state).type == current) state.indent = state.scopes.pop().offset - hangingIndent\n          else return ERRORCLASS;\n        }\n      }\n      if (state.dedent && stream.eol() && top(state).type == \"py\" && state.scopes.length > 1)\n        state.scopes.pop();\n\n      return style;\n    }\n\n    var external = {\n      startState: function(basecolumn) {\n        return {\n          tokenize: tokenBase,\n          scopes: [{offset: basecolumn || 0, type: \"py\", align: null}],\n          indent: basecolumn || 0,\n          lastToken: null,\n          lambda: false,\n          dedent: 0\n        };\n      },\n\n      token: function(stream, state) {\n        var addErr = state.errorToken;\n        if (addErr) state.errorToken = false;\n        var style = tokenLexer(stream, state);\n\n        if (style && style != \"comment\")\n          state.lastToken = (style == \"keyword\" || style == \"punctuation\") ? stream.current() : style;\n        if (style == \"punctuation\") style = null;\n\n        if (stream.eol() && state.lambda)\n          state.lambda = false;\n        return addErr ? style + \" \" + ERRORCLASS : style;\n      },\n\n      indent: function(state, textAfter) {\n        if (state.tokenize != tokenBase)\n          return state.tokenize.isString ? CodeMirror.Pass : 0;\n\n        var scope = top(state)\n        var closing = scope.type == textAfter.charAt(0) ||\n            scope.type == \"py\" && !state.dedent && /^(else:|elif |except |finally:)/.test(textAfter)\n        if (scope.align != null)\n          return scope.align - (closing ? 1 : 0)\n        else\n          return scope.offset - (closing ? hangingIndent : 0)\n      },\n\n      electricInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/,\n      closeBrackets: {triples: \"'\\\"\"},\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  });\n\n  CodeMirror.defineMIME(\"text/x-python\", \"python\");\n\n  var words = function(str) { return str.split(\" \"); };\n\n  CodeMirror.defineMIME(\"text/x-cython\", {\n    name: \"python\",\n    extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except \"+\n                          \"extern gil include nogil property public \"+\n                          \"readonly struct union DEF IF ELIF ELSE\")\n  });\n\n});\n\n\n//# sourceURL=webpack:///./node_modules/codemirror/mode/python/python.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[1]!./node_modules/codemirror/lib/codemirror.css":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[1]!./node_modules/codemirror/lib/codemirror.css ***!
  \**********************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* BASICS */\\n\\n.CodeMirror {\\n  /* Set height, width, borders, and global font properties here */\\n  font-family: monospace;\\n  height: 300px;\\n  color: black;\\n  direction: ltr;\\n}\\n\\n/* PADDING */\\n\\n.CodeMirror-lines {\\n  padding: 4px 0; /* Vertical padding around content */\\n}\\n.CodeMirror pre.CodeMirror-line,\\n.CodeMirror pre.CodeMirror-line-like {\\n  padding: 0 4px; /* Horizontal padding of content */\\n}\\n\\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\n  background-color: white; /* The little square between H and V scrollbars */\\n}\\n\\n/* GUTTER */\\n\\n.CodeMirror-gutters {\\n  border-right: 1px solid #ddd;\\n  background-color: #f7f7f7;\\n  white-space: nowrap;\\n}\\n.CodeMirror-linenumbers {}\\n.CodeMirror-linenumber {\\n  padding: 0 3px 0 5px;\\n  min-width: 20px;\\n  text-align: right;\\n  color: #999;\\n  white-space: nowrap;\\n}\\n\\n.CodeMirror-guttermarker { color: black; }\\n.CodeMirror-guttermarker-subtle { color: #999; }\\n\\n/* CURSOR */\\n\\n.CodeMirror-cursor {\\n  border-left: 1px solid black;\\n  border-right: none;\\n  width: 0;\\n}\\n/* Shown when moving in bi-directional text */\\n.CodeMirror div.CodeMirror-secondarycursor {\\n  border-left: 1px solid silver;\\n}\\n.cm-fat-cursor .CodeMirror-cursor {\\n  width: auto;\\n  border: 0 !important;\\n  background: #7e7;\\n}\\n.cm-fat-cursor div.CodeMirror-cursors {\\n  z-index: 1;\\n}\\n.cm-fat-cursor-mark {\\n  background-color: rgba(20, 255, 20, 0.5);\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\n  -moz-animation: blink 1.06s steps(1) infinite;\\n  animation: blink 1.06s steps(1) infinite;\\n}\\n.cm-animate-fat-cursor {\\n  width: auto;\\n  border: 0;\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\n  -moz-animation: blink 1.06s steps(1) infinite;\\n  animation: blink 1.06s steps(1) infinite;\\n  background-color: #7e7;\\n}\\n@-moz-keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n@-webkit-keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n@keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n\\n/* Can style cursor different in overwrite (non-insert) mode */\\n.CodeMirror-overwrite .CodeMirror-cursor {}\\n\\n.cm-tab { display: inline-block; text-decoration: inherit; }\\n\\n.CodeMirror-rulers {\\n  position: absolute;\\n  left: 0; right: 0; top: -50px; bottom: 0;\\n  overflow: hidden;\\n}\\n.CodeMirror-ruler {\\n  border-left: 1px solid #ccc;\\n  top: 0; bottom: 0;\\n  position: absolute;\\n}\\n\\n/* DEFAULT THEME */\\n\\n.cm-s-default .cm-header {color: blue;}\\n.cm-s-default .cm-quote {color: #090;}\\n.cm-negative {color: #d44;}\\n.cm-positive {color: #292;}\\n.cm-header, .cm-strong {font-weight: bold;}\\n.cm-em {font-style: italic;}\\n.cm-link {text-decoration: underline;}\\n.cm-strikethrough {text-decoration: line-through;}\\n\\n.cm-s-default .cm-keyword {color: #708;}\\n.cm-s-default .cm-atom {color: #219;}\\n.cm-s-default .cm-number {color: #164;}\\n.cm-s-default .cm-def {color: #00f;}\\n.cm-s-default .cm-variable,\\n.cm-s-default .cm-punctuation,\\n.cm-s-default .cm-property,\\n.cm-s-default .cm-operator {}\\n.cm-s-default .cm-variable-2 {color: #05a;}\\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\\n.cm-s-default .cm-comment {color: #a50;}\\n.cm-s-default .cm-string {color: #a11;}\\n.cm-s-default .cm-string-2 {color: #f50;}\\n.cm-s-default .cm-meta {color: #555;}\\n.cm-s-default .cm-qualifier {color: #555;}\\n.cm-s-default .cm-builtin {color: #30a;}\\n.cm-s-default .cm-bracket {color: #997;}\\n.cm-s-default .cm-tag {color: #170;}\\n.cm-s-default .cm-attribute {color: #00c;}\\n.cm-s-default .cm-hr {color: #999;}\\n.cm-s-default .cm-link {color: #00c;}\\n\\n.cm-s-default .cm-error {color: #f00;}\\n.cm-invalidchar {color: #f00;}\\n\\n.CodeMirror-composing { border-bottom: 2px solid; }\\n\\n/* Default styles for common addons */\\n\\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}\\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}\\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\\n.CodeMirror-activeline-background {background: #e8f2ff;}\\n\\n/* STOP */\\n\\n/* The rest of this file contains styles related to the mechanics of\\n   the editor. You probably shouldn't touch them. */\\n\\n.CodeMirror {\\n  position: relative;\\n  overflow: hidden;\\n  background: white;\\n}\\n\\n.CodeMirror-scroll {\\n  overflow: scroll !important; /* Things will break if this is overridden */\\n  /* 50px is the magic margin used to hide the element's real scrollbars */\\n  /* See overflow: hidden in .CodeMirror */\\n  margin-bottom: -50px; margin-right: -50px;\\n  padding-bottom: 50px;\\n  height: 100%;\\n  outline: none; /* Prevent dragging from highlighting the element */\\n  position: relative;\\n}\\n.CodeMirror-sizer {\\n  position: relative;\\n  border-right: 50px solid transparent;\\n}\\n\\n/* The fake, visible scrollbars. Used to force redraw during scrolling\\n   before actual scrolling happens, thus preventing shaking and\\n   flickering artifacts. */\\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\n  position: absolute;\\n  z-index: 6;\\n  display: none;\\n  outline: none;\\n}\\n.CodeMirror-vscrollbar {\\n  right: 0; top: 0;\\n  overflow-x: hidden;\\n  overflow-y: scroll;\\n}\\n.CodeMirror-hscrollbar {\\n  bottom: 0; left: 0;\\n  overflow-y: hidden;\\n  overflow-x: scroll;\\n}\\n.CodeMirror-scrollbar-filler {\\n  right: 0; bottom: 0;\\n}\\n.CodeMirror-gutter-filler {\\n  left: 0; bottom: 0;\\n}\\n\\n.CodeMirror-gutters {\\n  position: absolute; left: 0; top: 0;\\n  min-height: 100%;\\n  z-index: 3;\\n}\\n.CodeMirror-gutter {\\n  white-space: normal;\\n  height: 100%;\\n  display: inline-block;\\n  vertical-align: top;\\n  margin-bottom: -50px;\\n}\\n.CodeMirror-gutter-wrapper {\\n  position: absolute;\\n  z-index: 4;\\n  background: none !important;\\n  border: none !important;\\n}\\n.CodeMirror-gutter-background {\\n  position: absolute;\\n  top: 0; bottom: 0;\\n  z-index: 4;\\n}\\n.CodeMirror-gutter-elt {\\n  position: absolute;\\n  cursor: default;\\n  z-index: 4;\\n}\\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\\n\\n.CodeMirror-lines {\\n  cursor: text;\\n  min-height: 1px; /* prevents collapsing before first draw */\\n}\\n.CodeMirror pre.CodeMirror-line,\\n.CodeMirror pre.CodeMirror-line-like {\\n  /* Reset some styles that the rest of the page might have set */\\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\\n  border-width: 0;\\n  background: transparent;\\n  font-family: inherit;\\n  font-size: inherit;\\n  margin: 0;\\n  white-space: pre;\\n  word-wrap: normal;\\n  line-height: inherit;\\n  color: inherit;\\n  z-index: 2;\\n  position: relative;\\n  overflow: visible;\\n  -webkit-tap-highlight-color: transparent;\\n  -webkit-font-variant-ligatures: contextual;\\n  font-variant-ligatures: contextual;\\n}\\n.CodeMirror-wrap pre.CodeMirror-line,\\n.CodeMirror-wrap pre.CodeMirror-line-like {\\n  word-wrap: break-word;\\n  white-space: pre-wrap;\\n  word-break: normal;\\n}\\n\\n.CodeMirror-linebackground {\\n  position: absolute;\\n  left: 0; right: 0; top: 0; bottom: 0;\\n  z-index: 0;\\n}\\n\\n.CodeMirror-linewidget {\\n  position: relative;\\n  z-index: 2;\\n  padding: 0.1px; /* Force widget margins to stay inside of the container */\\n}\\n\\n.CodeMirror-widget {}\\n\\n.CodeMirror-rtl pre { direction: rtl; }\\n\\n.CodeMirror-code {\\n  outline: none;\\n}\\n\\n/* Force content-box sizing for the elements where we expect it */\\n.CodeMirror-scroll,\\n.CodeMirror-sizer,\\n.CodeMirror-gutter,\\n.CodeMirror-gutters,\\n.CodeMirror-linenumber {\\n  -moz-box-sizing: content-box;\\n  box-sizing: content-box;\\n}\\n\\n.CodeMirror-measure {\\n  position: absolute;\\n  width: 100%;\\n  height: 0;\\n  overflow: hidden;\\n  visibility: hidden;\\n}\\n\\n.CodeMirror-cursor {\\n  position: absolute;\\n  pointer-events: none;\\n}\\n.CodeMirror-measure pre { position: static; }\\n\\ndiv.CodeMirror-cursors {\\n  visibility: hidden;\\n  position: relative;\\n  z-index: 3;\\n}\\ndiv.CodeMirror-dragcursors {\\n  visibility: visible;\\n}\\n\\n.CodeMirror-focused div.CodeMirror-cursors {\\n  visibility: visible;\\n}\\n\\n.CodeMirror-selected { background: #d9d9d9; }\\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\\n.CodeMirror-crosshair { cursor: crosshair; }\\n.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }\\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }\\n\\n.cm-searching {\\n  background-color: #ffa;\\n  background-color: rgba(255, 255, 0, .4);\\n}\\n\\n/* Used to force a border model for a node */\\n.cm-force-border { padding-right: .1px; }\\n\\n@media print {\\n  /* Hide the cursor when printing */\\n  .CodeMirror div.CodeMirror-cursors {\\n    visibility: hidden;\\n  }\\n}\\n\\n/* See issue #2901 */\\n.cm-tab-wrap-hack:after { content: ''; }\\n\\n/* Help users use markselection to safely style text background */\\nspan.CodeMirror-selectedtext { background: none; }\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./node_modules/codemirror/lib/codemirror.css?./node_modules/css-loader/dist/cjs.js??ruleSet%5B1%5D.rules%5B1%5D.use%5B1%5D");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[1]!./public/css/panda-syntax.css":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[1]!./public/css/panda-syntax.css ***!
  \*******************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*\\n\\tName:       Panda Syntax\\n\\tAuthor:     Siamak Mokhtari (http://github.com/siamak/)\\n\\tCodeMirror template by Siamak Mokhtari (https://github.com/siamak/atom-panda-syntax)\\n*/\\n.cm-s-panda-syntax {\\n\\tbackground: #292A2B;\\n\\tcolor: #E6E6E6;\\n\\tline-height: 1.2;\\n\\tfont-size:small;\\n\\tfont-family: 'Operator Mono', 'Source Code Pro', Menlo, Monaco, Consolas, Courier New, monospace;\\n}\\n.cm-s-panda-syntax .CodeMirror-cursor { border-color: #ff2c6d; }\\n.cm-s-panda-syntax .CodeMirror-activeline-background {\\n\\tbackground: rgba(99, 123, 156, 0.1);\\n}\\n.cm-s-panda-syntax .CodeMirror-selected {\\n\\tbackground: rgba(255, 255, 255, 0.26);\\n}\\n.cm-s-panda-syntax .cm-comment {\\n\\tfont-style: italic;\\n\\tcolor: #c0c1c5;\\n}\\n.cm-s-panda-syntax .cm-operator {\\n\\tcolor: #f3f3f3;\\n}\\n.cm-s-panda-syntax .cm-string {\\n\\tcolor: #ffffff;\\n}\\n.cm-s-panda-syntax .cm-string-2 {\\n    color: #FFB86C;\\n}\\n\\n.cm-s-panda-syntax .cm-string-3 {\\n    color: #99d1ff;\\n}\\n\\n.cm-s-panda-syntax .cm-tag {\\n\\tcolor: #ff2c6d;\\n}\\n.cm-s-panda-syntax .cm-meta {\\n\\tcolor: #b084eb;\\n}\\n\\n.cm-s-panda-syntax .cm-number {\\n\\tcolor: #FFB86C;\\n}\\n.cm-s-panda-syntax .cm-atom {\\n\\tcolor: #ff2c6d;\\n}\\n.cm-s-panda-syntax .cm-keyword {\\n\\tcolor: #ffadd3;\\n}\\n.cm-s-panda-syntax .cm-variable {\\n\\tcolor: #ffb86c;\\n}\\n.cm-s-panda-syntax .cm-variable-2 {\\n\\tcolor: #ff9ac1;\\n}\\n.cm-s-panda-syntax .cm-variable-3, .cm-s-panda-syntax .cm-type {\\n\\tcolor: #ff9ac1;\\n}\\n\\n.cm-s-panda-syntax .cm-def {\\n\\tcolor: #e6e6e6;\\n}\\n.cm-s-panda-syntax .cm-property {\\n\\tcolor: #f3f3f3;\\n}\\n.cm-s-panda-syntax .cm-unit {\\n    color: #ffb86c;\\n}\\n\\n.cm-s-panda-syntax .cm-attribute {\\n    color: #ffb86c;\\n}\\n\\n.cm-s-panda-syntax .cm-age {\\n    color: #ff9f9f;\\n}\\n\\n.cm-s-panda-syntax .CodeMirror-matchingbracket {\\n    border-bottom: 1px dotted #19F9D8;\\n    padding-bottom: 2px;\\n    color: #e6e6e6;\\n}\\n.cm-s-panda-syntax .CodeMirror-gutters {\\n    background: #292a2b;\\n    border-right-color: rgba(255, 255, 255, 0.1);\\n}\\n.cm-s-panda-syntax .CodeMirror-linenumber {\\n    color: #e6e6e6;\\n    opacity: 0.6;\\n}\\n\\n\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./public/css/panda-syntax.css?./node_modules/css-loader/dist/cjs.js??ruleSet%5B1%5D.rules%5B1%5D.use%5B1%5D");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_DataView.js?");

/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var hashClear = __webpack_require__(/*! ./_hashClear */ \"./node_modules/lodash/_hashClear.js\"),\n    hashDelete = __webpack_require__(/*! ./_hashDelete */ \"./node_modules/lodash/_hashDelete.js\"),\n    hashGet = __webpack_require__(/*! ./_hashGet */ \"./node_modules/lodash/_hashGet.js\"),\n    hashHas = __webpack_require__(/*! ./_hashHas */ \"./node_modules/lodash/_hashHas.js\"),\n    hashSet = __webpack_require__(/*! ./_hashSet */ \"./node_modules/lodash/_hashSet.js\");\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_Hash.js?");

/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ \"./node_modules/lodash/_listCacheClear.js\"),\n    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ \"./node_modules/lodash/_listCacheDelete.js\"),\n    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ \"./node_modules/lodash/_listCacheGet.js\"),\n    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ \"./node_modules/lodash/_listCacheHas.js\"),\n    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ \"./node_modules/lodash/_listCacheSet.js\");\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_ListCache.js?");

/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_Map.js?");

/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ \"./node_modules/lodash/_mapCacheClear.js\"),\n    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ \"./node_modules/lodash/_mapCacheDelete.js\"),\n    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ \"./node_modules/lodash/_mapCacheGet.js\"),\n    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ \"./node_modules/lodash/_mapCacheHas.js\"),\n    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ \"./node_modules/lodash/_mapCacheSet.js\");\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_MapCache.js?");

/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_Promise.js?");

/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_Set.js?");

/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var ListCache = __webpack_require__(/*! ./_ListCache */ \"./node_modules/lodash/_ListCache.js\"),\n    stackClear = __webpack_require__(/*! ./_stackClear */ \"./node_modules/lodash/_stackClear.js\"),\n    stackDelete = __webpack_require__(/*! ./_stackDelete */ \"./node_modules/lodash/_stackDelete.js\"),\n    stackGet = __webpack_require__(/*! ./_stackGet */ \"./node_modules/lodash/_stackGet.js\"),\n    stackHas = __webpack_require__(/*! ./_stackHas */ \"./node_modules/lodash/_stackHas.js\"),\n    stackSet = __webpack_require__(/*! ./_stackSet */ \"./node_modules/lodash/_stackSet.js\");\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_Stack.js?");

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_Symbol.js?");

/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_Uint8Array.js?");

/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_WeakMap.js?");

/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/***/ ((module) => {

eval("/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_arrayEach.js?");

/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/***/ ((module) => {

eval("/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_arrayFilter.js?");

/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseTimes = __webpack_require__(/*! ./_baseTimes */ \"./node_modules/lodash/_baseTimes.js\"),\n    isArguments = __webpack_require__(/*! ./isArguments */ \"./node_modules/lodash/isArguments.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/lodash/isArray.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/lodash/isBuffer.js\"),\n    isIndex = __webpack_require__(/*! ./_isIndex */ \"./node_modules/lodash/_isIndex.js\"),\n    isTypedArray = __webpack_require__(/*! ./isTypedArray */ \"./node_modules/lodash/isTypedArray.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_arrayLikeKeys.js?");

/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/***/ ((module) => {

eval("/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_arrayPush.js?");

/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ \"./node_modules/lodash/_baseAssignValue.js\"),\n    eq = __webpack_require__(/*! ./eq */ \"./node_modules/lodash/eq.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_assignValue.js?");

/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var eq = __webpack_require__(/*! ./eq */ \"./node_modules/lodash/eq.js\");\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_assocIndexOf.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseAssign.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/lodash/_copyObject.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/lodash/keys.js\");\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseAssign.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseAssignIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/lodash/_copyObject.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/lodash/keysIn.js\");\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseAssignIn.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var defineProperty = __webpack_require__(/*! ./_defineProperty */ \"./node_modules/lodash/_defineProperty.js\");\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseAssignValue.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseClone.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Stack = __webpack_require__(/*! ./_Stack */ \"./node_modules/lodash/_Stack.js\"),\n    arrayEach = __webpack_require__(/*! ./_arrayEach */ \"./node_modules/lodash/_arrayEach.js\"),\n    assignValue = __webpack_require__(/*! ./_assignValue */ \"./node_modules/lodash/_assignValue.js\"),\n    baseAssign = __webpack_require__(/*! ./_baseAssign */ \"./node_modules/lodash/_baseAssign.js\"),\n    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ \"./node_modules/lodash/_baseAssignIn.js\"),\n    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ \"./node_modules/lodash/_cloneBuffer.js\"),\n    copyArray = __webpack_require__(/*! ./_copyArray */ \"./node_modules/lodash/_copyArray.js\"),\n    copySymbols = __webpack_require__(/*! ./_copySymbols */ \"./node_modules/lodash/_copySymbols.js\"),\n    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ \"./node_modules/lodash/_copySymbolsIn.js\"),\n    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ \"./node_modules/lodash/_getAllKeys.js\"),\n    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ \"./node_modules/lodash/_getAllKeysIn.js\"),\n    getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/lodash/_getTag.js\"),\n    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ \"./node_modules/lodash/_initCloneArray.js\"),\n    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ \"./node_modules/lodash/_initCloneByTag.js\"),\n    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ \"./node_modules/lodash/_initCloneObject.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/lodash/isArray.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/lodash/isBuffer.js\"),\n    isMap = __webpack_require__(/*! ./isMap */ \"./node_modules/lodash/isMap.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    isSet = __webpack_require__(/*! ./isSet */ \"./node_modules/lodash/isSet.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/lodash/keys.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/lodash/keysIn.js\");\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseClone.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\");\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseCreate.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var arrayPush = __webpack_require__(/*! ./_arrayPush */ \"./node_modules/lodash/_arrayPush.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/lodash/isArray.js\");\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseGetAllKeys.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/lodash/_Symbol.js\"),\n    getRawTag = __webpack_require__(/*! ./_getRawTag */ \"./node_modules/lodash/_getRawTag.js\"),\n    objectToString = __webpack_require__(/*! ./_objectToString */ \"./node_modules/lodash/_objectToString.js\");\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseGetTag.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/lodash/_baseGetTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseIsArguments.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseIsMap.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/lodash/_getTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseIsMap.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isFunction = __webpack_require__(/*! ./isFunction */ \"./node_modules/lodash/isFunction.js\"),\n    isMasked = __webpack_require__(/*! ./_isMasked */ \"./node_modules/lodash/_isMasked.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    toSource = __webpack_require__(/*! ./_toSource */ \"./node_modules/lodash/_toSource.js\");\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseIsNative.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseIsSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/lodash/_getTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseIsSet.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/lodash/_baseGetTag.js\"),\n    isLength = __webpack_require__(/*! ./isLength */ \"./node_modules/lodash/isLength.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseIsTypedArray.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isPrototype = __webpack_require__(/*! ./_isPrototype */ \"./node_modules/lodash/_isPrototype.js\"),\n    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ \"./node_modules/lodash/_nativeKeys.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseKeys.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\"),\n    isPrototype = __webpack_require__(/*! ./_isPrototype */ \"./node_modules/lodash/_isPrototype.js\"),\n    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ \"./node_modules/lodash/_nativeKeysIn.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseKeysIn.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/***/ ((module) => {

eval("/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseTimes.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/***/ ((module) => {

eval("/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_baseUnary.js?");

/***/ }),

/***/ "./node_modules/lodash/_cloneArrayBuffer.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ \"./node_modules/lodash/_Uint8Array.js\");\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_cloneArrayBuffer.js?");

/***/ }),

/***/ "./node_modules/lodash/_cloneBuffer.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_cloneBuffer.js?");

/***/ }),

/***/ "./node_modules/lodash/_cloneDataView.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ \"./node_modules/lodash/_cloneArrayBuffer.js\");\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_cloneDataView.js?");

/***/ }),

/***/ "./node_modules/lodash/_cloneRegExp.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
/***/ ((module) => {

eval("/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_cloneRegExp.js?");

/***/ }),

/***/ "./node_modules/lodash/_cloneSymbol.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/lodash/_Symbol.js\");\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_cloneSymbol.js?");

/***/ }),

/***/ "./node_modules/lodash/_cloneTypedArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ \"./node_modules/lodash/_cloneArrayBuffer.js\");\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_cloneTypedArray.js?");

/***/ }),

/***/ "./node_modules/lodash/_copyArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
/***/ ((module) => {

eval("/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_copyArray.js?");

/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var assignValue = __webpack_require__(/*! ./_assignValue */ \"./node_modules/lodash/_assignValue.js\"),\n    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ \"./node_modules/lodash/_baseAssignValue.js\");\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_copyObject.js?");

/***/ }),

/***/ "./node_modules/lodash/_copySymbols.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/lodash/_copyObject.js\"),\n    getSymbols = __webpack_require__(/*! ./_getSymbols */ \"./node_modules/lodash/_getSymbols.js\");\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_copySymbols.js?");

/***/ }),

/***/ "./node_modules/lodash/_copySymbolsIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/lodash/_copyObject.js\"),\n    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ \"./node_modules/lodash/_getSymbolsIn.js\");\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_copySymbolsIn.js?");

/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_coreJsData.js?");

/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/lodash/_getNative.js\");\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_defineProperty.js?");

/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\nmodule.exports = freeGlobal;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_freeGlobal.js?");

/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ \"./node_modules/lodash/_baseGetAllKeys.js\"),\n    getSymbols = __webpack_require__(/*! ./_getSymbols */ \"./node_modules/lodash/_getSymbols.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/lodash/keys.js\");\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_getAllKeys.js?");

/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ \"./node_modules/lodash/_baseGetAllKeys.js\"),\n    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ \"./node_modules/lodash/_getSymbolsIn.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/lodash/keysIn.js\");\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_getAllKeysIn.js?");

/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isKeyable = __webpack_require__(/*! ./_isKeyable */ \"./node_modules/lodash/_isKeyable.js\");\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_getMapData.js?");

/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ \"./node_modules/lodash/_baseIsNative.js\"),\n    getValue = __webpack_require__(/*! ./_getValue */ \"./node_modules/lodash/_getValue.js\");\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_getNative.js?");

/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var overArg = __webpack_require__(/*! ./_overArg */ \"./node_modules/lodash/_overArg.js\");\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_getPrototype.js?");

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/lodash/_Symbol.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_getRawTag.js?");

/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ \"./node_modules/lodash/_arrayFilter.js\"),\n    stubArray = __webpack_require__(/*! ./stubArray */ \"./node_modules/lodash/stubArray.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_getSymbols.js?");

/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var arrayPush = __webpack_require__(/*! ./_arrayPush */ \"./node_modules/lodash/_arrayPush.js\"),\n    getPrototype = __webpack_require__(/*! ./_getPrototype */ \"./node_modules/lodash/_getPrototype.js\"),\n    getSymbols = __webpack_require__(/*! ./_getSymbols */ \"./node_modules/lodash/_getSymbols.js\"),\n    stubArray = __webpack_require__(/*! ./stubArray */ \"./node_modules/lodash/stubArray.js\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_getSymbolsIn.js?");

/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var DataView = __webpack_require__(/*! ./_DataView */ \"./node_modules/lodash/_DataView.js\"),\n    Map = __webpack_require__(/*! ./_Map */ \"./node_modules/lodash/_Map.js\"),\n    Promise = __webpack_require__(/*! ./_Promise */ \"./node_modules/lodash/_Promise.js\"),\n    Set = __webpack_require__(/*! ./_Set */ \"./node_modules/lodash/_Set.js\"),\n    WeakMap = __webpack_require__(/*! ./_WeakMap */ \"./node_modules/lodash/_WeakMap.js\"),\n    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/lodash/_baseGetTag.js\"),\n    toSource = __webpack_require__(/*! ./_toSource */ \"./node_modules/lodash/_toSource.js\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_getTag.js?");

/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/***/ ((module) => {

eval("/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_getValue.js?");

/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"./node_modules/lodash/_nativeCreate.js\");\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_hashClear.js?");

/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/***/ ((module) => {

eval("/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_hashDelete.js?");

/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"./node_modules/lodash/_nativeCreate.js\");\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_hashGet.js?");

/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"./node_modules/lodash/_nativeCreate.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_hashHas.js?");

/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"./node_modules/lodash/_nativeCreate.js\");\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_hashSet.js?");

/***/ }),

/***/ "./node_modules/lodash/_initCloneArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
/***/ ((module) => {

eval("/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_initCloneArray.js?");

/***/ }),

/***/ "./node_modules/lodash/_initCloneByTag.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ \"./node_modules/lodash/_cloneArrayBuffer.js\"),\n    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ \"./node_modules/lodash/_cloneDataView.js\"),\n    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ \"./node_modules/lodash/_cloneRegExp.js\"),\n    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ \"./node_modules/lodash/_cloneSymbol.js\"),\n    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ \"./node_modules/lodash/_cloneTypedArray.js\");\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_initCloneByTag.js?");

/***/ }),

/***/ "./node_modules/lodash/_initCloneObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseCreate = __webpack_require__(/*! ./_baseCreate */ \"./node_modules/lodash/_baseCreate.js\"),\n    getPrototype = __webpack_require__(/*! ./_getPrototype */ \"./node_modules/lodash/_getPrototype.js\"),\n    isPrototype = __webpack_require__(/*! ./_isPrototype */ \"./node_modules/lodash/_isPrototype.js\");\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_initCloneObject.js?");

/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_isIndex.js?");

/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/***/ ((module) => {

eval("/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_isKeyable.js?");

/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var coreJsData = __webpack_require__(/*! ./_coreJsData */ \"./node_modules/lodash/_coreJsData.js\");\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_isMasked.js?");

/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/***/ ((module) => {

eval("/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_isPrototype.js?");

/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_listCacheClear.js?");

/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"./node_modules/lodash/_assocIndexOf.js\");\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_listCacheDelete.js?");

/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"./node_modules/lodash/_assocIndexOf.js\");\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_listCacheGet.js?");

/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"./node_modules/lodash/_assocIndexOf.js\");\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_listCacheHas.js?");

/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"./node_modules/lodash/_assocIndexOf.js\");\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_listCacheSet.js?");

/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Hash = __webpack_require__(/*! ./_Hash */ \"./node_modules/lodash/_Hash.js\"),\n    ListCache = __webpack_require__(/*! ./_ListCache */ \"./node_modules/lodash/_ListCache.js\"),\n    Map = __webpack_require__(/*! ./_Map */ \"./node_modules/lodash/_Map.js\");\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_mapCacheClear.js?");

/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getMapData = __webpack_require__(/*! ./_getMapData */ \"./node_modules/lodash/_getMapData.js\");\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_mapCacheDelete.js?");

/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getMapData = __webpack_require__(/*! ./_getMapData */ \"./node_modules/lodash/_getMapData.js\");\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_mapCacheGet.js?");

/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getMapData = __webpack_require__(/*! ./_getMapData */ \"./node_modules/lodash/_getMapData.js\");\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_mapCacheHas.js?");

/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getMapData = __webpack_require__(/*! ./_getMapData */ \"./node_modules/lodash/_getMapData.js\");\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_mapCacheSet.js?");

/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/lodash/_getNative.js\");\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_nativeCreate.js?");

/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var overArg = __webpack_require__(/*! ./_overArg */ \"./node_modules/lodash/_overArg.js\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_nativeKeys.js?");

/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/***/ ((module) => {

eval("/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_nativeKeysIn.js?");

/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar freeGlobal = __webpack_require__(/*! ./_freeGlobal */ \"./node_modules/lodash/_freeGlobal.js\");\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_nodeUtil.js?");

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ ((module) => {

eval("/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_objectToString.js?");

/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_overArg.js?");

/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ \"./node_modules/lodash/_freeGlobal.js\");\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_root.js?");

/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var ListCache = __webpack_require__(/*! ./_ListCache */ \"./node_modules/lodash/_ListCache.js\");\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_stackClear.js?");

/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/***/ ((module) => {

eval("/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_stackDelete.js?");

/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/***/ ((module) => {

eval("/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_stackGet.js?");

/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/***/ ((module) => {

eval("/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_stackHas.js?");

/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var ListCache = __webpack_require__(/*! ./_ListCache */ \"./node_modules/lodash/_ListCache.js\"),\n    Map = __webpack_require__(/*! ./_Map */ \"./node_modules/lodash/_Map.js\"),\n    MapCache = __webpack_require__(/*! ./_MapCache */ \"./node_modules/lodash/_MapCache.js\");\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_stackSet.js?");

/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/***/ ((module) => {

eval("/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/_toSource.js?");

/***/ }),

/***/ "./node_modules/lodash/cloneDeep.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/cloneDeep.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseClone = __webpack_require__(/*! ./_baseClone */ \"./node_modules/lodash/_baseClone.js\");\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = cloneDeep;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/cloneDeep.js?");

/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/***/ ((module) => {

eval("/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/eq.js?");

/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ \"./node_modules/lodash/_baseIsArguments.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/lodash/isObjectLike.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/isArguments.js?");

/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/***/ ((module) => {

eval("/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/isArray.js?");

/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isFunction = __webpack_require__(/*! ./isFunction */ \"./node_modules/lodash/isFunction.js\"),\n    isLength = __webpack_require__(/*! ./isLength */ \"./node_modules/lodash/isLength.js\");\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/isArrayLike.js?");

/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\"),\n    stubFalse = __webpack_require__(/*! ./stubFalse */ \"./node_modules/lodash/stubFalse.js\");\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/isBuffer.js?");

/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/lodash/_baseGetTag.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/lodash/isObject.js\");\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/isFunction.js?");

/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/isLength.js?");

/***/ }),

/***/ "./node_modules/lodash/isMap.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ \"./node_modules/lodash/_baseIsMap.js\"),\n    baseUnary = __webpack_require__(/*! ./_baseUnary */ \"./node_modules/lodash/_baseUnary.js\"),\n    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ \"./node_modules/lodash/_nodeUtil.js\");\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/isMap.js?");

/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/isObject.js?");

/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module) => {

eval("/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/isObjectLike.js?");

/***/ }),

/***/ "./node_modules/lodash/isSet.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ \"./node_modules/lodash/_baseIsSet.js\"),\n    baseUnary = __webpack_require__(/*! ./_baseUnary */ \"./node_modules/lodash/_baseUnary.js\"),\n    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ \"./node_modules/lodash/_nodeUtil.js\");\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/isSet.js?");

/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ \"./node_modules/lodash/_baseIsTypedArray.js\"),\n    baseUnary = __webpack_require__(/*! ./_baseUnary */ \"./node_modules/lodash/_baseUnary.js\"),\n    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ \"./node_modules/lodash/_nodeUtil.js\");\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/isTypedArray.js?");

/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ \"./node_modules/lodash/_arrayLikeKeys.js\"),\n    baseKeys = __webpack_require__(/*! ./_baseKeys */ \"./node_modules/lodash/_baseKeys.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/lodash/isArrayLike.js\");\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/keys.js?");

/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ \"./node_modules/lodash/_arrayLikeKeys.js\"),\n    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ \"./node_modules/lodash/_baseKeysIn.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/lodash/isArrayLike.js\");\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/keysIn.js?");

/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/***/ ((module) => {

eval("/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/stubArray.js?");

/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/***/ ((module) => {

eval("/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n\n\n//# sourceURL=webpack:///./node_modules/lodash/stubFalse.js?");

/***/ }),

/***/ "./node_modules/codemirror/lib/codemirror.css":
/*!****************************************************!*\
  !*** ./node_modules/codemirror/lib/codemirror.css ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../style-loader/dist/runtime/getTarget.js */ \"./node_modules/style-loader/dist/runtime/getTarget.js\");\n/* harmony import */ var _style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_codemirror_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js??ruleSet[1].rules[1].use[1]!./codemirror.css */ \"./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[1]!./node_modules/codemirror/lib/codemirror.css\");\n\n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = function(css, style){\n      if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n      } else {\n      while (style.firstChild) {\n        style.removeChild(style.firstChild);\n      }\n\n      style.appendChild(document.createTextNode(css));\n    }\n  };\noptions.setAttributes = function(style) {\n        var nonce =\n           true ? __webpack_require__.nc : 0;\n\n        if (nonce) {\n          style.setAttribute(\"nonce\", nonce);\n        }\n      };\noptions.insert = function(style){\n    var target = _style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2___default()(\"head\");\n\n    if (!target) {\n      throw new Error(\n        \"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\"\n      );\n    }\n\n    target.appendChild(style);\n  };\noptions.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default());\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_codemirror_css__WEBPACK_IMPORTED_MODULE_4__.default, options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_codemirror_css__WEBPACK_IMPORTED_MODULE_4__.default && _css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_codemirror_css__WEBPACK_IMPORTED_MODULE_4__.default.locals ? _css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_codemirror_css__WEBPACK_IMPORTED_MODULE_4__.default.locals : undefined);\n\n\n//# sourceURL=webpack:///./node_modules/codemirror/lib/codemirror.css?");

/***/ }),

/***/ "./public/css/panda-syntax.css":
/*!*************************************!*\
  !*** ./public/css/panda-syntax.css ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/getTarget.js */ \"./node_modules/style-loader/dist/runtime/getTarget.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_panda_syntax_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[1]!./panda-syntax.css */ \"./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].use[1]!./public/css/panda-syntax.css\");\n\n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = function(css, style){\n      if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n      } else {\n      while (style.firstChild) {\n        style.removeChild(style.firstChild);\n      }\n\n      style.appendChild(document.createTextNode(css));\n    }\n  };\noptions.setAttributes = function(style) {\n        var nonce =\n           true ? __webpack_require__.nc : 0;\n\n        if (nonce) {\n          style.setAttribute(\"nonce\", nonce);\n        }\n      };\noptions.insert = function(style){\n    var target = _node_modules_style_loader_dist_runtime_getTarget_js__WEBPACK_IMPORTED_MODULE_2___default()(\"head\");\n\n    if (!target) {\n      throw new Error(\n        \"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\"\n      );\n    }\n\n    target.appendChild(style);\n  };\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_3___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_panda_syntax_css__WEBPACK_IMPORTED_MODULE_4__.default, options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_panda_syntax_css__WEBPACK_IMPORTED_MODULE_4__.default && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_panda_syntax_css__WEBPACK_IMPORTED_MODULE_4__.default.locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_use_1_panda_syntax_css__WEBPACK_IMPORTED_MODULE_4__.default.locals : undefined);\n\n\n//# sourceURL=webpack:///./public/css/panda-syntax.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/getTarget.js":
/*!*************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/getTarget.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n\nmodule.exports = getTarget;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/getTarget.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var style = document.createElement(\"style\");\n  options.setAttributes(style, options.attributes);\n  options.insert(style);\n  return style;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute(\"media\", media);\n  } else {\n    style.removeAttribute(\"media\");\n  }\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, style);\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var style = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(style, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(style);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./src/define.ts":
/*!***********************!*\
  !*** ./src/define.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction getCharge(load, isCard) {\n    const switch_db = (db, change) => {\n        const i = db.findIndex((e) => e[0] === change[0]);\n        if (i !== -1) {\n            db[i] = change;\n        }\n        else {\n            throw Error(\"not found\");\n        }\n    };\n    const db_skill = [\n        [0, 5],\n        [10, 8],\n        [27.5, 17],\n        [35, 17],\n        [40, 8],\n        [45, 2],\n        [50, 5],\n        [55, 8],\n        [60, 8],\n        [65, 8],\n        [67.5, 17],\n        [70, 2],\n        [75, 8],\n        [80, 5],\n        [100, 5],\n        [110, 22],\n        [120, 8],\n        [125, 8],\n        [130, 8],\n        [135, 17],\n        [140, 8],\n        [145, 8],\n        [150, 17],\n        [155, 8],\n        [165, 10],\n        [170, 17],\n        [190, 17],\n        [200, 17],\n    ];\n    switch_db(db_skill, [125, 0]);\n    switch_db(db_skill, [10, 0]);\n    switch_db(db_skill, [100, 17]);\n    switch_db(db_skill, [70, 17]);\n    switch_db(db_skill, [75, 17]);\n    switch_db(db_skill, [130, 10]);\n    const db_skill_card = [\n        [75, 5],\n        [80, 22],\n        [100, 17],\n    ];\n    switch_db(db_skill_card, [100, 22]);\n    const db = isCard ? db_skill_card : db_skill;\n    const charge = db.find((x) => x[0] === load);\n    if (charge) {\n        return charge[1];\n    }\n    return 0;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    getCharge,\n});\n\n\n//# sourceURL=webpack:///./src/define.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! codemirror */ \"./node_modules/codemirror/lib/codemirror.js\");\n/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(codemirror__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var codemirror_addon_mode_simple__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! codemirror/addon/mode/simple */ \"./node_modules/codemirror/addon/mode/simple.js\");\n/* harmony import */ var codemirror_addon_mode_simple__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_mode_simple__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var codemirror_addon_comment_comment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! codemirror/addon/comment/comment */ \"./node_modules/codemirror/addon/comment/comment.js\");\n/* harmony import */ var codemirror_addon_comment_comment__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(codemirror_addon_comment_comment__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var codemirror_mode_python_python__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! codemirror/mode/python/python */ \"./node_modules/codemirror/mode/python/python.js\");\n/* harmony import */ var codemirror_mode_python_python__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_python_python__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! codemirror/lib/codemirror.css */ \"./node_modules/codemirror/lib/codemirror.css\");\n/* harmony import */ var _public_css_panda_syntax_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../public/css/panda-syntax.css */ \"./public/css/panda-syntax.css\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib */ \"./src/lib.ts\");\n/* harmony import */ var _define__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./define */ \"./src/define.ts\");\n/* harmony import */ var brython__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! brython */ \"./node_modules/brython/brython.js\");\n/* harmony import */ var brython__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(brython__WEBPACK_IMPORTED_MODULE_8__);\n\n\n\n\n\n\n\n\n\n\nconst unlockedPython = localStorage.getItem(\"I am aware of the dangers of this operation.\") ===\n    \"true\";\nObject.defineProperty(window, \"unlock\", {\n    get: () => {\n        const input = prompt(\"\\nI am aware of the dangers of this operation.\", \"\");\n        if (input === \"I am aware of the dangers of this operation.\") {\n            localStorage.setItem(\"I am aware of the dangers of this operation.\", \"true\");\n            window.location.reload();\n        }\n        else {\n            alert(\"\");\n        }\n        return () => undefined;\n    },\n});\nvoid (brython__WEBPACK_IMPORTED_MODULE_8___default());\nconst brython = window.brython;\nlet str = undefined;\nbrython.builtins.print = (s) => (str = s);\nbrython.builtins.JSON = JSON.stringify;\nfunction brython_err(str) {\n    console.error(str);\n    return str;\n}\nbrython.$raise = new Proxy(brython_err, {\n    apply: (target, thisarg) => {\n        try {\n            target(...thisarg);\n        }\n        catch (e) {\n            window.brython_error = e;\n            throw e;\n        }\n    },\n});\nfunction execPy(code) {\n    let output = str;\n    try {\n        window.pyexec(code);\n        output = str;\n        str = undefined;\n    }\n    catch ($err) {\n        console.error($err);\n        throw $err;\n    }\n    return output;\n}\nwindow.py = execPy;\n((window) => {\n    let command;\n    (function (command) {\n        command[command[\"set\"] = 0] = \"set\";\n        command[command[\"countTTK\"] = 1] = \"countTTK\";\n        command[command[\"countTTKuntil\"] = 2] = \"countTTKuntil\";\n        command[command[\"start\"] = 3] = \"start\";\n        command[command[\"end\"] = 4] = \"end\";\n        command[command[\"move\"] = 5] = \"move\";\n        command[command[\"action\"] = 6] = \"action\";\n        command[command[\"start_sort\"] = 7] = \"start_sort\";\n        command[command[\"end_sort\"] = 8] = \"end_sort\";\n        command[command[\"move_list\"] = 9] = \"move_list\";\n        command[command[\"buffset\"] = 10] = \"buffset\";\n        command[command[\"buffadd\"] = 11] = \"buffadd\";\n        command[command[\"buffminus\"] = 12] = \"buffminus\";\n        command[command[\"switch\"] = 13] = \"switch\";\n        command[command[\"order\"] = 14] = \"order\";\n        command[command[\"skillcard\"] = 15] = \"skillcard\";\n        command[command[\"color\"] = 16] = \"color\";\n        command[command[\"add\"] = 17] = \"add\";\n        command[command[\"nomove\"] = 18] = \"nomove\";\n    })(command || (command = {}));\n    const commandStr2Enum = (() => {\n        const output = {};\n        const command_list = [\n            \"set\",\n            \"countTTK\",\n            \"countTTKuntil\",\n            \"start\",\n            \"end\",\n            \"move\",\n            \"action\",\n            \"start_sort\",\n            \"end_sort\",\n            \"move_list\",\n            \"buffset\",\n            \"buffadd\",\n            \"buffminus\",\n            \"switch\",\n            \"order\",\n            \"skillcard\",\n            \"color\",\n            \"add\",\n            \"nomove\",\n        ];\n        command_list.forEach((x) => {\n            output[x] = command[x];\n        });\n        const shorthand_list = [\n            [\"ttk\", command.countTTK],\n            [\"ttk_until\", command.countTTKuntil],\n            [\"mv_ls\", command.move_list],\n            [\"b\", command.buffset],\n            [\"b+\", command.buffadd],\n            [\"b-\", command.buffminus],\n            [\"a\", command.add],\n            [\"m\", command.move],\n            [\"ac\", command.action],\n            [\"sw\", command.switch],\n            [\"c\", command.color],\n            [\"sc\", command.skillcard],\n        ];\n        shorthand_list.forEach(([str, toCommand]) => {\n            output[str] = toCommand;\n        });\n        return output;\n    })();\n    class parser_lexicallyAnalyze2AST {\n        constructor(lexically_analyzed) {\n            this.timeline_parsed = lexically_analyzed;\n            this.i_loading = 0;\n        }\n        get now_val() {\n            return this.timeline_parsed[this.i_loading];\n        }\n        set now_val(_) {\n            throw Error(\"now_val\");\n        }\n        get now_val_type() {\n            return this.now_val.type;\n        }\n        set now_val_type(_) {\n            throw Error(\"now_val\");\n        }\n        Normalize() {\n            const output = [];\n            let i;\n            const t = this;\n            const type = () => this.timeline_parsed[i].type;\n            for (i = 0; i < this.timeline_parsed.length; i++) {\n                if (type() === 4) {\n                    removeMeaninglessNewLine();\n                }\n                output.push(this.timeline_parsed[i]);\n            }\n            function removeMeaninglessNewLine() {\n                const i_toErrMsg = [i];\n                output.push(t.timeline_parsed[i]);\n                i++;\n                for (; i < t.timeline_parsed.length; i++) {\n                    if (i + 1 === t.timeline_parsed.length) {\n                        t.i_loading = (i_toErrMsg === null || i_toErrMsg === void 0 ? void 0 : i_toErrMsg[1]) || i_toErrMsg[0];\n                        t.error_unexpectedToken(\"]\");\n                    }\n                    if (type() === 4) {\n                        i_toErrMsg.push(i);\n                        removeMeaninglessNewLine();\n                    }\n                    else if (type() === 1) {\n                        continue;\n                    }\n                    else if (type() === 5) {\n                        i_toErrMsg.pop();\n                        break;\n                    }\n                    output.push(t.timeline_parsed[i]);\n                }\n            }\n            for (let i = 0, isBeforeNewLine = true; i < output.length; i++) {\n                if (output[i].type === 1) {\n                    if (isBeforeNewLine) {\n                        output.splice(i, 1);\n                        i--;\n                    }\n                    isBeforeNewLine = true;\n                }\n                else {\n                    isBeforeNewLine = false;\n                }\n            }\n            for (let i = output.length - 1; i >= 0; i--) {\n                if (output[i].type === 1) {\n                    output.pop();\n                }\n                else {\n                    break;\n                }\n            }\n            this.timeline_parsed = output;\n        }\n        parse() {\n            this.Normalize();\n            const output = [];\n            if (this.timeline_parsed.length === 0) {\n                return output;\n            }\n            this.timeline_parsed.push({\n                type: 1,\n                value: \"\\n\",\n            });\n            for (this.i_loading = 0; this.i_loading < this.timeline_parsed.length; this.i_loading++) {\n                const data = this.loadStatement();\n                output.push(data);\n                if (this.now_val_type !== 1) {\n                    this.error_unexpectedToken(\"]\");\n                }\n            }\n            return output;\n        }\n        loadStatement() {\n            let statementList = [];\n            this.checkIsWord();\n            const commmand_str = this.now_val.value;\n            const commmand = (() => {\n                const tmp = commandStr2Enum[commmand_str];\n                if (typeof tmp !== \"undefined\") {\n                    return tmp;\n                }\n                else {\n                    throw Error(\"\");\n                }\n            })();\n            this.nextVal();\n            const push = () => {\n                statementList.push(this.now_val.value);\n                this.nextVal();\n            };\n            if (commmand === command.move_list) {\n                this.checkIsWord();\n                const arg1 = this.now_val.value;\n                this.nextVal();\n                if (this.now_val_type !== 4) {\n                    this.error_unexpectedToken(\"move_list [ \");\n                }\n                this.nextVal();\n                const arg2 = [];\n                if (this.now_val_type !== 5) {\n                    while (true) {\n                        let list, val;\n                        switch (this.now_val_type) {\n                            case 4:\n                                this.nextVal();\n                                list = this.getMoveListInList(5);\n                                arg2.push({ mode: 0, value: list });\n                                break;\n                            case 6:\n                                this.nextVal();\n                                list = this.getMoveListInList(7);\n                                arg2.push({ mode: 1, value: list });\n                                break;\n                            case 2:\n                                this.nextVal();\n                                list = this.getCommandListInList();\n                                arg2.push({ mode: 2, value: list });\n                                break;\n                            case 9:\n                                val = { mode: 3, value: [] };\n                                val.value.push(this.now_val.value);\n                                arg2.push(val);\n                                this.nextVal();\n                                break;\n                            default:\n                                this.error_unexpectedToken(\"move_list\");\n                        }\n                        if (this.now_val_type === 5) {\n                            break;\n                        }\n                        else if (this.now_val_type === 0) {\n                            this.nextVal();\n                        }\n                        else {\n                            this.error_unexpectedToken(\"move_list]\");\n                        }\n                    }\n                }\n                statementList = [commmand, arg1, arg2];\n                this.nextVal();\n            }\n            else {\n                statementList = [commmand];\n                while (true) {\n                    if (this.now_val_type === 9) {\n                        push();\n                    }\n                    else if (this.now_val_type === 1) {\n                        break;\n                    }\n                    else {\n                        this.error_unexpectedToken(\"\");\n                    }\n                }\n            }\n            return statementList;\n        }\n        isLastValue() {\n            return this.i_loading + 1 >= this.timeline_parsed.length;\n        }\n        getCommandListInList() {\n            const endType = 3;\n            const output = [];\n            let i = 0;\n            loop: while (true) {\n                switch (this.now_val_type) {\n                    case 9:\n                        if (i === 0) {\n                            const command_num = commandStr2Enum[this.now_val.value];\n                            if (command_num) {\n                                output.push(command_num);\n                            }\n                            else {\n                                this.error_unexpectedToken(\"\");\n                            }\n                        }\n                        else {\n                            output.push(this.now_val.value);\n                        }\n                        this.nextVal();\n                        break;\n                    default:\n                        this.error_unexpectedToken(\"move_list\");\n                }\n                switch (this.now_val_type) {\n                    case endType:\n                        this.nextVal();\n                        break loop;\n                    case 0:\n                        this.nextVal();\n                        break;\n                    default:\n                        this.error_unexpectedToken(\"move_list\");\n                }\n                i++;\n            }\n            return output;\n        }\n        getMoveListInList(endType) {\n            const output = [];\n            if (this.now_val_type === endType) {\n                return output;\n            }\n            loop: while (true) {\n                switch (this.now_val_type) {\n                    case 9:\n                        output.push(this.now_val.value);\n                        this.nextVal();\n                        break;\n                    default:\n                        this.error_unexpectedToken(\"move_list\");\n                }\n                switch (this.now_val_type) {\n                    case endType:\n                        this.nextVal();\n                        break loop;\n                    case 0:\n                        this.nextVal();\n                        break;\n                    default:\n                        this.error_unexpectedToken(\"move_list\");\n                }\n            }\n            return output;\n        }\n        nextVal() {\n            if (this.isLastValue()) {\n                this.error_unexpectedToken(\"\");\n            }\n            this.i_loading++;\n        }\n        nextVal_noerror() {\n            if (!this.isLastValue()) {\n                this.i_loading++;\n            }\n        }\n        checkIsWord() {\n            if (this.now_val_type !== 9) {\n                this.error_unexpectedToken();\n            }\n        }\n        checkIsCommma() {\n            if (this.now_val_type !== 0) {\n                this.error_unexpectedToken();\n            }\n        }\n        error_unexpectedToken(errMsg = \"\") {\n            const output_err_where = _lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"span\");\n            output_err_where.appendChild(_lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"span\", \"\" + this.now_val.value + \"\", \"errMsg\"));\n            if (this.now_val.type !== 1) {\n                for (let i = this.i_loading + 1; i < this.timeline_parsed.length; i++) {\n                    if (this.timeline_parsed[i].type === 1) {\n                        break;\n                    }\n                    else {\n                        output_err_where.insertAdjacentText(\"beforeend\", this.timeline_parsed[i].value);\n                    }\n                }\n            }\n            for (let i = this.i_loading - 1; i >= 0; i--) {\n                if (this.timeline_parsed[i].type === 1) {\n                    break;\n                }\n                else {\n                    output_err_where.insertAdjacentText(\"afterbegin\", this.timeline_parsed[i].value);\n                }\n            }\n            if (this.now_val.type === 8) {\n                errMsg = \"\";\n            }\n            const output = _lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"span\");\n            output.insertAdjacentText(\"beforeend\", \": \" + JSON.stringify(this.now_val.value) + \"\");\n            output.appendChild(_lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"br\"));\n            output.appendChild(output_err_where);\n            output.appendChild(_lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"br\"));\n            output.insertAdjacentText(\"beforeend\", errMsg);\n            throw Error(output.outerHTML);\n        }\n    }\n    class parser_lexicallyAnalyze {\n        constructor(timeline_str) {\n            this.timeline_str = timeline_str;\n            this.timeline_parsed = [];\n            this._now_str = \"\";\n            this.i_nowloadstr = 0;\n        }\n        parse() {\n            this.timeline_parsed = this.lexicalAnalysis();\n            return this.timeline_parsed;\n        }\n        lexicalAnalysis() {\n            let string = this.timeline_str;\n            const output = [];\n            let tmp = \"\";\n            const space = \"\\u{20}\";\n            string = string.replaceAll(/\\\\(\\n|$)/g, \"\");\n            const parsed = (type, value) => ({\n                type,\n                value,\n            });\n            loop: for (let i = 0; i < string.length; i++) {\n                const char = string[i];\n                let val = { value: char };\n                const changeType = (type) => {\n                    val = {\n                        type: type,\n                        value: val.value,\n                    };\n                };\n                switch (char) {\n                    case \",\":\n                        changeType(0);\n                        break;\n                    case \"\\n\":\n                        changeType(1);\n                        break;\n                    case space:\n                    case \"\":\n                    case \"\\t\":\n                        push();\n                        continue;\n                    case \"#\":\n                        for (; i < string.length; i++) {\n                            if (string[i] === \"\\n\") {\n                                i--;\n                                continue loop;\n                            }\n                        }\n                        continue;\n                    case \"{\":\n                        changeType(2);\n                        break;\n                    case \"}\":\n                        changeType(3);\n                        break;\n                    case \"[\":\n                        changeType(4);\n                        break;\n                    case \"]\":\n                        changeType(5);\n                        break;\n                    case \"<\":\n                        changeType(6);\n                        break;\n                    case \">\":\n                        changeType(7);\n                        break;\n                    case \"(\":\n                    case \")\":\n                    case '\"':\n                    case \"'\":\n                    case \"!\":\n                    case \"$\":\n                    case \"%\":\n                    case \"&\":\n                    case \"=\":\n                    case \"^\":\n                    case \"~\":\n                    case \"*\":\n                    case \"?\":\n                    case \";\":\n                    case \"`\":\n                        changeType(8);\n                        break;\n                    default:\n                        tmp += char;\n                        continue loop;\n                }\n                push();\n                if (\"type\" in val) {\n                    output.push(val);\n                }\n                else {\n                    throw Error(\"\");\n                }\n            }\n            push();\n            function push() {\n                if (tmp.length > 0) {\n                    output.push(parsed(9, tmp));\n                    tmp = \"\";\n                }\n            }\n            return output;\n        }\n    }\n    class OperateURL {\n        constructor(_URL = location.href, autochange = true) {\n            this._href = _URL;\n            this._urlAPI = new URL(this._href);\n            this.autochange = autochange;\n        }\n        getParam(param) {\n            const val = this._urlAPI.searchParams.get(param) || \"\";\n            try {\n                return decodeURIComponent(val);\n            }\n            catch (_a) {\n                alert(val);\n                return val;\n            }\n        }\n        setParam(name, value = \"\") {\n            this._urlAPI.searchParams.set(name, value);\n            if (this.autochange) {\n                this._setURL(this._urlAPI.href);\n            }\n        }\n        get hash() {\n            return this._urlAPI.hash;\n        }\n        set hash(val) {\n            this._setURL(`#${val}`);\n        }\n        get href() {\n            return (this._urlAPI.protocol +\n                \"//\" +\n                this._urlAPI.host +\n                this._urlAPI.pathname +\n                \"?TL=\" +\n                encodeURIComponent(this.getParam(\"TL\")));\n        }\n        set href(val) {\n            this._urlAPI.href = val;\n        }\n        _setURL(arg3) {\n            if (this.autochange) {\n                history.replaceState(\"\", \"\", arg3);\n            }\n        }\n        _reflesh() {\n            this._urlAPI = new URL(this._href);\n        }\n    }\n    const url = new OperateURL(undefined, false);\n    class timeline {\n        constructor() {\n            this.current = [];\n            this.switchData = [];\n            this.cardData = [];\n            this.comment = [];\n            this.color = undefined;\n            this.place_of_currentTimeline = 0;\n        }\n        move(OrderValue, id = this.ID_of_firstChara(), canMoveWithout1stChara = false) {\n            this.setColor(id, this.place_of_currentTimeline);\n            if (id !== this.ID_of_firstChara() && canMoveWithout1stChara === false) {\n                throw new Error(\"\");\n            }\n            const moveChara_nowOrderValue = this.get_chara_by_ID(id).timeline_OrderValue;\n            const OrderValue_diff_between_1stchara_and_movechara = moveChara_nowOrderValue - this.OrderValue_of_firstChara();\n            const calculated_moved_OrderValue = moveChara_nowOrderValue +\n                OrderValue -\n                OrderValue_diff_between_1stchara_and_movechara;\n            this.pushChara(id, calculated_moved_OrderValue);\n            this.nextturn();\n        }\n        setColor(chara, place) {\n            if (this.color) {\n                this.comment.push([\"color\", chara, place, this.color]);\n                this.color = undefined;\n            }\n        }\n        setChara(id, initOrderValue) {\n            this.pushChara(id, initOrderValue);\n        }\n        place_to_moved(calculated_moved_OrderValue) {\n            let place_to_moved = -1;\n            for (let i = this.current.length - 1; i > this.place_of_currentTimeline; i--) {\n                if (calculated_moved_OrderValue >= this.current[i].timeline_OrderValue) {\n                    place_to_moved = i;\n                    break;\n                }\n            }\n            let output;\n            if (place_to_moved === -1) {\n                output = this.place_of_currentTimeline + 1;\n            }\n            else {\n                output = place_to_moved + 1;\n            }\n            return output;\n        }\n        pushChara(id, calculated_moved_OrderValue) {\n            let tmp_movechara;\n            try {\n                tmp_movechara = _lib__WEBPACK_IMPORTED_MODULE_6__.default.objectCopy(this.get_chara_by_ID(id));\n            }\n            catch (_a) {\n                tmp_movechara = { id };\n            }\n            tmp_movechara.timeline_OrderValue = calculated_moved_OrderValue;\n            const place_to_moved = this.place_to_moved(calculated_moved_OrderValue);\n            this.current.splice(place_to_moved, 0, tmp_movechara);\n        }\n        addChara(id, initOrderValue) {\n            const chara = {\n                id: id,\n                timeline_OrderValue: initOrderValue,\n                type: 0,\n            };\n            this.current.splice(this.place_of_currentTimeline, 0, chara);\n        }\n        addSkillCard(id, OrderValue, time, event) {\n            let current_card;\n            let isFoundCard = true;\n            try {\n                current_card = this.get_chara_by_ID(id);\n            }\n            catch (_a) {\n                isFoundCard = false;\n            }\n            if (isFoundCard) {\n                if (current_card) {\n                    if (current_card.type !== 1)\n                        throw Error(\"\");\n                    current_card.time = time;\n                    this.current[this.placeToChara(id)] = current_card;\n                }\n                else {\n                    throw Error(\"\");\n                }\n            }\n            else {\n                const target_ov = this.OrderValue_of_firstChara() + OrderValue;\n                const target_place = this.place_to_moved(target_ov);\n                event = event || ((..._) => undefined);\n                this.current.splice(target_place, 0, {\n                    type: 1,\n                    time,\n                    id,\n                    timeline_OrderValue: target_ov,\n                    OrderValue,\n                    event,\n                });\n                this.cardData.push([this.place_of_currentTimeline, id]);\n            }\n        }\n        switchChara(id_currentChara, id_switchToChara) {\n            this.switchData.push([\n                this.place_of_currentTimeline,\n                id_currentChara,\n                id_switchToChara,\n            ]);\n            this.setColor(id_currentChara, this.place_of_currentTimeline);\n            if (id_currentChara === this.ID_of_firstChara()) {\n                this.current[this.placeToChara(id_currentChara)].id = id_switchToChara;\n                this.current[this.placeToChara(id_switchToChara)].timeline_OrderValue =\n                    this.OrderValue_of_firstChara();\n            }\n            else {\n                this.switchSupportChara(id_currentChara, id_switchToChara);\n            }\n        }\n        switchSupportChara(id_currentChara, id_switchToChara) {\n            this.current.splice(this.placeToChara(id_currentChara), 1);\n            this.addChara(id_switchToChara, this.OrderValue_of_firstChara());\n        }\n        inited() {\n            this.current.sort(function (a, b) {\n                const a_OrderValue = a.timeline_OrderValue;\n                const b_OrderValue = b.timeline_OrderValue;\n                if (a_OrderValue < b_OrderValue)\n                    return -1;\n                if (a_OrderValue > b_OrderValue)\n                    return 1;\n                return 0;\n            });\n            this.place_of_currentTimeline = 0;\n        }\n        get firstChara() {\n            return this.current[this.place_of_currentTimeline];\n        }\n        set firstChara(_) {\n            throw Error(\"firstChara\");\n        }\n        OrderValue_of_firstChara() {\n            return this.firstChara.timeline_OrderValue;\n        }\n        ID_of_firstChara() {\n            return this.firstChara.id;\n        }\n        nextturn() {\n            this.place_of_currentTimeline++;\n            if (this.firstChara.type === 1) {\n                this.firstChara.event(this.firstChara.id, this.firstChara.OrderValue, this.firstChara.time);\n                this.firstChara.time--;\n                this.firstChara;\n                if (this.firstChara.time === 0) {\n                    this.nextturn();\n                }\n                else if (this.firstChara.time < 0) {\n                    throw Error(\"skillcardtime0\");\n                }\n                else {\n                    this.move(this.firstChara.OrderValue, this.ID_of_firstChara(), false);\n                }\n            }\n        }\n        skip() {\n            this.nextturn();\n        }\n        get_chara_by_ID(id) {\n            return this.current[this.placeToChara(id)];\n        }\n        placeToChara(id) {\n            for (let i = this.place_of_currentTimeline; i < this.current.length; i++) {\n                if (this.current[i].id === id) {\n                    return i;\n                }\n            }\n            throw Error(\"Not Found!ID\");\n        }\n    }\n    class chara {\n        constructor(id, SPD, SPD_buff, LoadFactorReduce = 0) {\n            this.id = id;\n            this.SPD = SPD;\n            this.SPD_buff = SPD_buff;\n            this.LoadFactorReduce = LoadFactorReduce;\n        }\n        calculateOrderValue(LoadFactor, LoadFactorReduce = 0) {\n            const SPD = this.SPD;\n            const SPD_buff = this.SPD_buff / 100;\n            const OrderValueRadix = Math.min(Math.max(124 - Math.floor(SPD / 2), 0), 100);\n            const OrderValue = Math.floor(OrderValueRadix *\n                (LoadFactor / 100) *\n                (1 - LoadFactorReduce) *\n                (1 - SPD_buff));\n            return Math.max(Math.min(OrderValue, 500), 15);\n        }\n        initOrderValue() {\n            return this.calculateOrderValue(100, 0);\n        }\n    }\n    let cm;\n    window.onload = () => {\n        const elm_csvDownload = document.getElementById(\"csvDownload\");\n        const elm_copyTL = document.getElementById(\"copyTL\");\n        const elm_copy_ConvertedTL = document.getElementById(\"copy_ConvertedTL\");\n        const elm_log_convertedTL = document.getElementById(\"log_convertedTL\");\n        const elm_jumpTwitter = document.getElementById(\"jumpTwitter\");\n        const elm_unzipMoveList = document.getElementById(\"unzipMoveList\");\n        const elm_Set_onbeforeunload = document.getElementById(\"isSet_onbeforeunload\");\n        const elm_pop11 = document.getElementById(\"pop11\");\n        const elm_editor = document.getElementById(\"editor\");\n        if (!((elm_csvDownload &&\n            elm_copyTL &&\n            elm_copy_ConvertedTL &&\n            elm_log_convertedTL &&\n            elm_jumpTwitter &&\n            elm_unzipMoveList &&\n            elm_Set_onbeforeunload &&\n            elm_pop11 &&\n            elm_editor))) {\n            throw _lib__WEBPACK_IMPORTED_MODULE_6__.default.undefinedErr;\n        }\n        codemirror__WEBPACK_IMPORTED_MODULE_0___default().defineSimpleMode(\"kirafan-timeline\", {\n            [\"start\"]: [\n                {\n                    regex: /(mv_ls|move_list)[ \\u3000]+/,\n                    token: \"keyword\",\n                    next: \"move_list\",\n                },\n                { regex: /[a-zA-Z_]+$/, token: \"keyword\" },\n                { regex: /[a-zA-Z_]+/, token: \"keyword\", next: \"arg\" },\n                { regex: /\\s+/ },\n                { regex: /#.*$/, token: \"comment\" },\n            ],\n            [\"move_list\"]: [\n                {\n                    regex: /(?:([^[\\s]+)(\\s*)(\\[))/,\n                    next: \"move_list_arg2\",\n                    token: [\"operator\", \"\", \"age\"],\n                },\n            ],\n            [\"move_list_arg2\"]: [\n                { regex: /\\s+/ },\n                { regex: /\\]/, token: \"unit\", next: \"start\" },\n                {\n                    regex: /(\\[)(\\s*)([^\\]\\s*,]+)/,\n                    token: [\"unit\", \"\", \"string-3\"],\n                    next: \"mvls_switch\",\n                },\n                {\n                    regex: /(\\{)(\\s*)([^}\\s*,]+)/,\n                    token: [\"unit\", \"\", \"keyword\"],\n                    next: \"mvls_command\",\n                },\n                {\n                    regex: /(<)(\\s*)([^>\\s*,]+)/,\n                    token: [\"unit\", \"\", \"string-3\"],\n                    next: \"mvls_order\",\n                },\n            ],\n            [\"mvls_switch\"]: [\n                { regex: /\\s+/ },\n                {\n                    regex: /,/,\n                },\n                { regex: /\\]/, token: \"unit\", next: \"move_list_arg2\" },\n                {\n                    regex: /[^\\s\\],]+/,\n                    token: \"string-3\",\n                },\n            ],\n            [\"mvls_command\"]: [\n                { regex: /\\s+/ },\n                {\n                    regex: /,/,\n                },\n                { regex: /\\}/, token: \"unit\", next: \"move_list_arg2\" },\n                {\n                    regex: /[^\\s},]+/,\n                    token: \"string-3\",\n                },\n            ],\n            [\"mvls_order\"]: [\n                { regex: /\\s+/ },\n                {\n                    regex: /,/,\n                },\n                { regex: />/, token: \"unit\", next: \"move_list_arg2\" },\n                {\n                    regex: /[^\\s>,]+/,\n                    token: \"string-3\",\n                },\n            ],\n            [\"arg\"]: [\n                { regex: /[^#]*$/, token: \"arg\", next: \"start\" },\n                { regex: /[^#]*/, token: \"arg\", next: \"start\" },\n                { regex: /#.*$/, token: \"comment\" },\n            ],\n            [\"comment\"]: [\n                { regex: /.*?$/, token: \"comment\", next: \"start\" },\n            ],\n            meta: {\n                dontIndentStates: [\"comment\"],\n                lineComment: \"#\",\n                fold: \"brace\",\n            },\n        });\n        const TLparam = url.getParam(\"TL\");\n        let str = \"\";\n        if (typeof TLparam !== null) {\n            str = TLparam;\n        }\n        cm = codemirror__WEBPACK_IMPORTED_MODULE_0___default()(elm_editor, {\n            mode: window.python ? \"python\" : \"kirafan-timeline\",\n            lineNumbers: true,\n            indentUnit: 4,\n            theme: \"panda-syntax\",\n            lineWrapping: true,\n            tabSize: 2,\n            value: str,\n        });\n        cm.scrollTo(3, 3);\n        cm.on(\"change\", () => {\n            main();\n        });\n        cm.on(\"keydown\", (cm, e) => {\n            if (e.key === \"/\" && e.ctrlKey) {\n                cm.toggleComment({ lineComment: \"#\" });\n            }\n        });\n        elm_csvDownload.onclick = outputAsCSV;\n        elm_copyTL.onclick = copyDataAsURL;\n        elm_log_convertedTL.onclick = printConvertedTL;\n        elm_copy_ConvertedTL.onclick = copyConvertedTL;\n        elm_jumpTwitter.onclick = () => {\n            window.open(\"https://twitter.com/Y52en/status/1402239605978517505?s=20\", \"_blank\");\n        };\n        elm_unzipMoveList.onclick = () => {\n            elm_pop11.checked = true;\n        };\n        window.onbeforeunload = function (e) {\n            save();\n            if (cm.getValue().length !== 0 && elm_Set_onbeforeunload.checked) {\n                e.preventDefault();\n                e.returnValue = \"\";\n            }\n        };\n        main();\n    };\n    let tableData;\n    let convertedTLdata;\n    function save() {\n        const nowUrlTlParam = new OperateURL(location.href).getParam(\"TL\");\n        const title = String(new Date()) + \":TL\";\n        if (nowUrlTlParam !== url.getParam(\"TL\")) {\n            if (nowUrlTlParam.length === 0) {\n                history.pushState(null, title, url.href);\n            }\n            else {\n                history.replaceState(null, title, url.href);\n            }\n            _lib__WEBPACK_IMPORTED_MODULE_6__.default.changeTitle(title);\n        }\n    }\n    (() => {\n        setInterval(() => {\n            save();\n        }, 1000 * 60 * 5);\n    })();\n    function transfer(arr) {\n        return arr.map((x) => {\n            const output = [];\n            const commmand_str = x[0];\n            const cmd = (() => {\n                const tmp = commandStr2Enum[commmand_str];\n                if (typeof tmp !== \"undefined\") {\n                    return tmp;\n                }\n                else {\n                    throw Error(\"\");\n                }\n            })();\n            output.push(cmd);\n            for (let i = 1; i < x.length; i++) {\n                const type = typeof x[i];\n                if (type === \"number\") {\n                    output.push(String(x[i]));\n                }\n                else if (type === \"string\") {\n                    output.push(x[i]);\n                }\n                else if (Array.isArray(x[i])) {\n                    if (cmd === command.move_list) {\n                        const tmp = x[i].map((elem) => {\n                            elem.mode = elem.mode;\n                            const is_mode_command = elem.mode === 2;\n                            if (is_mode_command) {\n                                elem.value[0] = commandStr2Enum[elem.value[0]];\n                            }\n                            for (let j = Number(is_mode_command); j < elem.value.length; j++) {\n                                if (typeof elem.value[j] === \"number\") {\n                                    elem.value[j] = String(elem.value[j]);\n                                }\n                            }\n                            return elem;\n                        });\n                        output.push(tmp);\n                    }\n                    else {\n                        throw Error(\"move_list\");\n                    }\n                }\n                else {\n                    throw Error(\": \" + JSON.stringify(x) + \" -> \" + x[i]);\n                }\n            }\n            return output;\n        });\n    }\n    function main() {\n        var _a, _b, _c, _d, _e;\n        const err = document.getElementById(\"error\");\n        const info = document.getElementById(\"info\");\n        let str;\n        if (cm) {\n            str = cm.getValue();\n        }\n        else {\n            throw _lib__WEBPACK_IMPORTED_MODULE_6__.default.undefinedErr;\n        }\n        window.python = Boolean(str.match(/^#python#\\n/));\n        const isPython = window.python && unlockedPython;\n        url.setParam(\"TL\", str);\n        convertedTLdata = { main: [], set: [] };\n        const chara_list = {};\n        const TL = new timeline();\n        const chara_move_list = {};\n        if (!err || !info) {\n            throw _lib__WEBPACK_IMPORTED_MODULE_6__.default.undefinedErr;\n        }\n        err.innerHTML = \"\";\n        info.innerHTML = \"\";\n        let parsed_tldata;\n        const count_ttk_ls = {};\n        let ttk = 0;\n        let ttk_count_until = Infinity;\n        const add_ttk = (n) => {\n            if (TL.place_of_currentTimeline < ttk_count_until) {\n                ttk += n;\n            }\n        };\n        try {\n            if (isPython) {\n                const tmp = `_output = []\n\n_command__ = [\n    \"set\",\n    \"countTTK\",\n    \"countTTKuntil\",\n    \"start\",\n    \"end\",\n    \"move\",\n    \"action\",\n    \"start_sort\",\n    \"end_sort\",\n    \"move_list\",\n    \"buffset\",\n    \"buffadd\",\n    \"buffminus\",\n    \"switch\",\n    \"order\",\n    \"skillcard\",\n    \"color\",\n    \"add\",\n    \"nomove\"\n]\n\n\ndef _command_fn(command, *args):\n    tmp = [command]\n    tmp += list(args)\n    _output.append(tmp)\n\n\nclass _wrapper_command:\n    def __init__(self, command):\n        self.command = command\n        self.isCommand = True\n\n    def __call__(self, *args):\n        _command_fn(self.command, *args)\n\n\nfor _cmd__ in _command__:\n    globals()[_cmd__] = _wrapper_command(_cmd__)\n\n\nttk = countTTK\nttk_until = countTTKuntil\nmv_ls = move_list\nbs = buffset\nbp = buffadd\nbm = buffminus\n# a = add\n# m = move\n# ac = action\nsw = switch\n# c = color\nsc = skillcard\n\n\ndef ___set(*args):\n\tglobals()[list(args)[0]] = list(args)[0]\n\t_wrapper_command(\"set\")(*args)\n\nset = ___set\n\n\n\n# b-10 -> \"b10\"\nclass _color__():\n\n    def __init__(self, color):\n        self.color = color\n\n    def __sub__(self, num):\n        return self.color + str(num)\n\n\nfor _alp_num in range(26):\n    alphabet = str(chr(_alp_num + 97))\n    globals()[alphabet] = _color__(alphabet)\n\n\nclass _mv_ls():\n    def __call__(self):\n        return _color__(\"m\")\n\n#     def _str(self, arg):\n#         ___output = []\n#         for i in list(arg):\n#             ___output.append(str(i))\n#         return __output \n\n    def _obj(self, mode, arg):\n        return {\"mode\": mode, \"value\": list(arg)}\n\n    def s(self, *args):\n        return self._obj(0, args)\n\n    def o(self, *args):\n        return self._obj(1, args)\n\n    def c(self, *args):\n        args = list(args)\n        if args[0].isCommand != True:\n            raise Exception(\"args[0] must be command function\")\n        args[0] = args[0].command\n        return self._obj(2, args)\n\n    def a(self, *args):\n        return self._obj(3, args)\n\n\nm = _mv_ls()\n\n# print(a-10)\n######################\n` +\n                    str +\n                    `\n######################\n\nm = _mv_ls()\nfor (i, cmd) in enumerate(_output):\n    if(cmd[0] == \"move_list\"):\n        for (j, o) in enumerate(cmd[2]):\n            o_type = type(o)\n\n            if(o_type == int or o_type == float or o_type == str):\n                _output[i][2][j] = m.a(o)\n            elif(o_type == list):\n                _output[i][2][j] = m.s(*o)\n\n\nprint(str(_output))\n\n`;\n                const tl_json = JSON.parse((_a = execPy(tmp)) === null || _a === void 0 ? void 0 : _a.replaceAll(\"'\", '\"'));\n                parsed_tldata = transfer(tl_json);\n            }\n            else {\n                const tl_parser_lexicallyAnalyze = new parser_lexicallyAnalyze(str);\n                const lexicallyAnalyzed = tl_parser_lexicallyAnalyze.parse();\n                const tl_parser_AST = new parser_lexicallyAnalyze2AST(lexicallyAnalyzed);\n                parsed_tldata = tl_parser_AST.parse();\n            }\n        }\n        catch (e) {\n            err.innerHTML = String(e);\n            throw e;\n        }\n        let mode = 0;\n        for (let i = 0; i < parsed_tldata.length; i++) {\n            try {\n                const load_text_command = (_b = parsed_tldata[i]) === null || _b === void 0 ? void 0 : _b[0];\n                const load_text_arg1 = (_c = parsed_tldata[i]) === null || _c === void 0 ? void 0 : _c[1];\n                const load_text_arg2 = (_d = parsed_tldata[i]) === null || _d === void 0 ? void 0 : _d[2];\n                const load_text_arg3 = (_e = parsed_tldata[i]) === null || _e === void 0 ? void 0 : _e[3];\n                let id, SPD, buff, LoadFactor, LoadFactor_list, to, from, ordervalue, statement, ttk_ls;\n                switch (mode) {\n                    case 0:\n                        switch (load_text_command) {\n                            case command.set:\n                                id = load_text_arg1.toString();\n                                SPD = Number(load_text_arg2);\n                                buff = Number(load_text_arg3) || 0;\n                                chara_list[id] = new chara(id, SPD, buff);\n                                TL.setChara(id, chara_list[id].initOrderValue());\n                                if (convertedTLdata.set.length === 0) {\n                                    convertedTLdata.set = [parsed_tldata[i]];\n                                }\n                                else {\n                                    convertedTLdata.set.push(parsed_tldata[i]);\n                                }\n                                break;\n                            case command.countTTK:\n                                ttk_ls = parsed_tldata[i].slice(1);\n                                ttk_ls.forEach((v) => {\n                                    if (typeof v === \"string\") {\n                                        count_ttk_ls[v] = true;\n                                    }\n                                });\n                                break;\n                            case command.countTTKuntil:\n                                ttk_count_until = Number(load_text_arg1) || Infinity;\n                                break;\n                            case command.start:\n                                mode = 1;\n                                TL.inited();\n                                break;\n                            case command.start_sort:\n                                mode = 2;\n                                TL.inited();\n                                break;\n                            default:\n                                throw Error(\"need 'start'\");\n                        }\n                        break;\n                    case 1:\n                        statement = parsed_tldata[i];\n                        if (statement[0] !== command.move_list) {\n                            mainMode(...statement);\n                        }\n                        else {\n                            throw Error(\"start_sort ~ end_sortmove_list\");\n                        }\n                        break;\n                    case 2:\n                        switch (load_text_command) {\n                            case command.move_list:\n                                id = load_text_arg1;\n                                LoadFactor_list = load_text_arg2;\n                                chara_move_list[id] = LoadFactor_list;\n                                break;\n                            case command.end_sort:\n                                sorting();\n                                mode = 4;\n                                break;\n                            default:\n                                throw Error(\"no command found:\" + load_text_command + \"\");\n                        }\n                        break;\n                    case 4:\n                        switch (load_text_command) {\n                            case command.start:\n                                mode = 1;\n                                break;\n                            case command.start_sort:\n                                mode = 2;\n                                break;\n                            default:\n                                throw Error(\"need 'start'\");\n                        }\n                        break;\n                    default:\n                        throw Error(\"\");\n                }\n                function sorting() {\n                    var _a;\n                    while (true) {\n                        const id = TL.ID_of_firstChara();\n                        if (((_a = chara_move_list[id]) === null || _a === void 0 ? void 0 : _a[0]) === undefined) {\n                            const output = {};\n                            Object.keys(chara_move_list).forEach(function (key) {\n                                if (chara_move_list[key].length !== 0) {\n                                    output[key] = chara_move_list[key];\n                                }\n                            });\n                            if (Object.keys(output).length !== 0) {\n                                if (!info)\n                                    throw _lib__WEBPACK_IMPORTED_MODULE_6__.default.undefinedErr;\n                                info.insertAdjacentText(\"beforeend\", \"info :move_list:\" +\n                                    JSON.stringify(Object.fromEntries(Object.entries(output).map(([key, value]) => [\n                                        key,\n                                        value.map((x) => {\n                                            if (x.value.length > 0) {\n                                                if (x.mode === 2) {\n                                                    x.value[0] = command[x.value[0]];\n                                                }\n                                            }\n                                            if (x.value.length === 1) {\n                                                x.value = x.value[0];\n                                            }\n                                            return x.value;\n                                        }),\n                                    ]))).replaceAll('\"', \"\"));\n                            }\n                            break;\n                        }\n                        const input = chara_move_list[id].shift();\n                        if (!input)\n                            throw Error(\"\");\n                        try {\n                            if (input.mode === 1) {\n                                const [Color_OrderValue] = input.value;\n                                const Color = Color_OrderValue.match(/^[a-zA-Z]/g);\n                                const OrderValue = Color_OrderValue.match(/\\d+/g);\n                                if (Color)\n                                    mainMode(command.color, Color[0]);\n                                if (OrderValue) {\n                                    mainMode(command.order, id, OrderValue[0]);\n                                }\n                                else {\n                                    throw Error(\"\");\n                                }\n                            }\n                            else if (input.mode === 3) {\n                                const [Color_LoadFactor] = input.value;\n                                const Color = Color_LoadFactor.match(/^[a-zA-Z]/g);\n                                const LoadFactor = Color_LoadFactor.match(/\\d+/g);\n                                if (Color)\n                                    mainMode(command.color, Color[0]);\n                                if (LoadFactor) {\n                                    mainMode(command.action, id, LoadFactor[0]);\n                                }\n                                else {\n                                    throw Error(\"\");\n                                }\n                            }\n                            else if (input.mode === 0) {\n                                const [to_name, SPD, buff] = input.value;\n                                mainMode(command.switch, id, to_name, SPD, buff || \"0\");\n                                chara_move_list[to_name] = chara_move_list[id];\n                                chara_move_list[id] = [];\n                            }\n                            else if (input.mode === 2) {\n                                mainMode(...input.value);\n                            }\n                            else {\n                                throw Error(\"\");\n                            }\n                        }\n                        catch (e) {\n                            throw Error(e + \":  \" + JSON.stringify(input.value) + \" \");\n                        }\n                    }\n                }\n                function mainMode(...arg) {\n                    const [load_text_command, load_text_arg1, load_text_arg2, load_text_arg3, load_text_arg4,] = arg;\n                    if (load_text_command !== command.end) {\n                        const tmp = arg;\n                        tmp[0] = command[load_text_command];\n                        if (convertedTLdata.main.length === 0) {\n                            convertedTLdata.main = [];\n                        }\n                        convertedTLdata.main.push(tmp);\n                    }\n                    let id, buff, color, name, spd, time, skillcard, canMoveWithout1stChara;\n                    switch (load_text_command) {\n                        case command.buffset:\n                            id = load_text_arg1;\n                            buff = Number(load_text_arg2) || 0;\n                            chara_list[id].SPD_buff = buff;\n                            break;\n                        case command.buffadd:\n                            id = load_text_arg1;\n                            buff = Number(load_text_arg2) || 0;\n                            chara_list[id].SPD_buff += buff;\n                            break;\n                        case command.buffminus:\n                            id = load_text_arg1;\n                            buff = Number(load_text_arg2) || 0;\n                            chara_list[id].SPD_buff -= buff;\n                            break;\n                        case command.add:\n                            id = load_text_arg1;\n                            SPD = Number(load_text_arg2);\n                            buff = Number(load_text_arg3) || 0;\n                            chara_list[id] = new chara(id, SPD, buff);\n                            TL.addChara(id, chara_list[id].initOrderValue());\n                            break;\n                        case command.move:\n                        case command.action:\n                            if (load_text_command === command.move) {\n                                LoadFactor = Number(load_text_arg1);\n                                id = load_text_arg2;\n                            }\n                            else {\n                                id = load_text_arg1;\n                                LoadFactor = Number(load_text_arg2);\n                            }\n                            canMoveWithout1stChara = load_text_arg3 === \"true\";\n                            if (count_ttk_ls[id]) {\n                                add_ttk(_define__WEBPACK_IMPORTED_MODULE_7__.default.getCharge(LoadFactor, false));\n                            }\n                            TL.move(chara_list[TL.ID_of_firstChara()].calculateOrderValue(LoadFactor), id, canMoveWithout1stChara);\n                            break;\n                        case command.order:\n                            id = load_text_arg1;\n                            ordervalue = Number(load_text_arg2);\n                            TL.move(ordervalue, id, false);\n                            break;\n                        case command.switch:\n                            to = load_text_arg1;\n                            from = load_text_arg2;\n                            SPD = Number(load_text_arg3);\n                            buff = Number(load_text_arg4) || 0;\n                            TL.switchChara(to, from);\n                            chara_list[from] = new chara(from, SPD, buff);\n                            break;\n                        case command.color:\n                            color = load_text_arg1;\n                            TL.color = color;\n                            break;\n                        case command.skillcard:\n                            name = load_text_arg1;\n                            spd = Number(load_text_arg2);\n                            LoadFactor = Number(load_text_arg3);\n                            time = Number(load_text_arg4);\n                            if ([spd, LoadFactor, time].includes(NaN)) {\n                                throw Error(\"\");\n                            }\n                            skillcard = new chara(name, spd, 0);\n                            chara_list[name] = skillcard;\n                            TL.addSkillCard(name, skillcard.calculateOrderValue(LoadFactor), time, (id, _, _i) => add_ttk(count_ttk_ls[id]\n                                ? _define__WEBPACK_IMPORTED_MODULE_7__.default.getCharge(Number(load_text_arg3), true)\n                                : 0));\n                            break;\n                        case command.nomove:\n                            TL.skip();\n                            break;\n                        case command.end:\n                            mode = 4;\n                            break;\n                        default:\n                            throw Error(\"no command found\");\n                    }\n                }\n            }\n            catch (e) {\n                err.appendChild(_lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"br\"));\n                err.insertAdjacentText(\"beforeend\", String(e));\n                break;\n            }\n        }\n        const chara_array = [];\n        for (const i in chara_list) {\n            chara_array.push(i);\n        }\n        const outputTL = Array.from(new Array(Object.keys(chara_list).length), () => new Array(TL.current.length).fill(undefined));\n        TL.current.forEach((i, index) => {\n            const chara_id = i.id;\n            const OrderValue = i.timeline_OrderValue;\n            const charaPlace = chara_array.indexOf(chara_id);\n            outputTL[charaPlace][index] = OrderValue;\n        });\n        TL.switchData.forEach((x) => {\n            const [place, from_id, to_id] = x;\n            const from_charaPlace = chara_array.indexOf(from_id);\n            const to_charaPlace = chara_array.indexOf(to_id);\n            let arrow_str = \"\";\n            if (from_charaPlace < to_charaPlace) {\n                arrow_str = \"\";\n            }\n            else {\n                arrow_str = \"\";\n            }\n            outputTL[from_charaPlace][place] = arrow_str;\n        });\n        TL.cardData.forEach((x) => {\n            const charaPlace = chara_array.indexOf(x[1]);\n            outputTL[charaPlace][x[0]] = \"\";\n        });\n        const now_place = TL.place_of_currentTimeline + 1;\n        const elm_firstchara = document.getElementById(\"firstchara\");\n        if (elm_firstchara)\n            elm_firstchara.innerText = TL.ID_of_firstChara();\n        const elm_now_place = document.getElementById(\"now_place\");\n        if (elm_now_place)\n            elm_now_place.innerText = String(now_place);\n        tableData = [outputTL, chara_array];\n        outputAsTable(outputTL, chara_array, TL.comment, now_place);\n        printConvertedTL();\n        document.querySelectorAll(\".ttk\").forEach((elm) => {\n            if (Object.values(count_ttk_ls).filter((x) => x).length === 0) {\n                elm.classList.add(\"display-none\");\n            }\n            else {\n                elm.classList.remove(\"display-none\");\n                document.querySelectorAll(\".ttk-value\").forEach((elm) => {\n                    elm.textContent = String(ttk);\n                });\n            }\n        });\n    }\n    function outputAsTable(json, charalist, comment, now_place) {\n        const output = _lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"thead\");\n        const inner_tr = _lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"tr\");\n        for (let i = 0; i <= json[0].length; i++) {\n            let tmp;\n            if (i === now_place) {\n                tmp = _lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"th\", i.toString(), \"now_place\");\n            }\n            else if (i === 0) {\n                tmp = _lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"th\", \"\", \"nowrap\");\n            }\n            else {\n                tmp = _lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"th\", i.toString());\n            }\n            inner_tr.appendChild(tmp);\n        }\n        output.appendChild(inner_tr);\n        for (let x = 0; x < json.length; x++) {\n            const main_tl = _lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"tr\");\n            main_tl.appendChild(_lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"td\", charalist[x], \"nowrap\"));\n            for (let y = 0; y < json[0].length; y++) {\n                let tmp;\n                const find = comment.find((elm) => elm[0] === \"color\" && elm[1] === charalist[x] && elm[2] === y);\n                const inner_tmp = json[x][y];\n                let inner_tmp_string;\n                if (typeof inner_tmp === \"string\") {\n                    inner_tmp_string = inner_tmp;\n                }\n                else if (typeof inner_tmp === \"number\") {\n                    inner_tmp_string = String(inner_tmp);\n                }\n                else {\n                    inner_tmp_string = \"\";\n                }\n                if (find) {\n                    tmp = _lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"td\", inner_tmp_string, \"color-\" + find[3]);\n                }\n                else {\n                    tmp = _lib__WEBPACK_IMPORTED_MODULE_6__.default.htmltag(\"td\", inner_tmp_string);\n                }\n                main_tl.appendChild(tmp);\n            }\n            output.appendChild(main_tl);\n        }\n        const target_elm = document.querySelector(\"table\");\n        if (target_elm) {\n            target_elm.innerHTML = \"\";\n            target_elm.appendChild(output);\n        }\n        else {\n            throw _lib__WEBPACK_IMPORTED_MODULE_6__.default.undefinedErr;\n        }\n    }\n    function outputAsCSV() {\n        const [json, charalist] = tableData;\n        let output = \"\";\n        for (let i = 0; i < json[0].length; i++) {\n            output += \",\" + (i + 1);\n        }\n        output += \"\\n\";\n        for (let x = 0; x < json.length; x++) {\n            output += charalist[x];\n            for (let y = 0; y < json[0].length; y++) {\n                output += \",\";\n                output += json[x][y] || \"\";\n            }\n            output += \"\\n\";\n        }\n        makeCSVfile_download(output);\n    }\n    function makeCSVfile_download(csv, fileName = \"timeline.csv\") {\n        const bom = new Uint8Array([0xef, 0xbb, 0xbf]);\n        const blob = new Blob([bom, csv], { type: \"text/csv\" });\n        const blobUrl = URL.createObjectURL(blob);\n        const link = document.createElement(\"a\");\n        link.href = blobUrl;\n        link.download = fileName;\n        link.style.display = \"none\";\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        URL.revokeObjectURL(blobUrl);\n    }\n    function copyDataAsURL() {\n        _lib__WEBPACK_IMPORTED_MODULE_6__.default.textCopy(url.href);\n        const copyed = document.getElementById(\"copyed\");\n        if (copyed) {\n            copyed.style.display = \"block\";\n            setTimeout(() => {\n                copyed.style.display = \"none\";\n            }, 1000);\n        }\n        else {\n            throw _lib__WEBPACK_IMPORTED_MODULE_6__.default.undefinedErr;\n        }\n    }\n    function printConvertedTL() {\n        const popup_elm = document.getElementById(\"popup\");\n        if (popup_elm) {\n            popup_elm.innerText = joinedTLdata();\n        }\n        else {\n            throw _lib__WEBPACK_IMPORTED_MODULE_6__.default.undefinedErr;\n        }\n    }\n    function copyConvertedTL() {\n        _lib__WEBPACK_IMPORTED_MODULE_6__.default.textCopy(joinedTLdata());\n        const copyed = document.getElementById(\"copyed_popup\");\n        if (copyed) {\n            copyed.style.display = \"block\";\n            setTimeout(() => {\n                copyed.style.display = \"none\";\n            }, 1000);\n        }\n        else {\n            throw _lib__WEBPACK_IMPORTED_MODULE_6__.default.undefinedErr;\n        }\n    }\n    function joinedTLdata() {\n        return (convertedTLdata.set\n            .map((x) => {\n            if (x) {\n                return x.join(\" \");\n            }\n            else {\n                return \"\";\n            }\n        })\n            .join(\"\\n\") +\n            \"\\n\\nstart\\n\" +\n            convertedTLdata.main\n                .map((x) => {\n                if (x) {\n                    return \"  \" + x.join(\" \");\n                }\n                else {\n                    return \"\";\n                }\n            })\n                .join(\"\\n\") +\n            \"\\nend\");\n    }\n})(window);\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/lib.ts":
/*!********************!*\
  !*** ./src/lib.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/cloneDeep */ \"./node_modules/lodash/cloneDeep.js\");\n/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0__);\n\nconst undefinedErr = Error(\"undefined\");\nfunction htmltag(name, inner = \"\", Class = \"\") {\n    const output = document.createElement(name);\n    if (output) {\n        if (inner)\n            output.innerText = inner;\n        if (Class)\n            output.classList.add(Class);\n        return output;\n    }\n    else {\n        throw undefinedErr;\n    }\n}\nfunction changeTitle(title) {\n    const elm_title = document.querySelector(\"title\");\n    if (elm_title) {\n        elm_title.innerText = title;\n    }\n    else {\n        throw undefinedErr;\n    }\n}\nfunction objectCopy(obj) {\n    return lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_0___default()(obj);\n}\nfunction textCopy(textVal) {\n    const copyFrom = document.createElement(\"textarea\");\n    copyFrom.textContent = textVal;\n    const bodyElm = document.getElementsByTagName(\"body\")[0];\n    bodyElm.appendChild(copyFrom);\n    copyFrom.select();\n    const retVal = document.execCommand(\"copy\");\n    bodyElm.removeChild(copyFrom);\n    return retVal;\n}\nfunction makeTable(headers, data) {\n    const table = htmltag(\"table\");\n    const thead = htmltag(\"thead\");\n    const tr = htmltag(\"tr\");\n    for (const header of headers) {\n        const th = htmltag(\"th\");\n        th.innerText = header;\n        tr.appendChild(th);\n    }\n    thead.appendChild(tr);\n    table.appendChild(thead);\n    const tbody = htmltag(\"tbody\");\n    for (const row of data) {\n        const tr = htmltag(\"tr\");\n        for (const col of row) {\n            const td = htmltag(\"td\");\n            td.innerText = col;\n            tr.appendChild(td);\n        }\n        tbody.appendChild(tr);\n    }\n    table.appendChild(tbody);\n    return table;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    undefinedErr,\n    htmltag,\n    changeTitle,\n    objectCopy,\n    textCopy,\n    makeTable,\n});\n\n\n//# sourceURL=webpack:///./src/lib.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;